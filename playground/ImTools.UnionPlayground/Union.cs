// <auto-generated/>
/*
The MIT License (MIT)

Copyright (c) 2016-2022 Maksim Volkau

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// ReSharper disable once InconsistentNaming

namespace ImTools;

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices; // For [MethodImpl(AggressiveInlining)]


/// <summary>Replacement for `Void` type which can be used as a type argument and value.
/// In traditional functional languages this type is a singleton empty record type,
/// e.g. `()` in Haskell https://en.wikipedia.org/wiki/Unit_type </summary>
public struct Unit : IEquatable<Unit>
{
    /// Singleton unit value - making it a lower-case so you could import `using static ImTools.Unit;` and write `return unit;`
    public static readonly Unit unit = new Unit();

    /// <inheritdoc />
    public override string ToString() => "(unit)";

    /// Equals to any other Unit
    public bool Equals(Unit other) => true;

    /// <inheritdoc />
    public override bool Equals(object obj) => obj is Unit;

    /// Using type hash code for the value
    public override int GetHashCode() => typeof(Unit).GetHashCode();
}

/// Simple value provider interface - useful for the type pattern matching via `case I{T} x: ...`
public interface I<out T>
{
    /// The value in this case ;)
    T Value { get; }
}

/// Helpers for `Is` and `Union`
public static class UnionTools
{
    /// Pretty prints the Union using the type information
    internal static string ToString<TName, T>(T value, string prefix = "case(", string suffix = ")")
    {
        if (typeof(TName) == typeof(Unit))
            return prefix + value + suffix;

        var typeName = typeof(TName).Name;
        var i = typeName.IndexOf('`');
        var name = i == -1 ? typeName : typeName.Substring(0, i);
        return name + prefix + value + suffix;
    }
}

/// Wraps the `T` in a typed `TItem` struct value in a one-line declaration,
/// so the <c><![CDATA[class Name : Case<Name, string>]]></c>
/// is different from the <c><![CDATA[class Address : Case<Address, string>]]></c> 
public abstract class Item<TItem, T> where TItem : Item<TItem, T>
{
    /// Creation method for the consistency with other types
    public static item Of(T x) => new item(x);

    /// Nested structure that hosts a value.
    /// All nested types by convention here are lowercase
    public readonly struct item : IEquatable<item>, I<T>
    {
        /// <inheritdoc />
        public T Value { [MethodImpl((MethodImplOptions)256)] get => Item; }

        /// The value
        public readonly T Item;

        /// Constructor
        public item(T x) => Item = x;

        /// <inheritdoc />
        public bool Equals(item other) => EqualityComparer<T>.Default.Equals(Value, other.Value);

        /// <inheritdoc />
        public override bool Equals(object obj) => obj is item c && Equals(c);

        /// <inheritdoc />
        public override int GetHashCode() => EqualityComparer<T>.Default.GetHashCode(Value);

        /// <inheritdoc />
        public override string ToString() => UnionTools.ToString<TItem, T>(Value);
    }
}

/// Item without the data payload
public abstract class Item<TItem> where TItem : Item<TItem>
{
    /// Single item value
    public static readonly item Value = new item();

    /// Nested structure that hosts a value.
    /// All nested types by convention here are lowercase
    public readonly struct item : IEquatable<item>
    {
        /// <inheritdoc />
        public bool Equals(item other) => true;

        /// <inheritdoc />
        public override bool Equals(object obj) => obj is item;

        /// <inheritdoc />
        public override int GetHashCode() => typeof(TItem).GetHashCode();

        /// <inheritdoc />
        public override string ToString() => "(" + typeof(TItem).Name + ")";
    }
}

/// Wraps the `T` in a named `TBox` class in a one-line declaration,
/// so the <c><![CDATA[class Name : Box<Name, string>]]></c>
/// is different from the <c><![CDATA[class Address : Box<Address, string>]]></c> 
public abstract class Box<TBox, T> : I<T>, IEquatable<Box<TBox, T>>
    where TBox : Box<TBox, T>, new()
{
    /// Wraps the value
    public static TBox Of(T x) => new TBox { Value = x };

    /// <inheritdoc />
    public T Value { get; private set; }

    /// <inheritdoc />
    public bool Equals(Box<TBox, T> other) =>
        other != null && EqualityComparer<T>.Default.Equals(Value, other.Value);

    /// <inheritdoc />
    public override bool Equals(object obj) => obj is Box<TBox, T> c && Equals(c);

    // ReSharper disable once NonReadonlyMemberInGetHashCode
    /// <inheritdoc />
    public override int GetHashCode() => EqualityComparer<T>.Default.GetHashCode(Value);

    /// <inheritdoc />
    public override string ToString() => UnionTools.ToString<TBox, T>(Value, "box(");
}

/// Unnamed discriminated union (with Empty name), shorter name for simplified inline usage
public class U<T1, T2> : Union<Unit, T1, T2> { }

/// Discriminated union
public abstract class Union<TUnion, T1, T2>
{
    /// To tag the cases with enum value for efficient pattern matching of required -
    /// otherwise we need to use `is CaseN` pattern or similar which is less efficient
    public enum Tag : byte
    {
        /// Tags Case1
        Case1,
        /// Tags Case2
        Case2
    }

    /// The base interface for the cases to operate.
    /// The naming is selected to start from the lower letter, cause we need to use the nested type.
    /// It is an unusual case, that's why using the __union__ will be fine to highlight this.
    // ReSharper disable once InconsistentNaming
    public interface union
    {
        /// The tag
        Tag Tag { get; }

        /// Matches the union cases to the R value
        R Match<R>(Func<T1, R> map1, Func<T2, R> map2);
    }

    /// Creates the respective case
    public static union Of(T1 x) => new case1(x);

    /// Creates the respective case
    public static union Of(T2 x) => new case2(x);

    /// Wraps the respective case
    public readonly struct case1 : union, IEquatable<case1>, I<T1>
    {
        /// Implicit conversion
        public static implicit operator case1(T1 x) => new case1(x);

        /// <inheritdoc />
        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

        /// <inheritdoc />
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2) => map1(Case);

        /// <inheritdoc />
        public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        /// The case value
        public readonly T1 Case;

        /// Wraps the value
        public case1(T1 x) => Case = x;

        /// <inheritdoc />
        public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Value, other.Value);

        /// <inheritdoc />
        public override bool Equals(object obj) => obj is case1 x && Equals(x);

        /// <inheritdoc />
        public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Value);

        /// <inheritdoc />
        public override string ToString() => UnionTools.ToString<TUnion, T1>(Value);
    }

    /// Wraps the respective case
    public readonly struct case2 : union, IEquatable<case2>, I<T2>
    {
        /// Conversion
        public static implicit operator case2(T2 x) => new case2(x);

        /// <inheritdoc />
        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }

        /// <inheritdoc />
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2) => map2(Value);

        /// <inheritdoc />
        public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        /// The case value
        public readonly T2 Case;

        /// Wraps the value
        public case2(T2 x) => Case = x;

        /// <inheritdoc />
        public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Value, other.Value);

        /// <inheritdoc />
        public override bool Equals(object obj) => obj is case2 x && Equals(x);

        /// <inheritdoc />
        public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Value);

        /// <inheritdoc />
        public override string ToString() => UnionTools.ToString<TUnion, T2>(Value);
    }
}

#pragma warning disable 1591
public class U<T1, T2, T3> : Union<Unit, T1, T2, T3> { }

public abstract class Union<TUnion, T1, T2, T3>
{
    public enum Tag : byte { Case1, Case2, Case3 }

    public interface union
    {
        Tag Tag { get; }
        R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3);
    }

    public static union Of(T1 x) => new case1(x);
    public static union Of(T2 x) => new case2(x);
    public static union Of(T3 x) => new case3(x);

    public struct case1 : union, IEquatable<case1>, I<T1>
    {
        public static implicit operator case1(T1 x) => new case1(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

        [MethodImpl((MethodImplOptions)256)]
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3) => map1(Case);

        public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T1 Case;
        public case1(T1 x) => Case = x;

        public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case1 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
    }

    public struct case2 : union, IEquatable<case2>, I<T2>
    {
        public static implicit operator case2(T2 x) => new case2(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3) => map2(Case);

        public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T2 Case;
        public case2(T2 x) => Case = x;

        public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case2 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
    }

    public struct case3 : union, IEquatable<case3>, I<T3>
    {
        public static implicit operator case3(T3 x) => new case3(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3) => map3(Case);

        public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T3 Case;
        public case3(T3 x) => Case = x;

        public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case3 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
    }
}

public class U<T1, T2, T3, T4> : Union<Unit, T1, T2, T3, T4> { }
public abstract class Union<TUnion, T1, T2, T3, T4>
{
    public enum Tag : byte { Case1, Case2, Case3, Case4 }

    public interface union
    {
        Tag Tag { get; }
        R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4);
    }

    public static union Of(T1 x) => new case1(x);
    public static union Of(T2 x) => new case2(x);
    public static union Of(T3 x) => new case3(x);
    public static union Of(T4 x) => new case4(x);

    public struct case1 : union, IEquatable<case1>, I<T1>
    {
        public static implicit operator case1(T1 x) => new case1(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

        [MethodImpl((MethodImplOptions)256)]
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4) => map1(Case);

        public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T1 Case;
        public case1(T1 x) => Case = x;

        public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case1 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
    }

    public struct case2 : union, IEquatable<case2>, I<T2>
    {
        public static implicit operator case2(T2 x) => new case2(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4) => map2(Case);

        public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T2 Case;
        public case2(T2 x) => Case = x;

        public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case2 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
    }

    public struct case3 : union, IEquatable<case3>, I<T3>
    {
        public static implicit operator case3(T3 x) => new case3(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4) => map3(Case);

        public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T3 Case;
        public case3(T3 x) => Case = x;

        public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case3 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
    }

    public struct case4 : union, IEquatable<case4>, I<T4>
    {
        public static implicit operator case4(T4 x) => new case4(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4) => map4(Case);

        public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T4 Case;
        public case4(T4 x) => Case = x;

        public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case4 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
    }
}

public class U<T1, T2, T3, T4, T5> : Union<Unit, T1, T2, T3, T4, T5> { }
public abstract class Union<TUnion, T1, T2, T3, T4, T5>
{
    public enum Tag : byte { Case1, Case2, Case3, Case4, Case5 }

    public interface union
    {
        Tag Tag { get; }
        R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5);
    }

    public static union Of(T1 x) => new case1(x);
    public static union Of(T2 x) => new case2(x);
    public static union Of(T3 x) => new case3(x);
    public static union Of(T4 x) => new case4(x);
    public static union Of(T5 x) => new case5(x);

    public struct case1 : union, IEquatable<case1>, I<T1>
    {
        public static implicit operator case1(T1 x) => new case1(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

        [MethodImpl((MethodImplOptions)256)]
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map1(Case);

        public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T1 Case;
        public case1(T1 x) => Case = x;

        public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case1 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
    }

    public struct case2 : union, IEquatable<case2>, I<T2>
    {
        public static implicit operator case2(T2 x) => new case2(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map2(Case);

        public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T2 Case;
        public case2(T2 x) => Case = x;

        public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case2 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
    }

    public struct case3 : union, IEquatable<case3>, I<T3>
    {
        public static implicit operator case3(T3 x) => new case3(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map3(Case);

        public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T3 Case;
        public case3(T3 x) => Case = x;

        public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case3 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
    }

    public struct case4 : union, IEquatable<case4>, I<T4>
    {
        public static implicit operator case4(T4 x) => new case4(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map4(Case);

        public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T4 Case;
        public case4(T4 x) => Case = x;

        public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case4 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
    }

    public struct case5 : union, IEquatable<case5>, I<T5>
    {
        public static implicit operator case5(T5 x) => new case5(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map5(Case);

        public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T5 Case;
        public case5(T5 x) => Case = x;

        public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case5 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
    }
}

public class U<T1, T2, T3, T4, T5, T6> : Union<Unit, T1, T2, T3, T4, T5, T6> { }
public abstract class Union<TUnion, T1, T2, T3, T4, T5, T6>
{
    public enum Tag : byte { Case1, Case2, Case3, Case4, Case5, Case6 }

    public interface union
    {
        Tag Tag { get; }
        R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6);
    }

    public static union Of(T1 x) => new case1(x);
    public static union Of(T2 x) => new case2(x);
    public static union Of(T3 x) => new case3(x);
    public static union Of(T4 x) => new case4(x);
    public static union Of(T5 x) => new case5(x);
    public static union Of(T6 x) => new case6(x);

    public struct case1 : union, IEquatable<case1>, I<T1>
    {
        public static implicit operator case1(T1 x) => new case1(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

        [MethodImpl((MethodImplOptions)256)]
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map1(Case);

        public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T1 Case;
        public case1(T1 x) => Case = x;

        public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case1 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
    }

    public struct case2 : union, IEquatable<case2>, I<T2>
    {
        public static implicit operator case2(T2 x) => new case2(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map2(Case);

        public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T2 Case;
        public case2(T2 x) => Case = x;

        public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case2 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
    }

    public struct case3 : union, IEquatable<case3>, I<T3>
    {
        public static implicit operator case3(T3 x) => new case3(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map3(Case);

        public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T3 Case;
        public case3(T3 x) => Case = x;

        public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case3 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
    }

    public struct case4 : union, IEquatable<case4>, I<T4>
    {
        public static implicit operator case4(T4 x) => new case4(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map4(Case);

        public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T4 Case;
        public case4(T4 x) => Case = x;

        public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case4 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
    }

    public struct case5 : union, IEquatable<case5>, I<T5>
    {
        public static implicit operator case5(T5 x) => new case5(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map5(Case);

        public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T5 Case;
        public case5(T5 x) => Case = x;

        public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case5 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
    }

    public struct case6 : union, IEquatable<case6>, I<T6>
    {
        public static implicit operator case6(T6 x) => new case6(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case6; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map6(Case);

        public T6 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T6 Case;
        public case6(T6 x) => Case = x;

        public bool Equals(case6 other) => EqualityComparer<T6>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case6 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T6>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T6>(Case);
    }
}

public class U<T1, T2, T3, T4, T5, T6, T7> : Union<Unit, T1, T2, T3, T4, T5, T6, T7> { }
public abstract class Union<TUnion, T1, T2, T3, T4, T5, T6, T7>
{
    public enum Tag : byte { Case1, Case2, Case3, Case4, Case5, Case6, Case7 }

    public interface union
    {
        Tag Tag { get; }
        R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7);
    }

    public static union Of(T1 x) => new case1(x);
    public static union Of(T2 x) => new case2(x);
    public static union Of(T3 x) => new case3(x);
    public static union Of(T4 x) => new case4(x);
    public static union Of(T5 x) => new case5(x);
    public static union Of(T6 x) => new case6(x);
    public static union Of(T7 x) => new case7(x);

    public struct case1 : union, IEquatable<case1>, I<T1>
    {
        public static implicit operator case1(T1 x) => new case1(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

        [MethodImpl((MethodImplOptions)256)]
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map1(Case);

        public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T1 Case;
        public case1(T1 x) => Case = x;

        public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case1 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
    }

    public struct case2 : union, IEquatable<case2>, I<T2>
    {
        public static implicit operator case2(T2 x) => new case2(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map2(Case);

        public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T2 Case;
        public case2(T2 x) => Case = x;

        public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case2 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
    }

    public struct case3 : union, IEquatable<case3>, I<T3>
    {
        public static implicit operator case3(T3 x) => new case3(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map3(Case);

        public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T3 Case;
        public case3(T3 x) => Case = x;

        public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case3 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
    }

    public struct case4 : union, IEquatable<case4>, I<T4>
    {
        public static implicit operator case4(T4 x) => new case4(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map4(Case);

        public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T4 Case;
        public case4(T4 x) => Case = x;

        public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case4 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
    }

    public struct case5 : union, IEquatable<case5>, I<T5>
    {
        public static implicit operator case5(T5 x) => new case5(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map5(Case);

        public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T5 Case;
        public case5(T5 x) => Case = x;

        public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case5 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
    }

    public struct case6 : union, IEquatable<case6>, I<T6>
    {
        public static implicit operator case6(T6 x) => new case6(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case6; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map6(Case);

        public T6 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T6 Case;
        public case6(T6 x) => Case = x;

        public bool Equals(case6 other) => EqualityComparer<T6>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case6 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T6>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T6>(Case);
    }

    public struct case7 : union, IEquatable<case7>, I<T7>
    {
        public static implicit operator case7(T7 x) => new case7(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case7; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map7(Case);

        public T7 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T7 Case;
        public case7(T7 x) => Case = x;

        public bool Equals(case7 other) => EqualityComparer<T7>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case7 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T7>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T7>(Case);
    }
}

public abstract class Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>
{
    public enum Tag : byte { Case1, Case2, Case3, Case4, Case5, Case6, Case7, Case8 }

    public interface union
    {
        Tag Tag { get; }
        R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8);
    }

    public static union Of(T1 x) => new case1(x);
    public static union Of(T2 x) => new case2(x);
    public static union Of(T3 x) => new case3(x);
    public static union Of(T4 x) => new case4(x);
    public static union Of(T5 x) => new case5(x);
    public static union Of(T6 x) => new case6(x);
    public static union Of(T7 x) => new case7(x);
    public static union Of(T8 x) => new case8(x);

    public struct case1 : union, IEquatable<case1>, I<T1>
    {
        public static implicit operator case1(T1 x) => new case1(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

        [MethodImpl((MethodImplOptions)256)]
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map1(Case);

        public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T1 Case;
        public case1(T1 x) => Case = x;

        public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case1 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
    }

    public struct case2 : union, IEquatable<case2>, I<T2>
    {
        public static implicit operator case2(T2 x) => new case2(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map2(Case);

        public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T2 Case;
        public case2(T2 x) => Case = x;

        public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case2 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
    }

    public struct case3 : union, IEquatable<case3>, I<T3>
    {
        public static implicit operator case3(T3 x) => new case3(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map3(Case);

        public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T3 Case;
        public case3(T3 x) => Case = x;

        public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case3 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
    }

    public struct case4 : union, IEquatable<case4>, I<T4>
    {
        public static implicit operator case4(T4 x) => new case4(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map4(Case);

        public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T4 Case;
        public case4(T4 x) => Case = x;

        public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case4 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
    }

    public struct case5 : union, IEquatable<case5>, I<T5>
    {
        public static implicit operator case5(T5 x) => new case5(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map5(Case);

        public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T5 Case;
        public case5(T5 x) => Case = x;

        public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case5 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
    }

    public struct case6 : union, IEquatable<case6>, I<T6>
    {
        public static implicit operator case6(T6 x) => new case6(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case6; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map6(Case);

        public T6 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T6 Case;
        public case6(T6 x) => Case = x;

        public bool Equals(case6 other) => EqualityComparer<T6>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case6 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T6>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T6>(Case);
    }

    public struct case7 : union, IEquatable<case7>, I<T7>
    {
        public static implicit operator case7(T7 x) => new case7(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case7; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map7(Case);

        public T7 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T7 Case;
        public case7(T7 x) => Case = x;

        public bool Equals(case7 other) => EqualityComparer<T7>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case7 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T7>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T7>(Case);
    }

    public struct case8 : union, IEquatable<case8>, I<T8>
    {
        public static implicit operator case8(T8 x) => new case8(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case8; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map8(Case);

        public T8 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T8 Case;
        public case8(T8 x) => Case = x;

        public bool Equals(case8 other) => EqualityComparer<T8>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case8 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T8>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T8>(Case);
    }
}

public abstract class Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>
{
    public enum Tag : byte { Case1, Case2, Case3, Case4, Case5, Case6, Case7, Case8, Case9 }

    public interface union
    {
        Tag Tag { get; }
        R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9);
    }

    public static union Of(T1 x) => new case1(x);
    public static union Of(T2 x) => new case2(x);
    public static union Of(T3 x) => new case3(x);
    public static union Of(T4 x) => new case4(x);
    public static union Of(T5 x) => new case5(x);
    public static union Of(T6 x) => new case6(x);
    public static union Of(T7 x) => new case7(x);
    public static union Of(T8 x) => new case8(x);
    public static union Of(T9 x) => new case9(x);

    public struct case1 : union, IEquatable<case1>, I<T1>
    {
        public static implicit operator case1(T1 x) => new case1(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

        [MethodImpl((MethodImplOptions)256)]
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map1(Case);

        public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T1 Case;
        public case1(T1 x) => Case = x;

        public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case1 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
    }

    public struct case2 : union, IEquatable<case2>, I<T2>
    {
        public static implicit operator case2(T2 x) => new case2(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map2(Case);

        public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T2 Case;
        public case2(T2 x) => Case = x;

        public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case2 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
    }

    public struct case3 : union, IEquatable<case3>, I<T3>
    {
        public static implicit operator case3(T3 x) => new case3(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map3(Case);

        public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T3 Case;
        public case3(T3 x) => Case = x;

        public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case3 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
    }

    public struct case4 : union, IEquatable<case4>, I<T4>
    {
        public static implicit operator case4(T4 x) => new case4(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map4(Case);

        public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T4 Case;
        public case4(T4 x) => Case = x;

        public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case4 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
    }

    public struct case5 : union, IEquatable<case5>, I<T5>
    {
        public static implicit operator case5(T5 x) => new case5(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map5(Case);

        public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T5 Case;
        public case5(T5 x) => Case = x;

        public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case5 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
    }

    public struct case6 : union, IEquatable<case6>, I<T6>
    {
        public static implicit operator case6(T6 x) => new case6(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case6; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map6(Case);

        public T6 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T6 Case;
        public case6(T6 x) => Case = x;

        public bool Equals(case6 other) => EqualityComparer<T6>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case6 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T6>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T6>(Case);
    }

    public struct case7 : union, IEquatable<case7>, I<T7>
    {
        public static implicit operator case7(T7 x) => new case7(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case7; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map7(Case);

        public T7 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T7 Case;
        public case7(T7 x) => Case = x;

        public bool Equals(case7 other) => EqualityComparer<T7>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case7 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T7>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T7>(Case);
    }

    public struct case8 : union, IEquatable<case8>, I<T8>
    {
        public static implicit operator case8(T8 x) => new case8(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case8; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map8(Case);

        public T8 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T8 Case;
        public case8(T8 x) => Case = x;

        public bool Equals(case8 other) => EqualityComparer<T8>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case8 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T8>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T8>(Case);
    }

    public struct case9 : union, IEquatable<case9>, I<T9>
    {
        public static implicit operator case9(T9 x) => new case9(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case9; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map9(Case);

        public T9 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T9 Case;
        public case9(T9 x) => Case = x;

        public bool Equals(case9 other) => EqualityComparer<T9>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case9 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T9>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T9>(Case);
    }
}

public abstract class Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
{
    public enum Tag : byte { Case1, Case2, Case3, Case4, Case5, Case6, Case7, Case8, Case9, Case10 }

    public interface union
    {
        Tag Tag { get; }
        R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10);
    }

    public static union Of(T1 x) => new case1(x);
    public static union Of(T2 x) => new case2(x);
    public static union Of(T3 x) => new case3(x);
    public static union Of(T4 x) => new case4(x);
    public static union Of(T5 x) => new case5(x);
    public static union Of(T6 x) => new case6(x);
    public static union Of(T7 x) => new case7(x);
    public static union Of(T8 x) => new case8(x);
    public static union Of(T9 x) => new case9(x);
    public static union Of(T10 x) => new case10(x);

    public struct case1 : union, IEquatable<case1>, I<T1>
    {
        public static implicit operator case1(T1 x) => new case1(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

        [MethodImpl((MethodImplOptions)256)]
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map1(Case);

        public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T1 Case;
        public case1(T1 x) => Case = x;

        public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case1 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
    }

    public struct case2 : union, IEquatable<case2>, I<T2>
    {
        public static implicit operator case2(T2 x) => new case2(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map2(Case);

        public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T2 Case;
        public case2(T2 x) => Case = x;

        public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case2 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
    }

    public struct case3 : union, IEquatable<case3>, I<T3>
    {
        public static implicit operator case3(T3 x) => new case3(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map3(Case);

        public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T3 Case;
        public case3(T3 x) => Case = x;

        public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case3 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
    }

    public struct case4 : union, IEquatable<case4>, I<T4>
    {
        public static implicit operator case4(T4 x) => new case4(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map4(Case);

        public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T4 Case;
        public case4(T4 x) => Case = x;

        public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case4 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
    }

    public struct case5 : union, IEquatable<case5>, I<T5>
    {
        public static implicit operator case5(T5 x) => new case5(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map5(Case);

        public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T5 Case;
        public case5(T5 x) => Case = x;

        public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case5 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
    }

    public struct case6 : union, IEquatable<case6>, I<T6>
    {
        public static implicit operator case6(T6 x) => new case6(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case6; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map6(Case);

        public T6 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T6 Case;
        public case6(T6 x) => Case = x;

        public bool Equals(case6 other) => EqualityComparer<T6>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case6 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T6>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T6>(Case);
    }

    public struct case7 : union, IEquatable<case7>, I<T7>
    {
        public static implicit operator case7(T7 x) => new case7(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case7; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map7(Case);

        public T7 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T7 Case;
        public case7(T7 x) => Case = x;

        public bool Equals(case7 other) => EqualityComparer<T7>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case7 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T7>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T7>(Case);
    }

    public struct case8 : union, IEquatable<case8>, I<T8>
    {
        public static implicit operator case8(T8 x) => new case8(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case8; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map8(Case);

        public T8 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T8 Case;
        public case8(T8 x) => Case = x;

        public bool Equals(case8 other) => EqualityComparer<T8>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case8 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T8>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T8>(Case);
    }

    public struct case9 : union, IEquatable<case9>, I<T9>
    {
        public static implicit operator case9(T9 x) => new case9(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case9; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map9(Case);

        public T9 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T9 Case;
        public case9(T9 x) => Case = x;

        public bool Equals(case9 other) => EqualityComparer<T9>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case9 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T9>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T9>(Case);
    }

    public struct case10 : union, IEquatable<case10>, I<T10>
    {
        public static implicit operator case10(T10 x) => new case10(x);

        public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case10; }
        public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
            Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map10(Case);

        public T10 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

        public readonly T10 Case;
        public case10(T10 x) => Case = x;

        public bool Equals(case10 other) => EqualityComparer<T10>.Default.Equals(Case, other.Case);
        public override bool Equals(object obj) => obj is case10 x && Equals(x);
        public override int GetHashCode() => EqualityComparer<T10>.Default.GetHashCode(Case);
        public override string ToString() => UnionTools.ToString<TUnion, T10>(Case);
    }
}

#pragma warning restore 1591
