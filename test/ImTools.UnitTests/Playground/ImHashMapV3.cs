// <auto-generated/>
/*
The MIT License (MIT)

Copyright (c) 2016-2022 Maksim Volkau

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// ReSharper disable once InconsistentNaming

namespace ImToolsV3
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading;
    using System.Diagnostics;
    using System.Runtime.CompilerServices; // For [MethodImpl(AggressiveInlining)]

    using ImTools;

    /// <summary>Entry containing the Key and Value in addition to the Hash</summary>
    public class ImHashMapEntry<K, V> : ImHashMap<K, V>.Entry
    {
        /// <summary>The key</summary>
        public readonly K Key;
        /// <summary>The value. Maybe modified if you need the Ref{Value} semantics. 
        /// You may add the entry with the default Value to the map, and calculate and set it later (e.g. using the CAS).</summary>
        public V Value;
        /// <summary>Constructs the entry with the key and value</summary>
        public ImHashMapEntry(int hash, K key) : base(hash) => Key = key;
        /// <summary>Constructs the entry with the key and value</summary>
        public ImHashMapEntry(int hash, K key, V value) : base(hash)
        {
            Key = key;
            Value = value;
        }

        /// <inheritdoc />
        public sealed override int Count() => 1;

        /// <inheritdoc />
        public sealed override ImHashMapEntry<K, V> GetEntryOrNull(int hash, K key) =>
            Hash == hash && Key.Equals(key) ? this : null;

        /// <inheritdoc />
        public sealed override Entry Update(ImHashMapEntry<K, V> newEntry) =>
            Key.Equals(newEntry.Key) ? newEntry : this.WithConflicting(newEntry);

        /// <inheritdoc />
        public sealed override Entry AppendOrUpdateInPlaceOrKeep<S>(S state, ImHashMapEntry<K, V> newEntry, UpdaterInPlaceOrKeeper<S> updateOrKeep)
        {
            if (!Key.Equals(newEntry.Key))
                return this.WithConflicting(newEntry);
            return updateOrKeep(state, this, newEntry) != this ? newEntry : this;
        }

#if !DEBUG
        /// <inheritdoc />
        public override string ToString() => "{H: " + Hash + ", K: " + Key + ", V: " + Value + "}";
#endif
    }

    /// <summary>The composite containing the list of entries with the same conflicting Hash.</summary>
    internal sealed class HashConflictingEntry<K, V> : ImHashMap<K, V>.Entry
    {
        public ImHashMapEntry<K, V>[] Conflicts;
        internal HashConflictingEntry(int hash, params ImHashMapEntry<K, V>[] conflicts) : base(hash) => Conflicts = conflicts;

        public override int Count() => Conflicts.Length;

        /// <inheritdoc />
        public override ImHashMapEntry<K, V> GetEntryOrNull(int hash, K key)
        {
            var cs = Conflicts;
            var i = cs.Length - 1;
            while (i != -1 && !key.Equals(cs[i].Key)) --i;
            return i != -1 ? cs[i] : null;
        }

        /// <inheritdoc />
        public override Entry Update(ImHashMapEntry<K, V> newEntry)
        {
            var key = newEntry.Key;
            var cs = Conflicts;
            var i = cs.Length - 1;
            while (i != -1 && !key.Equals(cs[i].Key)) --i;
            return new HashConflictingEntry<K, V>(Hash, cs.AppendOrUpdate(newEntry, i));
        }

        /// <inheritdoc />
        public override Entry AppendOrUpdateInPlaceOrKeep<S>(S state, ImHashMapEntry<K, V> newEntry, UpdaterInPlaceOrKeeper<S> updateOrKeep)
        {
            var key = newEntry.Key;
            var cs = Conflicts;
            var i = cs.Length - 1;
            while (i != -1 && !key.Equals(cs[i].Key)) --i;
            if (i == -1)
                return new HashConflictingEntry<K, V>(Hash, cs.AppendToNonEmpty(newEntry));

            var oldEntry = cs[i];
            if (updateOrKeep(state, oldEntry, newEntry) != oldEntry)
                return new HashConflictingEntry<K, V>(Hash, cs.UpdateNonEmpty(newEntry, i));

            return this;
        }

#if !DEBUG
        public override string ToString()
        {
            var sb = new System.Text.StringBuilder("HashConflictingEntry: [");
            foreach (var x in Conflicts) 
                sb.Append(x.ToString()).Append(", ");
            return sb.Append("]").ToString();
        }
#endif
    }

    /// <summary>The base and the holder class for the map tree leafs and branches, also defines the Empty tree.
    /// The map implementation is based on the "modified" 2-3 tree.</summary>
    public class ImHashMap<K, V>
    {
        /// <summary>Hide the base constructor to prevent the multiple Empty trees creation</summary>
        protected ImHashMap() { }

        /// <summary>Empty map to start with. Exists as a single instance.</summary>
        public static readonly ImHashMap<K, V> Empty = new ImHashMap<K, V>();

        /// <summary>Prints the map tree in JSON-ish format in release mode and enumerates the keys in DEBUG.</summary>
        public override string ToString()
        {
#if DEBUG
            // for the debug purposes we just output the first N keys in array
            const int n = 50;
            var count = this.Count();
            var keys = this.Enumerate().Take(n).Select(x => x.Key).ToList();
            return $"{{keys: new int[{(count > n ? $"{n}/{count}" : "" + count)}] {{{(string.Join(", ", keys))}}}}}";
#else
            return "{}";
#endif
        }

        /// <summary>Indicates that the map is empty</summary>
        public bool IsEmpty => this == Empty;

        /// <summary>The count of entries in the map</summary>
        public virtual int Count() => 0;

        internal virtual Entry GetMinHashEntryOrDefault() => null;
        internal virtual Entry GetMaxHashEntryOrDefault() => null;

        /// <summary>Lookup for the entry by hash. If nothing the method returns `null`</summary>
        internal virtual Entry GetEntryOrNull(int hash) => null;

        /// <summary>Returns the found entry with the same hash or the new map with added new entry.
        /// Note that the empty map will return the entry the same as if the entry was found - so the consumer should check for the empty map.
        /// Note that the method cannot return the `null` - when the existing entry is not found it will always be the new map with the added entry.</summary>
        public virtual ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry) => entry;

        /// <summary>Returns the new map with old entry replaced by the new entry. Note that the old entry should be present.</summary>
        internal virtual ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry) => this;

        /// <summary>Removes the certainly present old entry and returns the new map without it.</summary>
        internal virtual ImHashMap<K, V> RemoveEntry(Entry entry) => this;

        /// <summary>The delegate is supposed to return entry different from the oldEntry to update, and return the oldEntry to keep it.</summary>
        public delegate ImHashMapEntry<K, V> UpdaterInPlaceOrKeeper<S>(S state, ImHashMapEntry<K, V> oldEntry, ImHashMapEntry<K, V> newEntry);

        /// <summary>The base map entry for holding the hash and payload</summary>
        public abstract class Entry : ImHashMap<K, V>
        {
            /// <summary>The Hash</summary>
            public readonly int Hash;
            /// <summary>Constructs the entry with the hash</summary>
            protected Entry(int hash) => Hash = hash;

            internal override Entry GetMinHashEntryOrDefault() => this;
            internal override Entry GetMaxHashEntryOrDefault() => this;

            internal sealed override Entry GetEntryOrNull(int hash) => hash == Hash ? this : null;

            /// <summary>Lookup for the entry by Hash and Key</summary>
            public abstract ImHashMapEntry<K, V> GetEntryOrNull(int hash, K key);

            /// <summary>Updating the entry with the new one</summary>
            public abstract Entry Update(ImHashMapEntry<K, V> newEntry);

            /// <summary>Updating the newEntry in place via the provide delegate based on the current (old) entry or
            /// adding the newEntry to the hash-conflicting entry, or keeping the old one.</summary>
            public abstract Entry AppendOrUpdateInPlaceOrKeep<S>(S state, ImHashMapEntry<K, V> newEntry, UpdaterInPlaceOrKeeper<S> updateOrKeep);

            /// <inheritdoc />
            public sealed override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry) =>
                hash > Hash ? new Leaf2(this, entry) : hash < Hash ? new Leaf2(entry, this) : (ImHashMap<K, V>)this;

            internal sealed override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry)
            {
                Debug.Assert(this == oldEntry, "When down to the entry, the oldEntry should be present in the entry.");
                return newEntry;
            }

            internal sealed override ImHashMap<K, V> RemoveEntry(Entry removedEntry)
            {
                Debug.Assert(this == removedEntry, "When down to the entry, the removedEntry should be present in the entry.");
                return Empty;
            }
        }

        /// <summary>Leaf with 2 hash-ordered entries. Important: the both or either of entries may be null for the removed entries</summary>
        internal sealed class Leaf2 : ImHashMap<K, V>
        {
            public readonly Entry Entry0, Entry1;
            public Leaf2(Entry e0, Entry e1)
            {
                Debug.Assert(e0.Hash < e1.Hash);
                Entry0 = e0; Entry1 = e1;
            }

            public override int Count() => Entry0.Count() + Entry1.Count();

#if !DEBUG
            public override string ToString() => "{L2:{E0:" + Entry0 + ",E1:" + Entry1 + "}}";
#endif

            internal override Entry GetMinHashEntryOrDefault() => Entry0;
            internal override Entry GetMaxHashEntryOrDefault() => Entry1;

            internal override Entry GetEntryOrNull(int hash) =>
                Entry0.Hash == hash ? Entry0 : Entry1.Hash == hash ? Entry1 : null;

            public override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry) =>
                hash == Entry0.Hash ? Entry0 : hash == Entry1.Hash ? Entry1 : (ImHashMap<K, V>)new Leaf2Plus1(entry, this);

            internal override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry) =>
                oldEntry == Entry0 ? new Leaf2(newEntry, Entry1) : new Leaf2(Entry0, newEntry);

            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry) =>
                Entry0 == removedEntry ? Entry1 : Entry0;
        }

        /// <summary>The leaf containing the Leaf2 plus the newest added entry.</summary>
        internal sealed class Leaf2Plus1 : ImHashMap<K, V>
        {
            public readonly Entry Plus;
            public readonly Leaf2 L;
            public Leaf2Plus1(Entry plus, Leaf2 leaf)
            {
                Plus = plus;
                L = leaf;
            }

            public override int Count() => Plus.Count() + L.Entry0.Count() + L.Entry1.Count();

#if !DEBUG
            public override string ToString() => "{L21:{P:" + Plus + ",L:" + L + "}}";
#endif

            internal sealed override Entry GetMinHashEntryOrDefault() => Plus.Hash < L.Entry0.Hash ? Plus : L.Entry0;
            internal sealed override Entry GetMaxHashEntryOrDefault() => Plus.Hash > L.Entry1.Hash ? Plus : L.Entry1;

            internal override Entry GetEntryOrNull(int hash)
            {
                if (hash == Plus.Hash)
                    return Plus;
                Entry e0 = L.Entry0, e1 = L.Entry1;
                return e0.Hash == hash ? e0 : e1.Hash == hash ? e1 : null;
            }

            public sealed override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)
            {
                if (hash == Plus.Hash)
                    return Plus;
                Entry e0 = L.Entry0, e1 = L.Entry1;
                return hash == e0.Hash ? e0 : hash == e1.Hash ? e1 : (ImHashMap<K, V>)new Leaf2Plus1Plus1(entry, this);
            }

            internal sealed override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry) =>
                oldEntry == Plus ? new Leaf2Plus1(newEntry, L) :
                oldEntry == L.Entry0 ? new Leaf2Plus1(Plus, new Leaf2(newEntry, L.Entry1)) :
                                       new Leaf2Plus1(Plus, new Leaf2(L.Entry0, newEntry));

            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry) =>
                removedEntry == Plus ? L :
                removedEntry == L.Entry0 ?
                    (Plus.Hash < L.Entry1.Hash ? new Leaf2(Plus, L.Entry1) : new Leaf2(L.Entry1, Plus)) :
                    (Plus.Hash < L.Entry0.Hash ? new Leaf2(Plus, L.Entry0) : new Leaf2(L.Entry0, Plus));
        }

        /// <summary>Leaf with the Leaf2 plus added entry, plus added entry</summary>
        internal sealed class Leaf2Plus1Plus1 : ImHashMap<K, V>
        {
            public readonly Entry Plus;
            public readonly Leaf2Plus1 L;

            public Leaf2Plus1Plus1(Entry plus, Leaf2Plus1 l)
            {
                Plus = plus;
                L = l;
            }

            public override int Count() => Plus.Count() + L.Plus.Count() + L.L.Entry0.Count() + L.L.Entry1.Count();

#if !DEBUG
            public override string ToString() => "{L211:{P:" + Plus + ", L:" + L + "}}";
#endif

            internal sealed override Entry GetMinHashEntryOrDefault()
            {
                var m = L.GetMinHashEntryOrDefault();
                return Plus.Hash < m.Hash ? Plus : m;
            }
            internal sealed override Entry GetMaxHashEntryOrDefault()
            {
                var m = L.GetMaxHashEntryOrDefault();
                return Plus.Hash > m.Hash ? Plus : m;
            }

            internal override Entry GetEntryOrNull(int hash)
            {
                if (hash == Plus.Hash)
                    return Plus;
                if (hash == L.Plus.Hash)
                    return L.Plus;
                Entry e0 = L.L.Entry0, e1 = L.L.Entry1;
                return e0.Hash == hash ? e0 : e1.Hash == hash ? e1 : null;
            }

            public sealed override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)
            {
                var p = Plus;
                var ph = p.Hash;
                if (ph == hash)
                    return p;

                var pp = L.Plus;
                var pph = pp.Hash;
                if (pph == hash)
                    return pp;

                var l = L.L;
                Entry e0 = l.Entry0, e1 = l.Entry1;

                if (hash == e0.Hash)
                    return e0;
                if (hash == e1.Hash)
                    return e1;

                // e0 and e1 are already sorted e0 < e1, we need to insert the pp, p, e into them in the right order,
                // so the result should be e0 < e1 < pp < p < e

                if (pph < e1.Hash)
                {
                    Fun.Swap(ref e1, ref pp);
                    if (pph < e0.Hash)
                        Fun.Swap(ref e0, ref e1);
                }

                if (ph < pp.Hash)
                {
                    Fun.Swap(ref p, ref pp);
                    if (ph < e1.Hash)
                    {
                        Fun.Swap(ref pp, ref e1);
                        if (ph < e0.Hash)
                            Fun.Swap(ref e1, ref e0);
                    }
                }

                Entry e = entry;
                if (hash < p.Hash)
                {
                    Fun.Swap(ref e, ref p);
                    if (hash < pp.Hash)
                    {
                        Fun.Swap(ref p, ref pp);
                        if (hash < e1.Hash)
                        {
                            Fun.Swap(ref pp, ref e1);
                            if (hash < e0.Hash)
                                Fun.Swap(ref e1, ref e0);
                        }
                    }
                }

                return new Leaf5(e0, e1, pp, p, e);
            }

            internal sealed override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry) =>
                oldEntry == Plus ? new Leaf2Plus1Plus1(newEntry, L) :
                oldEntry == L.Plus ? new Leaf2Plus1Plus1(Plus, new Leaf2Plus1(newEntry, L.L)) :
                oldEntry == L.L.Entry0 ? new Leaf2Plus1Plus1(Plus, new Leaf2Plus1(L.Plus, new Leaf2(newEntry, L.L.Entry1))) :
                                         new Leaf2Plus1Plus1(Plus, new Leaf2Plus1(L.Plus, new Leaf2(L.L.Entry0, newEntry)));

            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry) =>
                removedEntry == Plus ? L :
                removedEntry == L.Plus ? new Leaf2Plus1(Plus, L.L) :
                removedEntry == L.L.Entry0 ?
                    (L.Plus.Hash < L.L.Entry1.Hash ? new Leaf2Plus1(Plus, new Leaf2(L.Plus, L.L.Entry1)) : new Leaf2Plus1(Plus, new Leaf2(L.L.Entry1, L.Plus))) :
                    (L.Plus.Hash < L.L.Entry0.Hash ? new Leaf2Plus1(Plus, new Leaf2(L.Plus, L.L.Entry0)) : new Leaf2Plus1(Plus, new Leaf2(L.L.Entry0, L.Plus)));
        }

        /// <summary>Leaf with 5 hash-ordered entries</summary>
        internal sealed class Leaf5 : ImHashMap<K, V>
        {
            public readonly Entry Entry0, Entry1, Entry2, Entry3, Entry4;

            public Leaf5(Entry e0, Entry e1, Entry e2, Entry e3, Entry e4)
            {
                Debug.Assert(e0.Hash < e1.Hash, "e0 < e1");
                Debug.Assert(e1.Hash < e2.Hash, "e1 < e2");
                Debug.Assert(e2.Hash < e3.Hash, "e2 < e3");
                Debug.Assert(e3.Hash < e4.Hash, "e3 < e4");
                Entry0 = e0; Entry1 = e1; Entry2 = e2; Entry3 = e3; Entry4 = e4;
            }

            public override int Count() => Entry0.Count() + Entry1.Count() + Entry2.Count() + Entry3.Count() + Entry4.Count();

#if !DEBUG
            public override string ToString() => 
                "{L2:{E0:" + Entry0 + ", E1:" + Entry1 + ", E2:" + Entry2 + ",E3:" + Entry3 + ",E4:" + Entry4 + "}}";
#endif

            internal sealed override Entry GetMinHashEntryOrDefault() => Entry0;
            internal sealed override Entry GetMaxHashEntryOrDefault() => Entry4;

            internal override Entry GetEntryOrNull(int hash) =>
                hash == Entry0.Hash ? Entry0 :
                hash == Entry1.Hash ? Entry1 :
                hash == Entry2.Hash ? Entry2 :
                hash == Entry3.Hash ? Entry3 :
                hash == Entry4.Hash ? Entry4 :
                null;

            public sealed override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry) =>
                hash == Entry0.Hash ? Entry0 :
                hash == Entry1.Hash ? Entry1 :
                hash == Entry2.Hash ? Entry2 :
                hash == Entry3.Hash ? Entry3 :
                hash == Entry4.Hash ? Entry4 :
                (ImHashMap<K, V>)new Leaf5Plus1(entry, this);

            internal sealed override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry) =>
                oldEntry == Entry0 ? new Leaf5(newEntry, Entry1, Entry2, Entry3, Entry4) :
                oldEntry == Entry1 ? new Leaf5(Entry0, newEntry, Entry2, Entry3, Entry4) :
                oldEntry == Entry2 ? new Leaf5(Entry0, Entry1, newEntry, Entry3, Entry4) :
                oldEntry == Entry3 ? new Leaf5(Entry0, Entry1, Entry2, newEntry, Entry4) :
                                     new Leaf5(Entry0, Entry1, Entry2, Entry3, newEntry);

            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry) =>
                removedEntry == Entry0 ? new Leaf2Plus1Plus1(Entry4, new Leaf2Plus1(Entry3, new Leaf2(Entry1, Entry2))) :
                removedEntry == Entry1 ? new Leaf2Plus1Plus1(Entry4, new Leaf2Plus1(Entry3, new Leaf2(Entry0, Entry2))) :
                removedEntry == Entry2 ? new Leaf2Plus1Plus1(Entry4, new Leaf2Plus1(Entry3, new Leaf2(Entry0, Entry1))) :
                removedEntry == Entry3 ? new Leaf2Plus1Plus1(Entry4, new Leaf2Plus1(Entry2, new Leaf2(Entry0, Entry1))) :
                                         new Leaf2Plus1Plus1(Entry3, new Leaf2Plus1(Entry2, new Leaf2(Entry0, Entry1)));
        }

        /// <summary>Leaf with 5 existing ordered entries plus 1 newly added entry.</summary>
        internal sealed class Leaf5Plus1 : ImHashMap<K, V>
        {
            public readonly Entry Plus;
            public readonly Leaf5 L;
            public Leaf5Plus1(Entry plus, Leaf5 l)
            {
                Plus = plus;
                L = l;
            }

            public override int Count() => Plus.Count() + L.Count();

#if !DEBUG
            public override string ToString() => "{L51:{P:" + Plus + ",L:" + L + "}}";
#endif

            internal sealed override Entry GetMinHashEntryOrDefault() => Plus.Hash < L.Entry0.Hash ? Plus : L.Entry0;
            internal sealed override Entry GetMaxHashEntryOrDefault() => Plus.Hash > L.Entry4.Hash ? Plus : L.Entry4;

            internal override Entry GetEntryOrNull(int hash)
            {
                if (hash == Plus.Hash)
                    return Plus;
                var l = L;
                return hash == l.Entry0.Hash ? l.Entry0
                    : hash == l.Entry1.Hash ? l.Entry1
                    : hash == l.Entry2.Hash ? l.Entry2
                    : hash == l.Entry3.Hash ? l.Entry3
                    : hash == l.Entry4.Hash ? l.Entry4
                    : null;
            }

            public sealed override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)
            {
                var p = Plus;
                var ph = p.Hash;
                if (ph == hash)
                    return p;
                var l = L;
                return hash == l.Entry0.Hash ? l.Entry0
                    : hash == l.Entry1.Hash ? l.Entry1
                    : hash == l.Entry2.Hash ? l.Entry2
                    : hash == l.Entry3.Hash ? l.Entry3
                    : hash == l.Entry4.Hash ? l.Entry4
                    : (ImHashMap<K, V>)new Leaf5Plus1Plus1(entry, this);
            }

            internal sealed override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry)
            {
                var p = Plus;
                if (oldEntry == p)
                    return new Leaf5Plus1(newEntry, L);
                var l = L;
                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;
                return oldEntry == e0 ? new Leaf5Plus1(p, new Leaf5(newEntry, e1, e2, e3, e4))
                    : oldEntry == e1 ? new Leaf5Plus1(p, new Leaf5(e0, newEntry, e2, e3, e4))
                    : oldEntry == e2 ? new Leaf5Plus1(p, new Leaf5(e0, e1, newEntry, e3, e4))
                    : oldEntry == e3 ? new Leaf5Plus1(p, new Leaf5(e0, e1, e2, newEntry, e4))
                    : new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, newEntry));
            }

            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry)
            {
                var p = Plus;
                if (p == removedEntry)
                    return L;

                var ph = p.Hash;
                var l = L;
                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, swap = null;

                if (ph < e4.Hash)
                {
                    swap = e4; e4 = p; p = swap;
                    if (ph < e3.Hash)
                    {
                        swap = e3; e3 = e4; e4 = swap;
                        if (ph < e2.Hash)
                        {
                            swap = e2; e2 = e3; e3 = swap;
                            if (ph < e1.Hash)
                            {
                                swap = e1; e1 = e2; e2 = swap;
                                if (ph < e0.Hash)
                                {
                                    swap = e0; e0 = e1; e1 = swap;
                                }
                            }
                        }
                    }
                }

                return removedEntry == e0 ? new Leaf5(e1, e2, e3, e4, p)
                    : removedEntry == e1 ? new Leaf5(e0, e2, e3, e4, p)
                    : removedEntry == e2 ? new Leaf5(e0, e1, e3, e4, p)
                    : removedEntry == e3 ? new Leaf5(e0, e1, e2, e4, p)
                    : removedEntry == e4 ? new Leaf5(e0, e1, e2, e3, p)
                    : new Leaf5(e0, e1, e2, e3, e4);
            }
        }

        internal abstract class OnTheVergeOfBalance : ImHashMap<K, V>
        {
            internal abstract ImHashMap<K, V> AddOrGetEntry(int hash, ref Entry entry, ref ImHashMap<K, V> splitRight);
        }

        /// <summary>Leaf with 5 existing ordered entries plus 1 newly added, plus 1 newly added.</summary>
        internal sealed class Leaf5Plus1Plus1 : OnTheVergeOfBalance
        {
            public readonly Entry Plus;
            public readonly Leaf5Plus1 L;
            public Leaf5Plus1Plus1(Entry plus, Leaf5Plus1 l)
            {
                Plus = plus;
                L = l;
            }

            public override int Count() => Plus.Count() + L.Count();

#if !DEBUG
            public override string ToString() => "{L511:{P:" + Plus + ",L:" + L + "}}";
#endif

            internal sealed override Entry GetMinHashEntryOrDefault()
            {
                var m = L.GetMinHashEntryOrDefault();
                return Plus.Hash < m.Hash ? Plus : m;
            }
            internal sealed override Entry GetMaxHashEntryOrDefault()
            {
                var m = L.GetMaxHashEntryOrDefault();
                return Plus.Hash > m.Hash ? Plus : m;
            }

            internal override Entry GetEntryOrNull(int hash)
            {
                if (hash == Plus.Hash)
                    return Plus;
                if (hash == L.Plus.Hash)
                    return L.Plus;
                var l = L.L;
                return hash == l.Entry0.Hash ? l.Entry0
                    : hash == l.Entry1.Hash ? l.Entry1
                    : hash == l.Entry2.Hash ? l.Entry2
                    : hash == l.Entry3.Hash ? l.Entry3
                    : hash == l.Entry4.Hash ? l.Entry4
                    : null;
            }

            public override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)
            {
                ImHashMap<K, V> splitRight = null;
                var entryOrNewMap = AddOrGetEntry(hash, ref entry, ref splitRight);
                if (splitRight != null)
                    return new Branch2(entryOrNewMap, entry, splitRight);
                return entryOrNewMap;
            }

            internal override ImHashMap<K, V> AddOrGetEntry(int hash, ref Entry entry, ref ImHashMap<K, V> splitRight)
            {
                var p = Plus;
                var ph = p.Hash;
                if (ph == hash)
                    return p;

                var pp = L.Plus;
                var pph = pp.Hash;
                if (pph == hash)
                    return pp;

                var l = L.L;
                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;

                if (hash == e0.Hash)
                    return e0;
                if (hash == e1.Hash)
                    return e1;
                if (hash == e2.Hash)
                    return e2;
                if (hash == e3.Hash)
                    return e3;
                if (hash == e4.Hash)
                    return e4;

                var right = hash > e4.Hash && ph > e4.Hash && pph > e4.Hash;
                var left = !right && hash < e0.Hash && ph < e0.Hash && pph < e0.Hash;

                Entry swap = null;
                if (pph < e4.Hash)
                {
                    swap = e4; e4 = pp; pp = swap;
                    if (pph < e3.Hash)
                    {
                        swap = e3; e3 = e4; e4 = swap;
                        if (pph < e2.Hash)
                        {
                            swap = e2; e2 = e3; e3 = swap;
                            if (pph < e1.Hash)
                            {
                                swap = e1; e1 = e2; e2 = swap;
                                if (pph < e0.Hash)
                                {
                                    swap = e0; e0 = e1; e1 = swap;
                                }
                            }
                        }
                    }
                }

                if (ph < pp.Hash)
                {
                    swap = pp; pp = p; p = swap;
                    if (ph < e4.Hash)
                    {
                        swap = e4; e4 = pp; pp = swap;
                        if (ph < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (ph < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (ph < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (ph < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }
                }

                Entry e = entry;
                if (hash < p.Hash)
                {
                    swap = p; p = e; e = swap;
                    if (hash < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (hash < e4.Hash)
                        {
                            swap = e4; e4 = pp; pp = swap;
                            if (hash < e3.Hash)
                            {
                                swap = e3; e3 = e4; e4 = swap;
                                if (hash < e2.Hash)
                                {
                                    swap = e2; e2 = e3; e3 = swap;
                                    if (hash < e1.Hash)
                                    {
                                        swap = e1; e1 = e2; e2 = swap;
                                        if (hash < e0.Hash)
                                        {
                                            swap = e0; e0 = e1; e1 = swap;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (left)
                {
                    entry = e2;
                    splitRight = l;
                    return new Leaf2(e0, e1);
                }

                entry = pp;
                splitRight = new Leaf2(p, e);
                return right ? l : new Leaf5(e0, e1, e2, e3, e4);
            }


            internal sealed override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry)
            {
                var p = Plus;
                if (p == oldEntry)
                    return new Leaf5Plus1Plus1(newEntry, L);

                var pp = L.Plus;
                if (pp == oldEntry)
                    return new Leaf5Plus1Plus1(p, new Leaf5Plus1(newEntry, L.L));

                var l = L.L;
                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;
                return
                    oldEntry == e0 ? new Leaf5Plus1Plus1(p, new Leaf5Plus1(pp, new Leaf5(newEntry, e1, e2, e3, e4))) :
                    oldEntry == e1 ? new Leaf5Plus1Plus1(p, new Leaf5Plus1(pp, new Leaf5(e0, newEntry, e2, e3, e4))) :
                    oldEntry == e2 ? new Leaf5Plus1Plus1(p, new Leaf5Plus1(pp, new Leaf5(e0, e1, newEntry, e3, e4))) :
                    oldEntry == e3 ? new Leaf5Plus1Plus1(p, new Leaf5Plus1(pp, new Leaf5(e0, e1, e2, newEntry, e4))) :
                                     new Leaf5Plus1Plus1(p, new Leaf5Plus1(pp, new Leaf5(e0, e1, e2, e3, newEntry)));
            }

            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry)
            {
                var p = Plus;
                if (p == removedEntry)
                    return L;

                var pp = L.Plus;
                if (pp == removedEntry)
                    return new Leaf5Plus1(p, L.L);

                var l = L.L;
                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, swap = null;
                int pph = pp.Hash, ph = p.Hash;
                if (pph < e4.Hash)
                {
                    swap = e4; e4 = pp; pp = swap;
                    if (pph < e3.Hash)
                    {
                        swap = e3; e3 = e4; e4 = swap;
                        if (pph < e2.Hash)
                        {
                            swap = e2; e2 = e3; e3 = swap;
                            if (pph < e1.Hash)
                            {
                                swap = e1; e1 = e2; e2 = swap;
                                if (pph < e0.Hash)
                                {
                                    swap = e0; e0 = e1; e1 = swap;
                                }
                            }
                        }
                    }
                }
                if (ph < pp.Hash)
                {
                    swap = pp; pp = p; p = swap;
                    if (ph < e4.Hash)
                    {
                        swap = e4; e4 = pp; pp = swap;
                        if (ph < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (ph < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (ph < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (ph < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }
                }

                return removedEntry == e0 ? new Leaf5Plus1(p, new Leaf5(e1, e2, e3, e4, pp))
                    : removedEntry == e1 ? new Leaf5Plus1(p, new Leaf5(e0, e2, e3, e4, pp))
                    : removedEntry == e2 ? new Leaf5Plus1(p, new Leaf5(e0, e1, e3, e4, pp))
                    : removedEntry == e3 ? new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e4, pp))
                    : removedEntry == e4 ? new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, pp))
                    : removedEntry == pp ? new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4))
                    : new Leaf5Plus1(pp, new Leaf5(e0, e1, e2, e3, e4));
            }
        }

        /// <summary>Branch of 2 leafs or branches with entry in the middle</summary>
        internal sealed class Branch2 : ImHashMap<K, V>
        {
            public readonly ImHashMap<K, V> Left;
            public readonly Entry MidEntry;
            public readonly ImHashMap<K, V> Right;

            public Branch2(ImHashMap<K, V> left, Entry entry, ImHashMap<K, V> right)
            {
                Debug.Assert(left != Empty && right != Empty, $"left:{left} != Empty && right:{right} != Empty");
                MidEntry = entry;
                Left = left;
                Right = right;
            }

            public override int Count() => MidEntry.Count() + Left.Count() + Right.Count();

#if !DEBUG
            public override string ToString() => "{B2:{E:" + MidEntry + ",L:" + Left + ",R:" + Right + "}}";
#endif

            internal override Entry GetMinHashEntryOrDefault() => Left.GetMinHashEntryOrDefault();
            internal override Entry GetMaxHashEntryOrDefault() => Right.GetMaxHashEntryOrDefault();

            internal override Entry GetEntryOrNull(int hash)
            {
                var h = MidEntry.Hash;
                return hash > h ? Right.GetEntryOrNull(hash)
                    : hash < h ? Left.GetEntryOrNull(hash)
                    : MidEntry;
            }

            public override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)
            {
                var e = MidEntry;
                ImHashMap<K, V> newBranch = null;
                if (hash > e.Hash)
                {
                    var right = Right;
                    if (right is OnTheVergeOfBalance r)
                    {
                        ImHashMap<K, V> splitRight = null;
                        newBranch = r.AddOrGetEntry(hash, ref entry, ref splitRight);
                        if (splitRight != null)
                            return new Branch3(Left, e, newBranch, entry, splitRight);
                    }
                    else newBranch = right.AddOrGetEntry(hash, entry);
                    return newBranch is Entry ? newBranch : new Branch2(Left, e, newBranch);
                }

                if (hash < e.Hash)
                {
                    var left = Left;
                    if (left is OnTheVergeOfBalance l)
                    {
                        ImHashMap<K, V> splitRight = null;
                        newBranch = l.AddOrGetEntry(hash, ref entry, ref splitRight);
                        if (splitRight != null)
                            return new Branch3(newBranch, entry, splitRight, e, Right);
                    }
                    else newBranch = left.AddOrGetEntry(hash, entry);
                    return newBranch is Entry ? newBranch : new Branch2(newBranch, e, Right);
                }

                return e;
            }

            internal override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry)
            {
                var h = MidEntry.Hash;
                return hash > h ? new Branch2(Left, MidEntry, Right.ReplaceEntry(hash, oldEntry, newEntry))
                    : hash < h ? new Branch2(Left.ReplaceEntry(hash, oldEntry, newEntry), MidEntry, Right)
                    : new Branch2(Left, newEntry, Right);
            }

            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry)
            {
                // The downward phase for deleting an element from a 2-3 tree is the same as the downward phase
                // for inserting an element except for the case when the element to be deleted is equal to the value in
                // a 2-node or a 3-node. In this case, if the value is not part of a terminal node, the value is replaced
                // by its in-order predecessor or in-order successor, just as in binary search tree deletion. So in any
                // case, deletion leaves a hole in a terminal node.
                // The goal of the rest of the deletion algorithm is to remove the hole without violating the other
                // invariants of the 2-3 tree.

                var mid = MidEntry;
                if (removedEntry.Hash > mid.Hash)
                {
                    var newRight = Right.RemoveEntry(removedEntry);
                    if (newRight == Empty)
                    {
                        // if the left node is not full yet then merge
                        if (Left is Leaf5Plus1Plus1 == false)
                            return Left.AddOrGetEntry(mid.Hash, mid);
                        return new Branch2(Left.RemoveEntry(removedEntry = Left.GetMaxHashEntryOrDefault()), removedEntry, mid); //! the height does not change
                    }

                    //*rebalance needed: the branch was merged from Br2 to Br3 or to the leaf and the height decreased 
                    if (Right is Branch2 && newRight is Branch2 == false)
                    {
                        // the the hole has a 2-node as a parent and a 3-node as a sibling.
                        if (Left is Branch3 lb3) //! the height does not change
                            return new Branch2(new Branch2(lb3.Left, lb3.Entry0, lb3.Middle), lb3.Entry1, new Branch2(lb3.Right, mid, newRight));

                        // the the hole has a 2-node as a parent and a 2-node as a sibling.
                        var lb2 = (Branch2)Left;
                        return new Branch3(lb2.Left, lb2.MidEntry, lb2.Right, mid, newRight);
                    }

                    return new Branch2(Left, mid, newRight);
                }

                // case 1, downward: swap the predecessor entry (max left entry) with the mid entry, then proceed to remove the predecessor from the Left branch
                if (removedEntry == mid)
                    removedEntry = mid = Left.GetMaxHashEntryOrDefault();

                // case 1, upward
                var newLeft = Left.RemoveEntry(removedEntry);
                if (newLeft == Empty)
                {
                    if (Right is Leaf5Plus1Plus1 == false)
                        return Right.AddOrGetEntry(mid.Hash, mid);
                    return new Branch2(mid, removedEntry = Right.GetMinHashEntryOrDefault(), Right.RemoveEntry(removedEntry)); //! the height does not change
                }

                //*rebalance needed: the branch was merged from Br2 to Br3 or to the leaf and the height decreased 
                if (Left is Branch2 && newLeft is Branch2 == false)
                {
                    // the the hole has a 2-node as a parent and a 3-node as a sibling.
                    if (Right is Branch3 rb3) //! the height does not change
                        return new Branch2(new Branch2(newLeft, mid, rb3.Left), rb3.Entry0, new Branch2(rb3.Middle, rb3.Entry1, rb3.Right));

                    // the the hole has a 2-node as a parent and a 2-node as a sibling.
                    var rb2 = (Branch2)Right;
                    return new Branch3(newLeft, mid, rb2.Left, rb2.MidEntry, rb2.Right);
                }

                return new Branch2(newLeft, mid, Right);
            }
        }

        /// <summary>Branch of 3 with 2 nodes in between</summary>
        internal sealed class Branch3 : OnTheVergeOfBalance
        {
            public readonly Entry Entry0, Entry1;
            public readonly ImHashMap<K, V> Left, Middle, Right;

            public Branch3(ImHashMap<K, V> left, Entry e0, ImHashMap<K, V> middle, Entry e1, ImHashMap<K, V> right)
            {
                Debug.Assert(e0.Hash < e1.Hash, $"e0.Hash:{e0.Hash} < e1.Hash{e1.Hash}");
                Left = left;
                Entry0 = e0;
                Middle = middle;
                Entry1 = e1;
                Right = right;
            }

            public override int Count() => Entry0.Count() + Entry1.Count() + Left.Count() + Middle.Count() + Right.Count();

#if !DEBUG
            public override string ToString() => "{B3:{E0:" + Entry0 + ",E1:" + Entry0 + ",L:" + Left + ",M:" + Middle + ",R:" + Right + "}}";
#endif

            internal override Entry GetMinHashEntryOrDefault() => Left.GetMinHashEntryOrDefault();
            internal override Entry GetMaxHashEntryOrDefault() => Right.GetMaxHashEntryOrDefault();

            internal override Entry GetEntryOrNull(int hash)
            {
                var h1 = Entry1.Hash;
                if (hash > h1)
                    return Right.GetEntryOrNull(hash);
                var h0 = Entry0.Hash;
                if (hash < h0)
                    return Left.GetEntryOrNull(hash);
                if (h0 == hash)
                    return Entry0;
                if (h1 == hash)
                    return Entry1;
                return Middle.GetEntryOrNull(hash);
            }

            public override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)
            {
                var h1 = Entry1.Hash;
                if (hash > h1)
                {
                    var right = Right;
                    var newRight = right.AddOrGetEntry(hash, entry);
                    if (newRight is Entry)
                        return newRight;
                    if (right is OnTheVergeOfBalance && newRight is Branch2)
                        return new Branch2(new Branch2(Left, Entry0, Middle), Entry1, newRight);
                    return new Branch3(Left, Entry0, Middle, Entry1, newRight);
                }

                var h0 = Entry0.Hash;
                if (hash < h0)
                {
                    var left = Left;
                    var newLeft = left.AddOrGetEntry(hash, entry);
                    if (newLeft is Entry)
                        return newLeft;
                    if (left is OnTheVergeOfBalance && newLeft is Branch2)
                        return new Branch2(newLeft, Entry0, new Branch2(Middle, Entry1, Right));
                    return new Branch3(newLeft, Entry0, Middle, Entry1, Right);
                }

                if (hash > h0 && hash < h1)
                {
                    var middle = Middle;
                    ImHashMap<K, V> newBranch = null;
                    if (middle is OnTheVergeOfBalance m)
                    {
                        ImHashMap<K, V> splitMiddleRight = null;
                        newBranch = m.AddOrGetEntry(hash, ref entry, ref splitMiddleRight);
                        if (splitMiddleRight != null)
                            return new Branch2(new Branch2(Left, Entry0, newBranch), entry, new Branch2(splitMiddleRight, Entry1, Right));
                    }
                    else newBranch = middle.AddOrGetEntry(hash, entry);
                    return newBranch is Entry ? newBranch : new Branch3(Left, Entry0, newBranch, Entry1, Right);
                }

                return hash == h0 ? Entry0 : Entry1;
            }

            internal override ImHashMap<K, V> AddOrGetEntry(int hash, ref Entry entry, ref ImHashMap<K, V> splitRight)
            {
                var h1 = Entry1.Hash;
                if (hash > h1)
                {
                    var right = Right;
                    var newRight = right.AddOrGetEntry(hash, entry);
                    if (newRight is Entry)
                        return newRight;
                    if (right is OnTheVergeOfBalance && newRight is Branch2)
                    {
                        entry = Entry1;
                        splitRight = newRight;
                        return new Branch2(Left, Entry0, Middle);
                    }
                    return new Branch3(Left, Entry0, Middle, Entry1, newRight);
                }

                var h0 = Entry0.Hash;
                if (hash < h0)
                {
                    var left = Left;
                    var newLeft = left.AddOrGetEntry(hash, entry);
                    if (newLeft is Entry)
                        return newLeft;
                    if (left is OnTheVergeOfBalance && newLeft is Branch2)
                    {
                        entry = Entry0;
                        splitRight = new Branch2(Middle, Entry1, Right);
                        return newLeft;
                    }

                    return new Branch3(newLeft, Entry0, Middle, Entry1, Right);
                }

                if (hash > h0 && hash < h1)
                {
                    var middle = Middle;
                    ImHashMap<K, V> newBranch = null;
                    if (middle is OnTheVergeOfBalance m)
                    {
                        ImHashMap<K, V> splitMiddleRight = null;
                        newBranch = m.AddOrGetEntry(hash, ref entry, ref splitMiddleRight);
                        if (splitMiddleRight != null)
                        {
                            // entry = entry; we don't need to assign the entry because it is already containing the proper value
                            splitRight = new Branch2(splitMiddleRight, Entry1, Right);
                            return new Branch2(Left, Entry0, newBranch);
                        }
                    }
                    else
                        newBranch = middle.AddOrGetEntry(hash, entry);
                    if (newBranch is Entry)
                        return newBranch;
                    return new Branch3(Left, Entry0, newBranch, Entry1, Right);
                }

                return hash == h0 ? Entry0 : Entry1;
            }

            internal override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry)
            {
                int h0 = Entry0.Hash, h1 = Entry1.Hash;
                return hash > h1 ? new Branch3(Left, Entry0, Middle, Entry1, Right.ReplaceEntry(hash, oldEntry, newEntry))
                    : hash < h0 ? new Branch3(Left.ReplaceEntry(hash, oldEntry, newEntry), Entry0, Middle, Entry1, Right)
                    : hash > h0 && hash < h1 ? new Branch3(Left, Entry0, Middle.ReplaceEntry(hash, oldEntry, newEntry), Entry1, Right)
                    : hash == h0 ? new Branch3(Left, newEntry, Middle, Entry1, Right) : new Branch3(Left, Entry0, Middle, newEntry, Right);
            }

            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry)
            {
                var midLeft = Entry0;
                var middle = Middle;
                var midRight = Entry1;
                var right = Right;

                // case 1, downward: swap the predecessor entry (max left entry) with the mid entry, then proceed to remove the predecessor from the Left branch
                if (removedEntry == midLeft)
                    removedEntry = midLeft = Left.GetMaxHashEntryOrDefault();

                if (removedEntry.Hash <= midLeft.Hash)
                {
                    var newLeft = Left.RemoveEntry(removedEntry);
                    if (newLeft == Empty)
                    {
                        if (middle is Leaf5Plus1Plus1 == false)
                            return new Branch2(middle.AddOrGetEntry(midLeft.Hash, midLeft), midRight, right); //! the height does not change
                        return new Branch3(midLeft, removedEntry = middle.GetMinHashEntryOrDefault(), middle.RemoveEntry(removedEntry), midRight, right); //! the height does not change
                    }

                    // rebalance is needed because the branch was merged from Br2 to Br3 or to Leaf and the height decrease
                    if (Left is Branch2 && newLeft is Branch2 == false)
                    {
                        // the hole has a 3-node as a parent and a 3-node as a sibling.
                        if (middle is Branch3 mb3) //! the height does not change
                            return new Branch3(new Branch2(newLeft, midLeft, mb3.Left), mb3.Entry0, new Branch2(mb3.Middle, mb3.Entry1, mb3.Right), midRight, right);

                        // the hole has a 3-node as a parent and a 2-node as a sibling.
                        var mb2 = (Branch2)middle;
                        return new Branch2(new Branch3(newLeft, midLeft, mb2.Left, mb2.MidEntry, mb2.Right), midRight, right);
                    }

                    return new Branch3(newLeft, midLeft, middle, midRight, right); // no rebalance needed
                }

                if (removedEntry == midRight)
                    removedEntry = midRight = middle.GetMaxHashEntryOrDefault();

                if (removedEntry.Hash <= midRight.Hash)
                {
                    var newMiddle = middle.RemoveEntry(removedEntry);
                    if (newMiddle == Empty)
                    {
                        if (right is Leaf5Plus1Plus1 == false)
                            return new Branch2(Left, midLeft, right.AddOrGetEntry(midRight.Hash, midRight)); // the Br3 become the Br2 but the height did not change - so no rebalance needed
                        return new Branch3(Left, midLeft, midRight, removedEntry = right.GetMinHashEntryOrDefault(), right.RemoveEntry(removedEntry)); //! the height does not change
                    }

                    if (middle is Branch2 && newMiddle is Branch2 == false)
                    {
                        // the hole has a 3-node as a parent and a 3-node as a sibling.
                        if (right is Branch3 rb3) //! the height does not change
                            return new Branch3(Left, midLeft, new Branch2(newMiddle, midRight, rb3.Left), rb3.Entry0, new Branch2(rb3.Middle, rb3.Entry1, rb3.Right));

                        // the hole has a 3-node as a parent and a 2-node as a sibling.
                        var rb2 = (Branch2)right;
                        return new Branch2(Left, midLeft, new Branch3(newMiddle, midRight, rb2.Left, rb2.MidEntry, rb2.Right));
                    }

                    return new Branch3(Left, midLeft, newMiddle, midRight, right);
                }

                var newRight = right.RemoveEntry(removedEntry);
                if (newRight == Empty)
                {
                    if (middle is Leaf5Plus1Plus1 == false)
                        return new Branch2(Left, midLeft, middle.AddOrGetEntry(midRight.Hash, midRight));
                    return new Branch3(Left, midLeft, middle.RemoveEntry(removedEntry = middle.GetMaxHashEntryOrDefault()), removedEntry, midRight);
                }

                // right was a Br2 but now is Leaf or Br3 - means the branch height is decrease
                if (right is Branch2 && newRight is Branch2 == false)
                {
                    // the hole has a 3-node as a parent and a 3-node as a sibling.new
                    if (middle is Branch3 mb3) //! the height does not change
                        return new Branch3(Left, midLeft, new Branch2(mb3.Left, mb3.Entry0, mb3.Middle), mb3.Entry1, new Branch2(mb3.Right, midRight, newRight));

                    // the hole has a 3-node as a parent and a 2-node as a sibling.
                    var mb2 = (Branch2)middle;
                    return new Branch2(Left, midLeft, new Branch3(mb2.Left, mb2.MidEntry, mb2.Right, midRight, newRight));
                }

                return new Branch3(Left, midLeft, middle, midRight, newRight);
            }
        }
    }


    /// <summary>The map methods</summary>
    public static class ImHashMap
    {
        /// <summary>Creates the entry to help with inference</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMapEntry<K, V> Entry<K, V>(K key, V value) => new ImHashMapEntry<K, V>(key.GetHashCode(), key, value);

        /// <summary>Creates the entry to help with inference</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMapEntry<K, V> Entry<K, V>(int hash, K key, V value) => new ImHashMapEntry<K, V>(hash, key, value);

        /// <summary>Creates the conflicting entry out of two entries</summary>
        [MethodImpl((MethodImplOptions)256)]
        internal static ImHashMap<K, V>.Entry WithConflicting<K, V>(this ImHashMapEntry<K, V> one, ImHashMapEntry<K, V> two) =>
            new HashConflictingEntry<K, V>(one.Hash, one, two);

        /// <summary>Sets the value and returns the entry</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMapEntry<K, V> SetValue<K, V>(this ImHashMapEntry<K, V> e, V value)
        {
            e.Value = value;
            return e;
        }

        private static readonly object _enumerationB3Tombstone = new object();

        /// <summary>Enumerates all the map entries in the hash order.
        /// The `parents` parameter allow sto reuse the stack memory used for traversal between multiple enumerates.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent `Enumerate` calls</summary>
        public static IEnumerable<ImHashMapEntry<K, V>> Enumerate<K, V>(this ImHashMap<K, V> map, MapParentStack parents = null)
        {
            if (map == ImHashMap<K, V>.Empty)
                yield break;
            if (map is ImHashMap<K, V>.Entry e)
            {
                if (e is ImHashMapEntry<K, V> v) yield return v;
                else foreach (var c in ((HashConflictingEntry<K, V>)e).Conflicts) yield return c;
                yield break;
            }

            var count = 0;
            while (true)
            {
                if (map is ImHashMap<K, V>.Branch2 b2)
                {
                    if (parents == null)
                        parents = new MapParentStack();
                    parents.Put(map, count++);
                    map = b2.Left;
                    continue;
                }
                if (map is ImHashMap<K, V>.Branch3 b3)
                {
                    if (parents == null)
                        parents = new MapParentStack();
                    parents.Put(map, count++);
                    map = b3.Left;
                    continue;
                }

                if (map is ImHashMap<K, V>.Entry l1)
                {
                    if (l1 is ImHashMapEntry<K, V> v0) yield return v0;
                    else foreach (var c in ((HashConflictingEntry<K, V>)l1).Conflicts) yield return c;
                }
                else if (map is ImHashMap<K, V>.Leaf2 l2)
                {
                    if (l2.Entry0 is ImHashMapEntry<K, V> v0) yield return v0;
                    else foreach (var c in ((HashConflictingEntry<K, V>)l2.Entry0).Conflicts) yield return c;
                    if (l2.Entry1 is ImHashMapEntry<K, V> v1) yield return v1;
                    else foreach (var c in ((HashConflictingEntry<K, V>)l2.Entry1).Conflicts) yield return c;
                }
                else if (map is ImHashMap<K, V>.Leaf2Plus1 l21)
                {
                    var p = l21.Plus;
                    var ph = p.Hash;
                    var l = l21.L;
                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, swap = null;
                    if (ph < e1.Hash)
                    {
                        swap = e1; e1 = p; p = swap;
                        if (ph < e0.Hash)
                        {
                            swap = e0; e0 = e1; e1 = swap;
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) yield return v0;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) yield return c;
                    if (e1 is ImHashMapEntry<K, V> v1) yield return v1;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) yield return c;
                    if (p is ImHashMapEntry<K, V> v2) yield return v2;
                    else foreach (var c in ((HashConflictingEntry<K, V>)p).Conflicts) yield return c;
                }
                else if (map is ImHashMap<K, V>.Leaf2Plus1Plus1 l211)
                {
                    var p = l211.Plus;
                    var pp = l211.L.Plus;
                    var ph = pp.Hash;
                    var l = l211.L.L;
                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, swap = null;
                    if (ph < e1.Hash)
                    {
                        swap = e1; e1 = pp; pp = swap;
                        if (ph < e0.Hash)
                        {
                            swap = e0; e0 = e1; e1 = swap;
                        }
                    }

                    ph = p.Hash;
                    if (ph < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (ph < e1.Hash)
                        {
                            swap = e1; e1 = pp; pp = swap;
                            if (ph < e0.Hash)
                            {
                                swap = e0; e0 = e1; e1 = swap;
                            }
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) yield return v0;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) yield return c;
                    if (e1 is ImHashMapEntry<K, V> v1) yield return v1;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) yield return c;
                    if (pp is ImHashMapEntry<K, V> v2) yield return v2;
                    else foreach (var c in ((HashConflictingEntry<K, V>)pp).Conflicts) yield return c;
                    if (p is ImHashMapEntry<K, V> v3) yield return v3;
                    else foreach (var c in ((HashConflictingEntry<K, V>)p).Conflicts) yield return c;
                }
                else if (map is ImHashMap<K, V>.Leaf5 l5)
                {
                    if (l5.Entry0 is ImHashMapEntry<K, V> v0) yield return v0;
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry0).Conflicts) yield return c;
                    if (l5.Entry1 is ImHashMapEntry<K, V> v1) yield return v1;
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry1).Conflicts) yield return c;
                    if (l5.Entry2 is ImHashMapEntry<K, V> v2) yield return v2;
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry2).Conflicts) yield return c;
                    if (l5.Entry3 is ImHashMapEntry<K, V> v3) yield return v3;
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry3).Conflicts) yield return c;
                    if (l5.Entry4 is ImHashMapEntry<K, V> v4) yield return v4;
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry4).Conflicts) yield return c;
                }
                else if (map is ImHashMap<K, V>.Leaf5Plus1 l51)
                {
                    var p = l51.Plus;
                    var ph = p.Hash;
                    var l = l51.L;
                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, swap = null;
                    if (ph < e4.Hash)
                    {
                        swap = e4; e4 = p; p = swap;
                        if (ph < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (ph < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (ph < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (ph < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) yield return v0;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) yield return c;
                    if (e1 is ImHashMapEntry<K, V> v1) yield return v1;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) yield return c;
                    if (e2 is ImHashMapEntry<K, V> v2) yield return v2;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e2).Conflicts) yield return c;
                    if (e3 is ImHashMapEntry<K, V> v3) yield return v3;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e3).Conflicts) yield return c;
                    if (e4 is ImHashMapEntry<K, V> v4) yield return v4;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e4).Conflicts) yield return c;
                    if (p is ImHashMapEntry<K, V> v5) yield return v5;
                    else foreach (var c in ((HashConflictingEntry<K, V>)p).Conflicts) yield return c;
                }
                else if (map is ImHashMap<K, V>.Leaf5Plus1Plus1 l511)
                {
                    var l = l511.L.L;
                    ImHashMap<K, V>.Entry
                        e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, p = l511.Plus, pp = l511.L.Plus, swap = null;
                    var h = pp.Hash;
                    if (h < e4.Hash)
                    {
                        swap = e4; e4 = pp; pp = swap;
                        if (h < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (h < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (h < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (h < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }

                    h = p.Hash;
                    if (h < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (h < e4.Hash)
                        {
                            swap = e4; e4 = pp; pp = swap;
                            if (h < e3.Hash)
                            {
                                swap = e3; e3 = e4; e4 = swap;
                                if (h < e2.Hash)
                                {
                                    swap = e2; e2 = e3; e3 = swap;
                                    if (h < e1.Hash)
                                    {
                                        swap = e1; e1 = e2; e2 = swap;
                                        if (h < e0.Hash)
                                        {
                                            swap = e0; e0 = e1; e1 = swap;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) yield return v0;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) yield return c;
                    if (e1 is ImHashMapEntry<K, V> v1) yield return v1;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) yield return c;
                    if (e2 is ImHashMapEntry<K, V> v2) yield return v2;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e2).Conflicts) yield return c;
                    if (e3 is ImHashMapEntry<K, V> v3) yield return v3;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e3).Conflicts) yield return c;
                    if (e4 is ImHashMapEntry<K, V> v4) yield return v4;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e4).Conflicts) yield return c;
                    if (pp is ImHashMapEntry<K, V> v5) yield return v5;
                    else foreach (var c in ((HashConflictingEntry<K, V>)pp).Conflicts) yield return c;
                    if (p is ImHashMapEntry<K, V> v6) yield return v6;
                    else foreach (var c in ((HashConflictingEntry<K, V>)p).Conflicts) yield return c;
                }

                if (count == 0)
                    break; // we yield the leaf and there is nothing in stack - we are DONE!

                var b = parents.Get(--count); // otherwise get the parent
                if (b is ImHashMap<K, V>.Branch2 pb2)
                {
                    if (pb2.MidEntry is ImHashMapEntry<K, V> v) yield return v;
                    else foreach (var c in ((HashConflictingEntry<K, V>)pb2.MidEntry).Conflicts) yield return c;
                    map = pb2.Right;
                }
                else if (b != _enumerationB3Tombstone)
                {
                    var pb3 = (ImHashMap<K, V>.Branch3)b;
                    if (pb3.Entry0 is ImHashMapEntry<K, V> v) yield return v;
                    else foreach (var c in ((HashConflictingEntry<K, V>)pb3.Entry0).Conflicts) yield return c;
                    map = pb3.Middle;
                    parents.Put(_enumerationB3Tombstone, ++count);
                    ++count;
                }
                else
                {
                    var pb3 = (ImHashMap<K, V>.Branch3)parents.Get(--count);
                    if (pb3.Entry1 is ImHashMapEntry<K, V> v) yield return v;
                    else foreach (var c in ((HashConflictingEntry<K, V>)pb3.Entry1).Conflicts) yield return c;
                    map = pb3.Right;
                }
            }
        }

        /// <summary>
        /// Depth-first in-order of hash traversal as described in http://en.wikipedia.org/wiki/Tree_traversal.
        /// The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        public static S ForEach<K, V, S>(this ImHashMap<K, V> map, S state, Action<ImHashMapEntry<K, V>, int, S> handler, MapParentStack parents = null)
        {
            if (map == ImHashMap<K, V>.Empty)
                return state;
            var i = 0;
            if (map is ImHashMap<K, V>.Entry e)
            {
                if (e is ImHashMapEntry<K, V> kv) handler(kv, 0, state);
                else foreach (var c in ((HashConflictingEntry<K, V>)e).Conflicts) handler(c, i++, state);
                return state;
            }

            var count = 0;
            while (true)
            {
                if (map is ImHashMap<K, V>.Branch2 b2)
                {
                    if (parents == null)
                        parents = new MapParentStack();
                    parents.Put(map, count++);
                    map = b2.Left;
                    continue;
                }
                if (map is ImHashMap<K, V>.Branch3 b3)
                {
                    if (parents == null)
                        parents = new MapParentStack();
                    parents.Put(map, count++);
                    map = b3.Left;
                    continue;
                }

                if (map is ImHashMap<K, V>.Entry l1)
                {
                    if (l1 is ImHashMapEntry<K, V> v0) handler(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l1).Conflicts) handler(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf2 l2)
                {
                    if (l2.Entry0 is ImHashMapEntry<K, V> v0) handler(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l2.Entry0).Conflicts) handler(c, i++, state);
                    if (l2.Entry1 is ImHashMapEntry<K, V> v1) handler(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l2.Entry1).Conflicts) handler(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf2Plus1 l21)
                {
                    var p = l21.Plus;
                    var ph = p.Hash;
                    var l = l21.L;
                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, swap = null;
                    if (ph < e1.Hash)
                    {
                        swap = e1; e1 = p; p = swap;
                        if (ph < e0.Hash)
                        {
                            swap = e0; e0 = e1; e1 = swap;
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) handler(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) handler(c, i++, state);
                    if (e1 is ImHashMapEntry<K, V> v1) handler(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) handler(c, i++, state);
                    if (p is ImHashMapEntry<K, V> v2) handler(v2, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)p).Conflicts) handler(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf2Plus1Plus1 l211)
                {
                    var p = l211.Plus;
                    var pp = l211.L.Plus;
                    var ph = pp.Hash;
                    var l = l211.L.L;
                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, swap = null;
                    if (ph < e1.Hash)
                    {
                        swap = e1; e1 = pp; pp = swap;
                        if (ph < e0.Hash)
                        {
                            swap = e0; e0 = e1; e1 = swap;
                        }
                    }

                    ph = p.Hash;
                    if (ph < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (ph < e1.Hash)
                        {
                            swap = e1; e1 = pp; pp = swap;
                            if (ph < e0.Hash)
                            {
                                swap = e0; e0 = e1; e1 = swap;
                            }
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) handler(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) handler(c, i++, state);
                    if (e1 is ImHashMapEntry<K, V> v1) handler(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) handler(c, i++, state);
                    if (pp is ImHashMapEntry<K, V> v2) handler(v2, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)pp).Conflicts) handler(c, i++, state);
                    if (p is ImHashMapEntry<K, V> v3) handler(v3, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)p).Conflicts) handler(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf5 l5)
                {
                    if (l5.Entry0 is ImHashMapEntry<K, V> v0) handler(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry0).Conflicts) handler(c, i++, state);
                    if (l5.Entry1 is ImHashMapEntry<K, V> v1) handler(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry1).Conflicts) handler(c, i++, state);
                    if (l5.Entry2 is ImHashMapEntry<K, V> v2) handler(v2, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry2).Conflicts) handler(c, i++, state);
                    if (l5.Entry3 is ImHashMapEntry<K, V> v3) handler(v3, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry3).Conflicts) handler(c, i++, state);
                    if (l5.Entry4 is ImHashMapEntry<K, V> v4) handler(v4, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry4).Conflicts) handler(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf5Plus1 l51)
                {
                    var p = l51.Plus;
                    var ph = p.Hash;
                    var l = l51.L;
                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, swap = null;
                    if (ph < e4.Hash)
                    {
                        swap = e4; e4 = p; p = swap;
                        if (ph < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (ph < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (ph < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (ph < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) handler(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) handler(c, i++, state);
                    if (e1 is ImHashMapEntry<K, V> v1) handler(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) handler(c, i++, state);
                    if (e2 is ImHashMapEntry<K, V> v2) handler(v2, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e2).Conflicts) handler(c, i++, state);
                    if (e3 is ImHashMapEntry<K, V> v3) handler(v3, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e3).Conflicts) handler(c, i++, state);
                    if (e4 is ImHashMapEntry<K, V> v4) handler(v4, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e4).Conflicts) handler(c, i++, state);
                    if (p is ImHashMapEntry<K, V> v5) handler(v5, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)p).Conflicts) handler(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf5Plus1Plus1 l511)
                {
                    var l = l511.L.L;
                    ImHashMap<K, V>.Entry
                        e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, p = l511.Plus, pp = l511.L.Plus, swap = null;
                    var h = pp.Hash;
                    if (h < e4.Hash)
                    {
                        swap = e4; e4 = pp; pp = swap;
                        if (h < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (h < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (h < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (h < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }

                    h = p.Hash;
                    if (h < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (h < e4.Hash)
                        {
                            swap = e4; e4 = pp; pp = swap;
                            if (h < e3.Hash)
                            {
                                swap = e3; e3 = e4; e4 = swap;
                                if (h < e2.Hash)
                                {
                                    swap = e2; e2 = e3; e3 = swap;
                                    if (h < e1.Hash)
                                    {
                                        swap = e1; e1 = e2; e2 = swap;
                                        if (h < e0.Hash)
                                        {
                                            swap = e0; e0 = e1; e1 = swap;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) handler(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) handler(c, i++, state);
                    if (e1 is ImHashMapEntry<K, V> v1) handler(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) handler(c, i++, state);
                    if (e2 is ImHashMapEntry<K, V> v2) handler(v2, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e2).Conflicts) handler(c, i++, state);
                    if (e3 is ImHashMapEntry<K, V> v3) handler(v3, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e3).Conflicts) handler(c, i++, state);
                    if (e4 is ImHashMapEntry<K, V> v4) handler(v4, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e4).Conflicts) handler(c, i++, state);
                    if (pp is ImHashMapEntry<K, V> v5) handler(v5, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)pp).Conflicts) handler(c, i++, state);
                    if (p is ImHashMapEntry<K, V> v6) handler(v6, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)p).Conflicts) handler(c, i++, state);
                }

                if (count == 0)
                    break; // we yield the leaf and there is nothing in stack - we are DONE!

                var b = parents.Get(--count); // otherwise get the parent
                if (b is ImHashMap<K, V>.Branch2 pb2)
                {
                    if (pb2.MidEntry is ImHashMapEntry<K, V> v) handler(v, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)pb2.MidEntry).Conflicts) handler(c, i++, state);
                    map = pb2.Right;
                }
                else if (b != _enumerationB3Tombstone)
                {
                    var pb3 = (ImHashMap<K, V>.Branch3)b;
                    if (pb3.Entry0 is ImHashMapEntry<K, V> v) handler(v, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)pb3.Entry0).Conflicts) handler(c, i++, state);
                    map = pb3.Middle;
                    parents.Put(_enumerationB3Tombstone, ++count);
                    ++count;
                }
                else
                {
                    var pb3 = (ImHashMap<K, V>.Branch3)parents.Get(--count);
                    if (pb3.Entry1 is ImHashMapEntry<K, V> v) handler(v, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)pb3.Entry1).Conflicts) handler(c, i++, state);
                    map = pb3.Right;
                }
            }

            return state;
        }

        /// <summary>Do something for each entry.
        /// The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        public static void ForEach<K, V>(this ImHashMap<K, V> map, Action<ImHashMapEntry<K, V>, int> handler, MapParentStack parents = null) =>
            map.ForEach(handler, (e, i, r) => r(e, i), parents);

        /// <summary>Collect something for each entry.
        /// The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        public static S Fold<K, V, S>(this ImHashMap<K, V> map, S state, Func<ImHashMapEntry<K, V>, int, S, S> handler, MapParentStack parents = null) =>
            map.ForEach(St.Rent(state, handler), (e, i, s) => s.a = s.b(e, i, s.a), parents).ResetButGetA();

        /// <summary>Converts map to an array with the minimum allocations</summary>
        public static S[] ToArray<K, V, S>(this ImHashMap<K, V> map, Func<ImHashMapEntry<K, V>, S> selector) =>
            map == ImHashMap<K, V>.Empty ? ArrayTools.Empty<S>() :
                map.ForEach(St.Rent(new S[map.Count()], selector), (e, i, s) => s.a[i] = s.b(e)).ResetButGetA();

        /// <summary>Converts map to an array with the minimum allocations</summary>
        public static ImHashMapEntry<K, V>[] ToArray<K, V>(this ImHashMap<K, V> map) =>
            map == ImHashMap<K, V>.Empty ? ArrayTools.Empty<ImHashMapEntry<K, V>>() :
                map.ForEach(new ImHashMapEntry<K, V>[map.Count()], (e, i, a) => a[i] = e);

        /// <summary>Converts the map to the dictionary</summary>
        public static Dictionary<K, V> ToDictionary<K, V>(this ImHashMap<K, V> map) =>
            map == ImHashMap<K, V>.Empty ? new Dictionary<K, V>(0) :
                map.ForEach(new Dictionary<K, V>(), (e, _, d) => d.Add(e.Key, e.Value));

        /// <summary>Get the key value entry if the hash and key is in the map or the default `null` value otherwise.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMapEntry<K, V> GetEntryOrDefault<K, V>(this ImHashMap<K, V> map, int hash, K key)
        {
            var e = map.GetEntryOrNull(hash);

            if (e is ImHashMapEntry<K, V> kv)
                return kv.Key.Equals(key) ? kv : null;

            if (e is HashConflictingEntry<K, V> hc)
                foreach (var x in hc.Conflicts)
                    if (x.Key.Equals(key))
                        return x;

            return null;
        }

        /// <summary>Get the key value entry if the key is in the map or the default `null` value otherwise.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMapEntry<K, V> GetEntryOrDefault<K, V>(this ImHashMap<K, V> map, K key) =>
            GetEntryOrDefault(map, key.GetHashCode(), key);

        /// <summary>Returns <see langword="true"/> if map contains the hash and key, otherwise returns <see langword="false"/></summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool Contains<K, V>(this ImHashMap<K, V> map, int hash, K key) => map.GetEntryOrDefault(hash, key) != null;

        /// <summary>Returns <see langword="true"/> if map contains the key, otherwise returns <see langword="false"/></summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool Contains<K, V>(this ImHashMap<K, V> map, K key) => map.GetEntryOrDefault(key.GetHashCode(), key) != null;

        /// <summary>Returns the entry ASSUMING it is present otherwise its behavior is UNDEFINED.
        /// You can use the method after the Add and Update methods on the same map instance - because the map is immutable it is for sure contains added or updated entry.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMapEntry<K, V> GetSurePresentEntry<K, V>(this ImHashMap<K, V> map, int hash, K key)
        {
            var e = map.GetEntryOrNull(hash);
            if (e is HashConflictingEntry<K, V> c)
                foreach (var x in c.Conflicts)
                    if (x.Key.Equals(key))
                        return x;

            return (ImHashMapEntry<K, V>)e; // we don't need the comparison of the key because there is only one entry with the key
        }

        /// <summary>Lookup for the value by the key using the hash and checking the key with the `object.Equals` for equality, 
        /// returns the default `V` if hash, key are not found.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, int hash, K key)
        {
            var e = map.GetEntryOrNull(hash);
            if (e is ImHashMapEntry<K, V> kv)
            {
                if (kv.Key.Equals(key))
                    return kv.Value;
            }
            else if (e is HashConflictingEntry<K, V> hc)
            {
                foreach (var x in hc.Conflicts)
                    if (x.Key.Equals(key))
                        return x.Value;
            }
            return default(V);
        }

        /// <summary>Lookup for the value by key using its hash and checking the key with the `object.Equals` for equality, 
        /// returns the default `V` if hash, key are not found.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, K key) =>
            map.GetValueOrDefault(key.GetHashCode(), key);

        /// <summary>Lookup for the value by the key using the hash and checking the key with the `object.ReferenceEquals` for equality,
        ///  returns found value or the default value if not found</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefaultByReferenceEquals<K, V>(this ImHashMap<K, V> map, int hash, K key) where K : class
        {
            var e = map.GetEntryOrNull(hash);
            if (e is ImHashMapEntry<K, V> kv)
            {
                if (kv.Key == key)
                    return kv.Value;
            }
            else if (e is HashConflictingEntry<K, V> hc)
            {
                foreach (var x in hc.Conflicts)
                    if (x.Key == key)
                        return x.Value;
            }
            return default(V);
        }

        /// <summary>Lookup for the value by the key using the hash and checking the key with the `object.Equals` for equality,
        /// returns the `true` and the found value or the `false` otherwise</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<K, V>(this ImHashMap<K, V> map, int hash, K key, out V value)
        {
            var e = map.GetEntryOrNull(hash);
            if (e is ImHashMapEntry<K, V> kv)
            {
                if (kv.Key.Equals(key))
                {
                    value = kv.Value;
                    return true;
                }
            }
            else if (e is HashConflictingEntry<K, V> hc)
            {
                foreach (var x in hc.Conflicts)
                    if (x.Key.Equals(key))
                    {
                        value = x.Value;
                        return true;
                    }
            }

            value = default(V);
            return false;
        }

        /// <summary>Lookup for the value by the key using the hash and checking the key with the `object.ReferenceEquals`, 
        /// returns the `true` and the found value or the `false` otherwise</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFindByReferenceEquals<K, V>(this ImHashMap<K, V> map, int hash, K key, out V value) where K : class
        {
            var e = map.GetEntryOrNull(hash);
            if (e is ImHashMapEntry<K, V> kv)
            {
                if (kv.Key == key)
                {
                    value = kv.Value;
                    return true;
                }
            }
            else if (e is HashConflictingEntry<K, V> hc)
            {
                foreach (var x in hc.Conflicts)
                    if (x.Key == key)
                    {
                        value = x.Value;
                        return true;
                    }
            }

            value = default(V);
            return false;
        }

        /// <summary>Lookup for the value by the key using its hash and checking the key with the `object.Equals` for equality,
        /// returns the `true` and the found value or the `false` otherwise</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<K, V>(this ImHashMap<K, V> map, K key, out V value) =>
            map.TryFind(key.GetHashCode(), key, out value);

        /// <summary>Adds the entry and returns the new map or if the hash is present then return the found entry or the newEntry if the map is empty, 
        /// so you may check the result like this `if (res is ImMapEntry&lt;V&gt; entry &amp;&amp; entry != newEntry)`</summary>
        public static ImHashMap<K, V> AddOrGetEntry<K, V>(this ImHashMap<K, V> map, ImHashMapEntry<K, V> newEntry)
        {
            var hash = newEntry.Hash;
            var mapOrOldEntry = map.AddOrGetEntry(hash, newEntry);
            if (mapOrOldEntry is ImHashMap<K, V>.Entry oldEntry && oldEntry != newEntry)
            {
                if (oldEntry is ImHashMapEntry<K, V> kv)
                    return kv.Key.Equals(newEntry.Key) ? oldEntry
                        : map.ReplaceEntry(hash, oldEntry, new HashConflictingEntry<K, V>(hash, kv, newEntry));

                var key = newEntry.Key;
                var cs = ((HashConflictingEntry<K, V>)oldEntry).Conflicts;
                var i = cs.Length - 1;
                while (i != -1 && !key.Equals(cs[i].Key)) --i;
                return i != -1 ? cs[i] : map.ReplaceEntry(hash, oldEntry, new HashConflictingEntry<K, V>(hash, cs.AppendToNonEmpty(newEntry)));
            }
            return mapOrOldEntry;
        }

        /// <summary>Adds or updates (no in-place mutation) the map with value by the passed hash and key, always returning the NEW map!</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> AddOrUpdate<K, V>(this ImHashMap<K, V> map, int hash, K key, V value)
        {
            var newEntry = new ImHashMapEntry<K, V>(hash, key, value);
            var mapOrOldEntry = map.AddOrGetEntry(hash, newEntry);
            return mapOrOldEntry is ImHashMap<K, V>.Entry oldEntry
                ? oldEntry == newEntry ? newEntry : map.ReplaceEntry(hash, oldEntry, oldEntry.Update(newEntry))
                : mapOrOldEntry;
        }

        /// <summary>Adds or updates (no in-place mutation) the map with the new entry, always returning the NEW map!</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> AddOrUpdateEntry<K, V>(this ImHashMap<K, V> map, ImHashMapEntry<K, V> newEntry)
        {
            var hash = newEntry.Hash;
            var mapOrOldEntry = map.AddOrGetEntry(hash, newEntry);
            return mapOrOldEntry is ImHashMap<K, V>.Entry oldEntry
                ? oldEntry == newEntry ? newEntry : map.ReplaceEntry(hash, oldEntry, oldEntry.Update(newEntry))
                : mapOrOldEntry;
        }

        /// <summary>Adds or updates (no in-place mutation) the map with value by the passed key, always returning the NEW map!</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> AddOrUpdate<K, V>(this ImHashMap<K, V> map, K key, V value) =>
            map.AddOrUpdate(key.GetHashCode(), key, value);

        /// <summary>Adds or updates (no in-place mutation) the map with value by the passed key, always returning the NEW map!</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> AddOrUpdate<K, V>(this ImHashMap<K, V> map, int hash, K key, V value, Update<K, V> update)
        {
            var newEntry = new ImHashMapEntry<K, V>(hash, key, value);
            var mapOrOldEntry = map.AddOrGetEntry(hash, newEntry);
            return mapOrOldEntry is ImHashMap<K, V>.Entry oldEntry
                ? oldEntry == newEntry ? newEntry : map.ReplaceEntry(hash, oldEntry, UpdateEntry(oldEntry, newEntry, update))
                : mapOrOldEntry;
        }

        /// <summary>Updates the possibly the conflicted entry with the new key and value entry using the provided update function.</summary>
        internal static ImHashMap<K, V>.Entry UpdateEntry<K, V>(ImHashMap<K, V>.Entry oldEntry, ImHashMapEntry<K, V> newEntry, Update<K, V> update)
        {
            var key = newEntry.Key;
            if (oldEntry is ImHashMapEntry<K, V> kv)
                return kv.Key.Equals(key) ? new ImHashMapEntry<K, V>(newEntry.Hash, key, update(key, kv.Value, newEntry.Value))
                    : (ImHashMap<K, V>.Entry)new HashConflictingEntry<K, V>(oldEntry.Hash, kv, newEntry);

            var cs = ((HashConflictingEntry<K, V>)oldEntry).Conflicts;
            var i = cs.Length - 1;
            while (i != -1 && !key.Equals(cs[i].Key)) --i;
            if (i != -1)
                newEntry = new ImHashMapEntry<K, V>(newEntry.Hash, key, update(key, cs[i].Value, newEntry.Value));
            return new HashConflictingEntry<K, V>(oldEntry.Hash, cs.AppendOrUpdate(newEntry, i));
        }

        /// <summary>Adds or updates (no in-place mutation) the map with value by the passed key, always returning the NEW map!</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> AddOrUpdate<K, V>(this ImHashMap<K, V> map, K key, V value, Update<K, V> update) =>
            map.AddOrUpdate(key.GetHashCode(), key, value, update);

        /// <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.</summary>
        public static ImHashMap<K, V> Update<K, V>(this ImHashMap<K, V> map, int hash, K key, V value)
        {
            var entry = map.GetEntryOrNull(hash);
            if (entry == null)
                return map;

            if (entry is ImHashMapEntry<K, V> kv)
                return kv.Key.Equals(key) ? map.ReplaceEntry(hash, entry, new ImHashMapEntry<K, V>(hash, key, value)) : map;

            var cs = ((HashConflictingEntry<K, V>)entry).Conflicts;
            var i = cs.Length - 1;
            while (i != -1 && !key.Equals(cs[i].Key)) --i;
            return i == -1 ? map :
                map.ReplaceEntry(hash, entry, new HashConflictingEntry<K, V>(hash, cs.UpdateNonEmpty(new ImHashMapEntry<K, V>(hash, key, value), i)));
        }

        /// <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> Update<K, V>(this ImHashMap<K, V> map, K key, V value) =>
            map.Update(key.GetHashCode(), key, value);

        /// <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.</summary>
        public static ImHashMap<K, V> UpdateToDefault<K, V>(this ImHashMap<K, V> map, int hash, K key)
        {
            var entry = map.GetEntryOrNull(hash);
            if (entry == null)
                return map;

            if (entry is ImHashMapEntry<K, V> kv)
                return kv.Key.Equals(key) ? map.ReplaceEntry(hash, entry, new ImHashMapEntry<K, V>(hash, key)) : map;

            var cs = ((HashConflictingEntry<K, V>)entry).Conflicts;
            var i = cs.Length - 1;
            while (i != -1 && !key.Equals(cs[i].Key)) --i;
            return i == -1 ? map :
                map.ReplaceEntry(hash, entry, new HashConflictingEntry<K, V>(hash, cs.UpdateNonEmpty(new ImHashMapEntry<K, V>(hash, key), i)));
        }

        /// <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> UpdateToDefault<K, V>(this ImHashMap<K, V> map, K key) =>
            map.UpdateToDefault(key.GetHashCode(), key);

        /// <summary>Updates the map with the new value and the `update` function if the key is found otherwise returns the same unchanged map.
        /// If `update` returns the same map if the updated result is the same</summary>
        public static ImHashMap<K, V> Update<K, V>(this ImHashMap<K, V> map, int hash, K key, V value, Update<K, V> update)
        {
            var entry = map.GetEntryOrNull(hash);
            if (entry == null)
                return map;

            if (entry is ImHashMapEntry<K, V> kv)
                return !kv.Key.Equals(key) || ReferenceEquals(kv.Value, value = update(key, kv.Value, value))
                    ? map
                    : map.ReplaceEntry(hash, entry, new ImHashMapEntry<K, V>(hash, key, value));

            var cs = ((HashConflictingEntry<K, V>)entry).Conflicts;
            var i = cs.Length - 1;
            while (i != -1 && !key.Equals(cs[i].Key)) --i;
            if (i == -1 || ReferenceEquals(cs[i].Value, value = update(key, cs[i].Value, value)))
                return map;
            return map.ReplaceEntry(hash, entry, new HashConflictingEntry<K, V>(hash, cs.UpdateNonEmpty(new ImHashMapEntry<K, V>(hash, key, value), i)));
        }

        /// <summary>Updates the map with the new value and the `update` function if the key is found otherwise returns the same unchanged map.
        /// If `update` returns the same map if the updated result is the same</summary>
        public static ImHashMap<K, V> Update<K, V>(this ImHashMap<K, V> map, K key, V value, Update<K, V> update) =>
            map.Update(key.GetHashCode(), key, value, update);

        /// <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> AddOrKeepEntry<K, V>(this ImHashMap<K, V> map, ImHashMapEntry<K, V> newEntry)
        {
            var hash = newEntry.Hash;
            var mapOrOldEntry = map.AddOrGetEntry(hash, newEntry);
            if (mapOrOldEntry is ImHashMap<K, V>.Entry oldEntry && oldEntry != newEntry)
            {
                var e = KeepOrAddEntry(oldEntry, newEntry);
                return e == oldEntry ? map : map.ReplaceEntry(hash, oldEntry, e);
            }

            return mapOrOldEntry;
        }

        /// <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> AddOrKeep<K, V>(this ImHashMap<K, V> map, int hash, K key, V value)
        {
            var newEntry = new ImHashMapEntry<K, V>(hash, key, value);
            var mapOrOldEntry = map.AddOrGetEntry(hash, newEntry);
            if (mapOrOldEntry is ImHashMap<K, V>.Entry oldEntry && oldEntry != newEntry)
            {
                var e = KeepOrAddEntry(oldEntry, newEntry);
                return e == oldEntry ? map : map.ReplaceEntry(hash, oldEntry, e);
            }

            return mapOrOldEntry;
        }

        private static ImHashMap<K, V>.Entry KeepOrAddEntry<K, V>(ImHashMap<K, V>.Entry oldEntry, ImHashMapEntry<K, V> newEntry)
        {
            if (oldEntry is ImHashMapEntry<K, V> kv)
                return kv.Key.Equals(newEntry.Key) ? oldEntry : (ImHashMap<K, V>.Entry)new HashConflictingEntry<K, V>(oldEntry.Hash, kv, newEntry);

            var key = newEntry.Key;
            var cs = ((HashConflictingEntry<K, V>)oldEntry).Conflicts;
            var i = cs.Length - 1;
            while (i != -1 && !key.Equals(cs[i].Key)) --i;
            if (i != -1) // return the existing map
                return oldEntry;
            return new HashConflictingEntry<K, V>(oldEntry.Hash, cs.AppendToNonEmpty(newEntry));
        }

        /// <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> AddOrKeep<K, V>(this ImHashMap<K, V> map, K key, V value) =>
            map.AddOrKeep(key.GetHashCode(), key, value);

        /// <summary>Returns the new map without the specified hash and key (if found) or returns the same map otherwise</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> Remove<K, V>(this ImHashMap<K, V> map, int hash, K key)
        {
            var entryToRemove = map.GetEntryOrNull(hash);
            if (entryToRemove is ImHashMapEntry<K, V>)
                return map.RemoveEntry(entryToRemove);

            if (entryToRemove is HashConflictingEntry<K, V> hc)
            {
                var entryToReplace = RemoveEntryToReplaceOrDefault(hc, key);
                return entryToReplace == null ? map : map.ReplaceEntry(hash, entryToRemove, entryToReplace);
            }

            return map;
        }

        private static ImHashMap<K, V>.Entry RemoveEntryToReplaceOrDefault<K, V>(HashConflictingEntry<K, V> hc, K key)
        {
            var cs = hc.Conflicts;
            var n = cs.Length;
            var i = n - 1;
            while (i != -1 && !cs[i].Key.Equals(key)) --i;
            if (i != -1)
            {
                if (n == 2)
                    return i == 0 ? cs[1] : cs[0];
                var newConflicts = new ImHashMapEntry<K, V>[n -= 1]; // the new n is less by one
                if (i > 0) // copy the 1st part
                    Array.Copy(cs, 0, newConflicts, 0, i);
                if (i < n) // copy the 2nd part
                    Array.Copy(cs, i + 1, newConflicts, i, n - i);
                return new HashConflictingEntry<K, V>(hc.Hash, newConflicts);
            }

            return null;
        }

        /// <summary>Returns the new map without the specified hash and key (if found) or returns the same map otherwise</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> Remove<K, V>(this ImHashMap<K, V> map, K key) =>
            map == ImHashMap<K, V>.Empty ? map : map.Remove(key.GetHashCode(), key); // it make sense to have the empty map condition here to prevent the probably costly `GetHashCode()` for the empty map.
    }

    /// <summary>
    /// The fixed array of maps (partitions) where the key first (lower) bits are used to locate the partion to lookup into.
    /// Note: The partition array is NOT immutable and operates by swapping the updated partition with the new one.
    /// The number of partitions may be specified by user or you can use the default number 16.
    /// The default number 16 was selected to be not so big to pay for the few items and not so small to diminish the use of partitions.
    /// </summary>
    public static class PartitionedHashMap
    {
        /// <summary>The default number of partitions</summary>
        public const int PARTITION_COUNT_POWER_OF_TWO = 16;

        /// <summary>The default mask to partition the key</summary>
        public const int PARTITION_HASH_MASK = PARTITION_COUNT_POWER_OF_TWO - 1;

        /// <summary>Creates the new collection with the empty partions</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V>[] CreateEmpty<K, V>(int partitionCountOfPowerOfTwo = PARTITION_COUNT_POWER_OF_TWO)
        {
            var parts = new ImHashMap<K, V>[partitionCountOfPowerOfTwo];
            for (var i = 0; i < parts.Length; ++i)
                parts[i] = ImHashMap<K, V>.Empty;
            return parts;
        }

        /// <summary>Lookup for the value by the key using the hash and checking the key with the `object.Equals` for equality, 
        /// returns the default `V` if hash, key are not found.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, int partHashMask = PARTITION_HASH_MASK)
        {
            var p = parts[hash & partHashMask];
            return p != null ? p.GetValueOrDefault(hash, key) : default(V);
        }

        /// <summary>Lookup for the value by the key using the hash and checking the key with the `object.ReferenceEquals` for equality,
        ///  returns found value or the default value if not found</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefaultByReferenceEquals<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, int partHashMask = PARTITION_HASH_MASK) where K : class
        {
            var p = parts[hash & partHashMask];
            return p != null ? p.GetValueOrDefaultByReferenceEquals(hash, key) : default(V);
        }

        /// <summary>Lookup for the value by the key using its hash and checking the key with the `object.Equals` for equality, 
        /// returns the default `V` if hash, key are not found.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V>[] parts, K key, int partHashMask = PARTITION_HASH_MASK) =>
            parts.GetValueOrDefault(key.GetHashCode(), key, partHashMask);

        /// <summary>Lookup for the value by the key using the hash code and checking the key with the `object.Equals` for equality,
        /// returns the `true` and the found value or the `false`</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, out V value, int partHashMask = PARTITION_HASH_MASK)
        {
            var p = parts[hash & partHashMask];
            if (p != null)
                return p.TryFind(hash, key, out value);
            value = default(V);
            return false;
        }

        /// <summary>Lookup for the value by the key using its hash code and checking the key with the `object.Equals` for equality,
        /// returns the `true` and the found value or the `false`</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<K, V>(this ImHashMap<K, V>[] parts, K key, out V value, int partHashMask = PARTITION_HASH_MASK) =>
            parts.TryFind(key.GetHashCode(), key, out value, partHashMask);

        /// <summary>Lookup for the value by the key using the hash code and checking the key with the `object.ReferenceEquals` for equality,
        /// returns the `true` and the found value or the `false`</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFindByReferenceEquals<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, out V value,
            int partHashMask = PARTITION_HASH_MASK) where K : class
        {
            var p = parts[hash & partHashMask];
            if (p != null)
                return p.TryFindByReferenceEquals(hash, key, out value);
            value = default(V);
            return false;
        }

        /// <summary>Lookup for the value by the key using its hash and checking the key with the `object.ReferenceEquals` for equality, 
        /// returns the default `V` if hash, key are not found.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefaultByReferenceEquals<K, V>(this ImHashMap<K, V>[] parts, K key, int partHashMask = PARTITION_HASH_MASK) where K : class =>
            parts.GetValueOrDefaultByReferenceEquals(key.GetHashCode(), key, partHashMask);

        /// <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, V value, int partHashMask = PARTITION_HASH_MASK)
        {
            ref var part = ref parts[hash & partHashMask];
            var p = part;
            if (Interlocked.CompareExchange(ref part, p.AddOrUpdate(hash, key, value), p) != p)
                RefAddOrUpdatePart(ref part, hash, key, value);
        }

        /// <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] parts, K key, V value, int partHashMask = PARTITION_HASH_MASK) =>
            parts.AddOrUpdate(key.GetHashCode(), key, value, partHashMask);

        private static void RefAddOrUpdatePart<K, V>(ref ImHashMap<K, V> part, int hash, K key, V value) =>
            Ref.Swap(ref part, hash, key, value, (x, h, k, v) => x.AddOrUpdate(h, k, v));

        /// <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, V value, Update<K, V> update,
            int partHashMask = PARTITION_HASH_MASK)
        {
            ref var part = ref parts[hash & partHashMask];
            var p = part;
            if (Interlocked.CompareExchange(ref part, p.AddOrUpdate(hash, key, value, update), p) != p)
                Ref.Swap(ref part, new ImHashMapEntry<K, V>(hash, key, value), update, (x, e, u) => x.AddOrUpdate(e.Hash, e.Key, e.Value, u));
        }

        /// <summary>Returns the SAME partitioned maps array instance but with the NEW added or the same kept partion</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrKeep<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, V value, int partHashMask = PARTITION_HASH_MASK)
        {
            ref var part = ref parts[hash & partHashMask];
            var p = part;
            if (Interlocked.CompareExchange(ref part, p.AddOrKeep(hash, key, value), p) != p)
                RefAddOrKeepPart(ref part, hash, key, value);
        }

        /// <summary>Returns the SAME partitioned maps array instance but with the NEW added or the same kept partion</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrKeep<K, V>(this ImHashMap<K, V>[] parts, K key, V value,
            int partHashMask = PARTITION_HASH_MASK) =>
            parts.AddOrKeep(key.GetHashCode(), key, value, partHashMask);

        private static void RefAddOrKeepPart<K, V>(ref ImHashMap<K, V> part, int hash, K key, V value) =>
            Ref.Swap(ref part, hash, key, value, (x, h, k, v) => x.AddOrUpdate(h, k, v));

        /// <summary>Do something for each entry.
        /// The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static IEnumerable<ImHashMapEntry<K, V>> Enumerate<K, V>(this ImHashMap<K, V>[] parts, MapParentStack parents = null)
        {
            if (parents == null)
                parents = new MapParentStack();
            foreach (var map in parts)
            {
                if (map == ImHashMap<K, V>.Empty)
                    continue;
                foreach (var entry in map.Enumerate(parents))
                    yield return entry;
            }
        }

        /// <summary>Do something for each entry.
        /// The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        public static S ForEach<K, V, S>(this ImHashMap<K, V>[] parts, S state, Action<ImHashMapEntry<K, V>, int, S> handler,
            MapParentStack parents = null)
        {
            if (parents == null)
                parents = new MapParentStack();
            foreach (var map in parts)
            {
                if (map == ImHashMap<K, V>.Empty)
                    continue;
                state = map.ForEach(state, handler, parents);
            }
            return state;
        }
    }
}