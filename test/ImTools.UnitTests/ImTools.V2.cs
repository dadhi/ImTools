// <auto-generated/>
/*
The MIT License (MIT)

Copyright (c) 2016-2021 Maksim Volkau

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// ReSharper disable once InconsistentNaming

namespace ImTools.V2
{
    using System;
    using System.Collections.Generic;
    using System.Threading;
    using System.Runtime.CompilerServices; // For [MethodImpl(AggressiveInlining)]\

    /// <summary>Immutable http://en.wikipedia.org/wiki/AVL_tree with integer keys and <typeparamref name="V"/> values.</summary>
    public sealed class ImMap<V>
    {
        /// <summary>Empty tree to start with.</summary>
        public static readonly ImMap<V> Empty = new ImMap<V>();

        /// <summary>Key.</summary>
        public int Key;

        /// <summary>Value.</summary>
        public V Value;

        /// <summary>Left sub-tree/branch, or empty.</summary>
        public ImMap<V> Left;

        /// <summary>Right sub-tree/branch, or empty.</summary>
        public ImMap<V> Right;

        /// <summary>Height of the longest sub-tree/branch. It is 0 for empty tree, and 1 for single node tree.</summary>
        public int Height;

        /// <summary>Returns true if tree is empty.</summary>
        public bool IsEmpty => Height == 0;

        /// Adds or updates the value by key in the map, always returns a modified map
        [MethodImpl((MethodImplOptions)256)]
        public ImMap<V> AddOrUpdate(int key, V value) =>
            Height == 0
                ? new ImMap<V>(key, value)
                : key == Key
                    ? new ImMap<V>(key, value, Left, Right, Height)
                    : AddOrUpdateLeftOrRight(key, value);

        private ImMap<V> AddOrUpdateLeftOrRight(int key, V value)
        {
            if (key < Key)
            {
                if (Left.Height == 0)
                    return new ImMap<V>(Key, Value, new ImMap<V>(key, value), Right, 2);

                var left = Left;
                if (left.Key == key)
                    return new ImMap<V>(Key, Value, new ImMap<V>(key, value, left.Left, left.Right, left.Height), Right,
                        Height);

                if (Right.Height == 0)
                    return key < left.Key
                        ? new ImMap<V>(left.Key, left.Value, new ImMap<V>(key, value), new ImMap<V>(Key, Value), 2)
                        : new ImMap<V>(key, value, new ImMap<V>(left.Key, left.Value), new ImMap<V>(Key, Value), 2);

                var newLeft = left.AddOrUpdateLeftOrRight(key, value);
                if (newLeft.Height > Right.Height + 1) // left is longer by 2, rotate left
                {
                    var leftLeft = newLeft.Left;
                    var leftRight = newLeft.Right;

                    if (leftLeft.Height >= leftRight.Height)
                        return new ImMap<V>(newLeft.Key, newLeft.Value,
                            leftLeft,
                            new ImMap<V>(Key, Value, leftRight, Right));

                    return new ImMap<V>(leftRight.Key, leftRight.Value,
                        new ImMap<V>(newLeft.Key, newLeft.Value, leftLeft, leftRight.Left),
                        new ImMap<V>(Key, Value, leftRight.Right, Right));
                }

                return new ImMap<V>(Key, Value, newLeft, Right);
            }
            else
            {
                if (Right.Height == 0)
                    return new ImMap<V>(Key, Value, Left, new ImMap<V>(key, value), 2);

                var right = Right;
                if (right.Key == key)
                    return new ImMap<V>(Key, Value, Left,
                        new ImMap<V>(key, value, right.Left, right.Right, right.Height), Height);

                if (Left.Height == 0)
                    return key >= right.Key
                        ? new ImMap<V>(right.Key, right.Value, new ImMap<V>(Key, Value), new ImMap<V>(key, value), 2)
                        : new ImMap<V>(key, value, new ImMap<V>(Key, Value), new ImMap<V>(right.Key, right.Value), 2);

                var newRight = right.AddOrUpdateLeftOrRight(key, value);
                if (newRight.Height > Left.Height + 1)
                {
                    var rightLeft = newRight.Left;
                    var rightRight = newRight.Right;

                    if (rightRight.Height >= rightLeft.Height)
                        return new ImMap<V>(newRight.Key, newRight.Value,
                            new ImMap<V>(Key, Value, Left, rightLeft),
                            rightRight);

                    return new ImMap<V>(rightLeft.Key, rightLeft.Value,
                        new ImMap<V>(Key, Value, Left, rightLeft.Left),
                        new ImMap<V>(newRight.Key, newRight.Value, rightLeft.Right, rightRight));
                }

                return new ImMap<V>(Key, Value, Left, newRight);
            }
        }

        /// Returns a new map with added value for the specified key or the existing map if the key is already in the map.
        [MethodImpl((MethodImplOptions)256)]
        public ImMap<V> AddOrKeep(int key, V value) =>
            Height == 0
                ? new ImMap<V>(key, value)
                : key == Key
                    ? this
                    : AddOrKeepLeftOrRight(key, value);

        private ImMap<V> AddOrKeepLeftOrRight(int key, V value)
        {
            if (key < Key)
            {
                if (Left.Height == 0)
                    return new ImMap<V>(Key, Value, new ImMap<V>(key, value), Right, 2);

                if (Left.Key == key)
                    return this;

                if (Right.Height == 0)
                    return key < Left.Key
                        ? new ImMap<V>(Left.Key, Left.Value, new ImMap<V>(key, value), new ImMap<V>(Key, Value), 2)
                        : new ImMap<V>(key, value, new ImMap<V>(Left.Key, Left.Value), new ImMap<V>(Key, Value), 2);

                var newLeft = Left.AddOrKeepLeftOrRight(key, value);
                if (ReferenceEquals(newLeft, Left))
                    return this;

                if (newLeft.Height > Right.Height + 1) // left is longer by 2, rotate left
                {
                    var leftLeft = newLeft.Left;
                    var leftRight = newLeft.Right;

                    if (leftLeft.Height >= leftRight.Height)
                        return new ImMap<V>(newLeft.Key, newLeft.Value,
                            leftLeft, new ImMap<V>(Key, Value, leftRight, Right));

                    return new ImMap<V>(leftRight.Key, leftRight.Value,
                        new ImMap<V>(newLeft.Key, newLeft.Value, leftLeft, leftRight.Left),
                        new ImMap<V>(Key, Value, leftRight.Right, Right));
                }

                return new ImMap<V>(Key, Value, newLeft, Right);
            }
            else
            {
                if (Right.Height == 0)
                    return new ImMap<V>(Key, Value, Left, new ImMap<V>(key, value), 2);

                if (Right.Key == key)
                    return this;

                if (Left.Height == 0)
                    return key >= Right.Key
                        ? new ImMap<V>(Right.Key, Right.Value, new ImMap<V>(Key, Value), new ImMap<V>(key, value), 2)
                        : new ImMap<V>(key, value, new ImMap<V>(Key, Value), new ImMap<V>(Right.Key, Right.Value), 2);

                var newRight = Right.AddOrKeepLeftOrRight(key, value);
                if (ReferenceEquals(newRight, Right))
                    return this;

                if (newRight.Height > Left.Height + 1)
                {
                    var rightLeft = newRight.Left;
                    var rightRight = newRight.Right;

                    if (rightRight.Height >= rightLeft.Height)
                        return new ImMap<V>(newRight.Key, newRight.Value,
                            new ImMap<V>(Key, Value, Left, rightLeft), rightRight);

                    return new ImMap<V>(rightLeft.Key, rightLeft.Value,
                        new ImMap<V>(Key, Value, Left, rightLeft.Left),
                        new ImMap<V>(newRight.Key, newRight.Value, rightLeft.Right, rightRight));
                }

                return new ImMap<V>(Key, Value, Left, newRight);
            }
        }

        /// Returns the new map with added or updated value for the specified key.
        [MethodImpl((MethodImplOptions)256)]
        public ImMap<V> AddOrUpdate(int key, V value, Update<int, V> updateValue) =>
            Height == 0
            ? new ImMap<V>(key, value)
            : key == Key
                ? new ImMap<V>(key, updateValue(key, Value, value), Left, Right, Height)
                : AddOrUpdateLeftOrRightWithUpdate(key, value, updateValue);

        private ImMap<V> AddOrUpdateLeftOrRightWithUpdate(int key, V value, Update<int, V> updateValue)
        {
            if (key < Key)
            {
                if (Left.Height == 0)
                    return new ImMap<V>(Key, Value, new ImMap<V>(key, value), Right, 2);

                if (Left.Key == key)
                {
                    var left = Left;
                    return new ImMap<V>(Key, Value,
                        new ImMap<V>(key, updateValue(key, left.Value, value), left.Left, left.Right, left.Height),
                        Right, Height);
                }

                if (Right.Height == 0)
                    return key < Left.Key
                        ? new ImMap<V>(Left.Key, Left.Value, new ImMap<V>(key, value), new ImMap<V>(Key, Value), 2)
                        : new ImMap<V>(key, value, new ImMap<V>(Left.Key, Left.Value), new ImMap<V>(Key, Value), 2);

                var newLeft = Left.AddOrUpdateLeftOrRightWithUpdate(key, value, updateValue);

                if (newLeft.Height > Right.Height + 1) // left is longer by 2, rotate left
                {
                    var leftLeft = newLeft.Left;
                    var leftRight = newLeft.Right;

                    if (leftLeft.Height >= leftRight.Height)
                        return new ImMap<V>(newLeft.Key, newLeft.Value,
                            leftLeft, new ImMap<V>(Key, Value, leftRight, Right));

                    return new ImMap<V>(leftRight.Key, leftRight.Value,
                        new ImMap<V>(newLeft.Key, newLeft.Value, leftLeft, leftRight.Left),
                        new ImMap<V>(Key, Value, leftRight.Right, Right));
                }

                return new ImMap<V>(Key, Value, newLeft, Right);
            }
            else
            {
                if (Right.Height == 0)
                    return new ImMap<V>(Key, Value, Left, new ImMap<V>(key, value), 2);

                if (Right.Key == key)
                {
                    var right = Right;
                    return new ImMap<V>(Key, Value, Left,
                        new ImMap<V>(key, updateValue(key, right.Value, value), right.Left, right.Right, right.Height), 
                        Height);
                }

                if (Left.Height == 0)
                    return key >= Right.Key
                        ? new ImMap<V>(Right.Key, Right.Value, new ImMap<V>(Key, Value), new ImMap<V>(key, value), 2)
                        : new ImMap<V>(key, value, new ImMap<V>(Key, Value), new ImMap<V>(Right.Key, Right.Value), 2);

                var newRight = Right.AddOrUpdateLeftOrRightWithUpdate(key, value, updateValue);

                if (newRight.Height > Left.Height + 1)
                {
                    var rightLeft = newRight.Left;
                    var rightRight = newRight.Right;

                    if (rightRight.Height >= rightLeft.Height)
                        return new ImMap<V>(newRight.Key, newRight.Value,
                            new ImMap<V>(Key, Value, Left, rightLeft), rightRight);

                    return new ImMap<V>(rightLeft.Key, rightLeft.Value,
                        new ImMap<V>(Key, Value, Left, rightLeft.Left),
                        new ImMap<V>(newRight.Key, newRight.Value, rightLeft.Right, rightRight));
                }

                return new ImMap<V>(Key, Value, Left, newRight);
            }
        }

        ///<summary>Returns the new map with the updated value for the key, or the same map if the key was not found.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public ImMap<V> Update(int key, V value) => 
            this.TryFind(key, out _) ? UpdateImpl(key, value) : this;

        internal ImMap<V> UpdateImpl(int key, V value) =>
            key < Key ? new ImMap<V>(Key, Value, Left.UpdateImpl(key, value), Right, Height)
          : key > Key ? new ImMap<V>(Key, Value, Left, Right.UpdateImpl(key, value), Height)
          : new ImMap<V>(key, value, Left, Right, Height);

        /// <summary>
        /// Returns all map tree nodes enumerated from the lesser to the bigger keys
        /// </summary>
        public IEnumerable<ImMap<V>> Enumerate(ImMap<V>[] parentStack = null)
        {
            if (Height == 0)
                yield break;

            if (Height == 1)
            {
                yield return this;
            }
            else if (Height == 2)
            {
                if (Left.Height != 0)
                    yield return Left;
                yield return this;
                if (Right.Height != 0)
                    yield return Right;
            }
            else
            {
                parentStack = parentStack ?? new ImMap<V>[Height - 2];
                var map = this;
                var parentIndex = -1;
                while (map.Height != 0)
                {
                    if (map.Height == 1)
                    {
                        yield return map;
                        if (parentIndex == -1)
                            break;
                        yield return map = parentStack[parentIndex--];
                        map = map.Right;
                    }
                    else if (map.Height == 2)
                    {
                        if (map.Left.Height != 0)
                            yield return map.Left;
                        yield return map;
                        if (map.Right.Height != 0)
                            yield return map.Right;
                        if (parentIndex == -1)
                            break;
                        yield return map = parentStack[parentIndex--];
                        map = map.Right;
                    }
                    else
                    {
                        parentStack[++parentIndex] = map;
                        map = map.Left;
                    }
                }
            }
        }

        // todo: add `FindFirst`
        /// <summary>
        /// Folds all the map nodes with the state from left to right and from the bottom to top
        /// You may pass `parentStacks` to reuse the array memory.
        /// NOTE: the length of `parentStack` should be at least of map height, content is not important and could be erased.
        /// </summary>
        public S Fold<S>(S state, Func<ImMap<V>, S, S> reduce, ImMap<V>[] parentStack = null)
        {
            if (Height == 0)
                return state;

            if (Height == 1)
                return reduce(this, state);

            if (Height == 2) 
                return this.ReduceTwoLevelTree(state, reduce);

            parentStack = parentStack ?? new ImMap<V>[Height - 2];
            var map = this;
            var parentIndex = -1;
            do
            {
                if (map.Height == 1)
                {
                    state = reduce(map, state);
                    if (parentIndex == -1)
                        break;
                    state = reduce(map = parentStack[parentIndex--], state);
                    map = map.Right;
                }
                else if (map.Height == 2)
                {
                    state = map.ReduceTwoLevelTree(state, reduce);
                    if (parentIndex == -1)
                        break;
                    state = reduce(map = parentStack[parentIndex--], state);
                    map = map.Right;
                }
                else
                {
                    parentStack[++parentIndex] = map;
                    map = map.Left;
                }
            } while (map.Height != 0);

            return state;
        }

        /// <summary>
        /// Folds all the map nodes with the state from left to right and from the bottom to top
        /// You may pass `parentStacks` to reuse the array memory.
        /// NOTE: the length of `parentStack` should be at least of map height, content is not important and could be erased.
        /// </summary>
        public S Fold<S, R>(S state, R reducer, ImMap<V>[] parentStack = null) where R : struct, IFoldReducer<ImMap<V>, S>
        {
            if (Height == 0)
                return state;

            if (Height == 1)
                return reducer.Reduce(this, state);

            if (Height == 2)
                return this.ReduceTwoLevelTree(state, reducer);

            parentStack = parentStack ?? new ImMap<V>[Height - 2];
            var map = this;
            var parentIndex = -1;
            do
            {
                if (map.Height == 1)
                {
                    state = reducer.Reduce(map, state);
                    if (parentIndex == -1)
                        break;
                    state = reducer.Reduce(map = parentStack[parentIndex--], state);
                    map = map.Right;
                }
                else if (map.Height == 2)
                {
                    state = map.ReduceTwoLevelTree(state, reducer);
                    if (parentIndex == -1)
                        break;
                    state = reducer.Reduce(map = parentStack[parentIndex--], state);
                    map = map.Right;
                }
                else
                {
                    parentStack[++parentIndex] = map;
                    map = map.Left;
                }
            } while (map.Height != 0);

            return state;
        }


        /// <summary>
        /// Folds all the map nodes with the state and index from left to right and from bottom to top
        /// You may pass `parentStacks` to reuse the array memory.
        /// NOTE: the length of `parentStack` should be at least of map height, content is not important and could be erased.
        /// </summary>
        public S Fold<S>(S state, Func<ImMap<V>, int, S, S> reduce, ImMap<V>[] parentStack = null)
        {
            if (Height == 0)
                return state;

            if (Height == 1)
                return reduce(this, 0, state);

            if (Height == 2)
            {
                if (Left.Height != 0)
                    state = reduce(Left, 0, state);
                state = reduce(this, 1, state);
                if (Right.Height != 0)
                    state = reduce(Right, 2, state);
                return state;
            }

            parentStack = parentStack ?? new ImMap<V>[Height - 2];
            var map = this;
            var parentIndex = -1;
            var index = 0;
            do
            {
                if (map.Height == 1)
                {
                    state = reduce(map, index++, state);
                    if (parentIndex == -1)
                        break;
                    state = reduce(map = parentStack[parentIndex--], index++, state);
                    map = map.Right;
                }
                else if (map.Height == 2)
                {
                    if (map.Left.Height != 0)
                        state = reduce(Left, index++, state);
                    state = reduce(map, index++, state);
                    if (Right.Height != 0)
                        state = reduce(map.Right, index++, state);
                    if (parentIndex == -1)
                        break;
                    state = reduce(map = parentStack[parentIndex--], index++, state);
                    map = map.Right;
                }
                else
                {
                    parentStack[++parentIndex] = map;
                    map = map.Left;
                }
            } while (map.Height != 0);

            return state;
        }

        /// <summary>Removes or updates value for specified key, or does nothing if key is not found.
        /// Based on Eric Lippert http://blogs.msdn.com/b/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx </summary>
        /// <param name="key">Key to look for.</param> 
        /// <returns>New tree with removed or updated value.</returns>
        [MethodImpl((MethodImplOptions)256)]
        public ImMap<V> Remove(int key)
        {
            if (Height == 0)
                return this;

            if (key == Key) // we've found the node to remove
            {
                if (Height == 1) // remove the leaf node
                    return Empty;

                // if we have the on child remaining then just return it
                if (Right.Height == 0)
                    return Left;

                if (Left.Height == 0)
                    return Right;

                // we have two children,
                // so remove the next highest node and replace this node with it.
                var successor = Right;
                while (successor.Left.Height != 0)
                    successor = successor.Left;
                return new ImMap<V>(successor.Key, successor.Value,
                    Left, Right.Remove(successor.Key));
            }

            // remove the node and balance the new tree
            return key < Key
                ? Balance(Key, Value, Left.Remove(key), Right)
                : Balance(Key, Value, Left, Right.Remove(key));
        }

        /// <summary>Outputs key value pair</summary>
        public override string ToString() => IsEmpty ? "empty" : Key + ":" + Value;

        internal ImMap() { }

        internal ImMap(int key, V value)
        {
            Key = key;
            Value = value;
            Left = Empty;
            Right = Empty;
            Height = 1;
        }

        internal ImMap(int key, V value, ImMap<V> left, ImMap<V> right, int height)
        {
            Key = key;
            Value = value;
            Left = left;
            Right = right;
            Height = height;
        }

        internal ImMap(int key, V value, ImMap<V> left, ImMap<V> right)
        {
            Key = key;
            Value = value;
            Left = left;
            Right = right;
            Height = left.Height > right.Height ? left.Height + 1 : right.Height + 1;
        }

        internal static ImMap<V> Balance(int key, V value, ImMap<V> left, ImMap<V> right)
        {
            var delta = left.Height - right.Height;
            if (delta > 1) // left is longer by 2, rotate left
            {
                var leftLeft = left.Left;
                var leftRight = left.Right;
                if (leftRight.Height > leftLeft.Height)
                {
                    // double rotation:
                    //      5     =>     5     =>     4
                    //   2     6      4     6      2     5
                    // 1   4        2   3        1   3     6
                    //    3        1
                    return new ImMap<V>(leftRight.Key, leftRight.Value,
                        new ImMap<V>(left.Key, left.Value, leftLeft, leftRight.Left),
                        new ImMap<V>(key, value, leftRight.Right, right));
                }

                // single rotation:
                //      5     =>     2
                //   2     6      1     5
                // 1   4              4   6
                return new ImMap<V>(left.Key, left.Value,
                    leftLeft,
                    new ImMap<V>(key, value, leftRight, right));
            }

            if (delta < -1)
            {
                var rightLeft = right.Left;
                var rightRight = right.Right;
                if (rightLeft.Height > rightRight.Height)
                {
                    return new ImMap<V>(rightLeft.Key, rightLeft.Value,
                        new ImMap<V>(key, value, left, rightLeft.Left),
                        new ImMap<V>(right.Key, right.Value, rightLeft.Right, rightRight));
                }

                return new ImMap<V>(right.Key, right.Value,
                    new ImMap<V>(key, value, left, rightLeft),
                    rightRight);
            }

            return new ImMap<V>(key, value, left, right);
        }
    }

    /// ImMap static methods
    public static class ImMap
    {
        internal static V IgnoreKey<K, V>(this Update<V> update, K _, V oldValue, V newValue) => update(oldValue, newValue);

        /// Get value for found key or the default value otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<V>(this ImMap<V> map, int key)
        {
            while (map.Height != 0 && map.Key != key)
                map = key < map.Key ? map.Left : map.Right;
            return map.Value; // that's fine to return the value without check, because for we have a default value in empty map
        }

        /// Get value for found key or the specified default value otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<V>(this ImMap<V> map, int key, V defaultValue)
        {
            while (map.Height != 0 && map.Key != key)
                map = key < map.Key ? map.Left : map.Right;
            return map.Height != 0 ? map.Value : defaultValue;
        }

        /// Returns true if key is found and sets the value.
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<V>(this ImMap<V> map, int key, out V value)
        {
            while (map.Height != 0)
            {
                if (key < map.Key)
                    map = map.Left;
                else if (key > map.Key)
                    map = map.Right;
                else
                    break;
            }

            value = map.Value;
            return map.Height != 0;
        }

        [MethodImpl((MethodImplOptions)256)]
        internal static S ReduceTwoLevelTree<V, S>(this ImMap<V> map, S state, Func<ImMap<V>, S, S> reduce)
        {
            if (map.Left.Height != 0)
                state = reduce(map.Left, state);
            state = reduce(map, state);
            if (map.Right.Height != 0)
                state = reduce(map.Right, state);
            return state;
        }

        [MethodImpl((MethodImplOptions)256)]
        internal static S ReduceTwoLevelTree<V, S, R>(this ImMap<V> map, S state, R reducer) where R : struct, IFoldReducer<ImMap<V>, S>
        {
            if (map.Left.Height != 0)
                state = reducer.Reduce(map.Left, state);
            state = reducer.Reduce(map, state);
            if (map.Right.Height != 0)
                state = reducer.Reduce(map.Right, state);
            return state;
        }
    }

    /// <summary>
    /// The array of ImMap slots where the key first bits are used for FAST slot location
    /// and the slot is the reference to ImMap that can be swapped with its updated value
    /// </summary>
    public static class ImMapSlots
    {
        /// Default number of slots
        public const int SLOT_COUNT_POWER_OF_TWO = 32;

        /// The default mask to partition the key to the target slot
        public const int KEY_MASK_TO_FIND_SLOT = SLOT_COUNT_POWER_OF_TWO - 1;

        /// Creates the array with the empty slots
        [MethodImpl((MethodImplOptions)256)]
        public static ImMap<V>[] CreateWithEmpty<V>(int slotCountPowerOfTwo = SLOT_COUNT_POWER_OF_TWO)
        {
            var slots = new ImMap<V>[slotCountPowerOfTwo];
            for (var i = 0; i < slots.Length; ++i)
                slots[i] = ImMap<V>.Empty;
            return slots;
        }

        /// Returns a new tree with added or updated value for specified key.
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrUpdate<V>(this ImMap<V>[] slots, int key, V value, int keyMaskToFindSlot = KEY_MASK_TO_FIND_SLOT)
        {
            ref var slot = ref slots[key & keyMaskToFindSlot];
            var copy = slot;
            if (Interlocked.CompareExchange(ref slot, copy.AddOrUpdate(key, value), copy) != copy)
                RefAddOrUpdateSlot(ref slot, key, value);
        }

        /// Update the ref to the slot with the new version - retry if the someone changed the slot in between
        public static void RefAddOrUpdateSlot<V>(ref ImMap<V> slot, int key, V value) =>
            Ref.Swap(ref slot, key, value, (x, k, v) => x.AddOrUpdate(k, v));

        /// Updates the value with help of `updateValue` function
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrUpdate<V>(this ImMap<V>[] slots, int key, V value, Update<int, V> updateValue, int keyMaskToFindSlot = KEY_MASK_TO_FIND_SLOT)
        {
            ref var slot = ref slots[key & keyMaskToFindSlot];
            var copy = slot;
            if (Interlocked.CompareExchange(ref slot, copy.AddOrUpdate(key, value, updateValue), copy) != copy)
                RefAddOrUpdateSlot(ref slot, key, value, updateValue);
        }

        /// Update the ref to the slot with the new version - retry if the someone changed the slot in between
        public static void RefAddOrUpdateSlot<V>(ref ImMap<V> slot, int key, V value, Update<int, V> updateValue) =>
            Ref.Swap(ref slot, key, value, updateValue, (s, k, v, u) => s.AddOrUpdate(k, v, u));

        /// Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrKeep<V>(this ImMap<V>[] slots, int key, V value, int keyMaskToFindSlot = KEY_MASK_TO_FIND_SLOT)
        {
            ref var slot = ref slots[key & keyMaskToFindSlot];
            var copy = slot;
            if (Interlocked.CompareExchange(ref slot, copy.AddOrKeep(key, value), copy) != copy)
                RefAddOrKeepSlot(ref slot, key, value);
        }

        /// Update the ref to the slot with the new version - retry if the someone changed the slot in between
        public static void RefAddOrKeepSlot<V>(ref ImMap<V> slot, int key, V value) =>
            Ref.Swap(ref slot, key, value, (s, k, v) => s.AddOrKeep(k, v));

        /// Updates the specified slot or does not change it
        [MethodImpl((MethodImplOptions)256)]
        public static void Update<V>(this ImMap<V>[] slots, int key, V value, int keyMaskToFindSlot = KEY_MASK_TO_FIND_SLOT)
        {
            ref var slot = ref slots[key & keyMaskToFindSlot];
            var copy = slot;
            if (Interlocked.CompareExchange(ref slot, copy.Update(key, value), copy) != copy)
                RefUpdateSlot(ref slot, key, value);
        }

        /// Update the ref to the slot with the new version - retry if the someone changed the slot in between
        public static void RefUpdateSlot<V>(ref ImMap<V> slot, int key, V value) =>
            Ref.Swap(ref slot, key, value, (s, k, v) => s.Update(k, v));

        /// <summary> Folds all map tree nodes without the order </summary>
        public static S Fold<V, S>(this ImMap<V>[] slots, S state, Func<ImMap<V>, S, S> reduce)
        {
            var parentStack = ArrayTools.Empty<ImMap<V>>();
            for (var i = 0; i < slots.Length; i++)
            {
                var map = slots[i];
                var height = map.Height;
                if (height == 0)
                    continue;
                if (height == 1)
                    state = reduce(map, state);
                else if (height == 2)
                    state = map.ReduceTwoLevelTree(state, reduce);
                else
                {
                    if (parentStack.Length < height - 2)
                        parentStack = new ImMap<V>[height - 2];
                    var parentIndex = -1;
                    do
                    {
                        if (map.Height == 1)
                        {
                            state = reduce(map, state);
                            if (parentIndex == -1)
                                break;
                            state = reduce(map = parentStack[parentIndex--], state);
                            map = map.Right;
                        }
                        else if (map.Height == 2)
                        {
                            state = map.ReduceTwoLevelTree(state, reduce);
                            if (parentIndex == -1)
                                break;
                            state = reduce(map = parentStack[parentIndex--], state);
                            map = map.Right;
                        }
                        else
                        {
                            parentStack[++parentIndex] = map;
                            map = map.Left;
                        }
                    } while (map.Height != 0);
                }
            }

            return state;
        }
    }

    /// <summary>Wraps the stored data with "fixed" reference semantics - when added to the tree it did not change or reconstructed in memory</summary>
    public class ImHashMapEntry<K, V>
    {
        /// Empty thingy
        public static readonly ImHashMapEntry<K, V> Empty = new ImHashMapEntry<K, V>();

        /// Key hash
        public readonly int Hash;

        ///  The key
        public readonly K Key;

        /// The value - may be mutated implementing the Ref CAS semantics if needed
        public V Value;

        private ImHashMapEntry() { }

        /// Constructs the data
        public ImHashMapEntry(int hash, K key, V value)
        {
            Hash = hash;
            Key = key;
            Value = value;
        }

        /// Constructs the data with the default value
        public ImHashMapEntry(int hash, K key)
        {
            Hash = hash;
            Key = key;
        }

        /// <summary>Outputs the brief tree info - mostly for debugging purposes</summary>
        public override string ToString() => Key + ": " + Value;
    }

    /// Stores ALL the data in `Conflicts` array, the fields except the `hash` are just fillers.
    /// This way we preserve the once created `ImHashMapData` so that client can hold the reference to it and update the Value if needed.
    public sealed class ImHashMapConflicts<K, V> : ImHashMapEntry<K, V>
    {
        /// Conflicted data
        public readonly ImHashMapEntry<K, V>[] Conflicts;

        /// <inheritdoc />
        public ImHashMapConflicts(int hash, params ImHashMapEntry<K, V>[] conflicts) : base(hash, default, default) => 
            Conflicts = conflicts;
    }

    /// Immutable http://en.wikipedia.org/wiki/AVL_tree 
    /// where node key is the hash code of <typeparamref name="K"/>
    public sealed class ImHashMap<K, V>
    {
        /// Empty map to start with.
        public static readonly ImHashMap<K, V> Empty = new ImHashMap<K, V>();

        /// <summary>Calculated key hash.</summary>
        public int Hash
        {
            [MethodImpl((MethodImplOptions)256)]
            get => Entry.Hash;
        }

        /// <summary>Key of type K that should support <see cref="object.Equals(object)"/> and <see cref="object.GetHashCode"/>.</summary>
        public K Key
        {
            [MethodImpl((MethodImplOptions)256)]
            get => Entry.Key;
        }

        /// <summary>Value of any type V.</summary>
        public V Value
        {
            [MethodImpl((MethodImplOptions)256)]
            get => Entry.Value;
        }

        /// <summary>In case of <see cref="Hash"/> conflicts for different keys contains conflicted keys with their values.</summary>
        public ImHashMapEntry<K, V>[] Conflicts
        {
            [MethodImpl((MethodImplOptions)256)]
            get => (Entry as ImHashMapConflicts<K, V>)?.Conflicts;
        }

        /// <summary>Left sub-tree/branch, or empty.</summary>
        public ImHashMap<K, V> Left;

        /// <summary>Right sub-tree/branch, or empty.</summary>
        public ImHashMap<K, V> Right;

        /// <summary>Height of longest sub-tree/branch plus 1. It is 0 for empty tree, and 1 for single node tree.</summary>
        public int Height;

        /// <summary>Returns true if tree is empty.</summary>
        public bool IsEmpty => Height == 0;

        /// <summary>The entry which is allocated once and can be used as a "fixed" reference to the Key and Value</summary>
        public readonly ImHashMapEntry<K, V> Entry;

        internal ImHashMap() => Entry = ImHashMapEntry<K, V>.Empty;

        /// Creates  leaf node
        public ImHashMap(int hash, K key, V value)
        {
            Entry = new ImHashMapEntry<K, V>(hash, key, value);
            Left  = Empty;
            Right = Empty;
            Height = 1;
        }

        /// Creates a leaf node with default value
        public ImHashMap(int hash, K key)
        {
            Entry = new ImHashMapEntry<K, V>(hash, key);
            Left  = Empty;
            Right = Empty;
            Height = 1;
        }

        /// Creates a leaf node
        public ImHashMap(ImHashMapEntry<K, V> entry)
        {
            Entry = entry;
            Left  = Empty;
            Right = Empty;
            Height = 1;
        }

        /// Creates the tree and calculates the height for you
        public ImHashMap(ImHashMapEntry<K, V> entry, ImHashMap<K, V> left, ImHashMap<K, V> right)
        {
            Entry = entry;
            Left = left;
            Right = right;
            Height = 1 + (left.Height > right.Height ? left.Height : right.Height);
        }

        /// Creates the tree with the known height
        public ImHashMap(ImHashMapEntry<K, V> entry, ImHashMap<K, V> left, ImHashMap<K, V> right, int height)
        {
            Entry = entry;
            Left = left;
            Right = right;
            Height = height;
        }

        /// <summary>Outputs the brief tree info - mostly for debugging purposes</summary>
        public override string ToString() => Height == 0 ? "empty" 
            : "(" + Entry
            + ") -> (" + (Left.Height  == 0 ? "empty" : Left.Entry  + " of height " + Left.Height)
            + ", "     + (Right.Height == 0 ? "empty" : Right.Entry + " of height " + Right.Height)
            + ")";

        /// <summary>Uses the user provided hash and adds and updates the tree with passed key-value. Returns a new tree.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrUpdate(int hash, K key, V value) =>
            Height == 0 ? new ImHashMap<K, V>(hash, key, value)
            : hash == Hash ? UpdateValueOrAddOrUpdateConflict(hash, key, value)
            : AddOrUpdateLeftOrRight(hash, key, value);

        /// Adds and updates the tree with passed key-value. Returns a new tree.
        [MethodImpl((MethodImplOptions) 256)]
        public ImHashMap<K, V> AddOrUpdate(K key, V value) => 
            AddOrUpdate(key.GetHashCode(), key, value);

        private ImHashMap<K, V> UpdateValueOrAddOrUpdateConflict(int hash, K key, V value)
        {
            var conflictsData = Entry as ImHashMapConflicts<K, V>;
            return conflictsData == null && (ReferenceEquals(key, Key) || key.Equals(Key))
                ? new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key, value), Left, Right, Height)
                : AddOrUpdateConflict(conflictsData, hash, key, value);
        }

        internal enum DoAddOrUpdateConflicts { AddOrUpdate, AddOrKeep, Update }

        private ImHashMap<K, V> AddOrUpdateConflict(ImHashMapConflicts<K, V> conflictsData, int hash, K key, V value, 
            Update<K, V> update = null, DoAddOrUpdateConflicts doWhat = DoAddOrUpdateConflicts.AddOrUpdate)
        {
            if (conflictsData == null)
                return doWhat == DoAddOrUpdateConflicts.Update 
                    ? this
                    : new ImHashMap<K, V>(
                        new ImHashMapConflicts<K, V>(hash, Entry, new ImHashMapEntry<K, V>(hash, key, value)),
                        Left, Right, Height);

            var conflicts = conflictsData.Conflicts;
            var conflictCount = conflicts.Length;
            var conflictIndex = conflictCount - 1;
            while (conflictIndex != -1 && !key.Equals(conflicts[conflictIndex].Key))
                --conflictIndex;

            ImHashMapEntry<K, V>[] newConflicts;
            if (conflictIndex != -1)
            {
                if (doWhat == DoAddOrUpdateConflicts.AddOrKeep)
                    return this;

                // update the existing conflicted value
                newConflicts = new ImHashMapEntry<K, V>[conflictCount];
                Array.Copy(conflicts, 0, newConflicts, 0, conflictCount);
                var newValue = update == null ? value : update(key, conflicts[conflictIndex].Value, value);
                newConflicts[conflictIndex] = new ImHashMapEntry<K, V>(hash, key, newValue);
            }
            else
            {
                if (doWhat == DoAddOrUpdateConflicts.Update)
                    return this;

                // add the new conflicting value
                newConflicts = new ImHashMapEntry<K, V>[conflictCount + 1];
                Array.Copy(conflicts, 0, newConflicts, 0, conflictCount);
                newConflicts[conflictCount] = new ImHashMapEntry<K, V>(hash, key, value);
            }

            return new ImHashMap<K, V>(new ImHashMapConflicts<K, V>(hash, newConflicts), Left, Right, Height);
        }

        private ImHashMap<K, V> AddOrUpdateLeftOrRight(int hash, K key, V value)
        {
            if (hash < Hash)
            {
                if (Left.Height == 0)
                    return new ImHashMap<K, V>(Entry, new ImHashMap<K, V>(hash, key, value), Right, 2);

                if (Left.Hash == hash)
                    return new ImHashMap<K, V>(Entry, Left.UpdateValueOrAddOrUpdateConflict(hash, key, value), Right, Height);

                if (Right.Height == 0)
                {
                    if (hash < Left.Hash)
                        return new ImHashMap<K, V>(Left.Entry,
                            new ImHashMap<K, V>(hash, key, value), new ImHashMap<K, V>(Entry), 2);

                    return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key, value),
                        new ImHashMap<K, V>(Left.Entry), new ImHashMap<K, V>(Entry), 2);
                }

                var left = Left.AddOrUpdateLeftOrRight(hash, key, value);
                return left.Height > Right.Height + 1 
                    ? BalanceNewLeftTree(left) 
                    : new ImHashMap<K, V>(Entry, left, Right);
            }
            else
            {
                if (Right.Height == 0)
                    return new ImHashMap<K, V>(Entry, Left, new ImHashMap<K, V>(hash, key, value), 2);

                if (Right.Hash == hash)
                    return new ImHashMap<K, V>(Entry, Left, Right.UpdateValueOrAddOrUpdateConflict(hash, key, value), Height);

                if (Left.Height == 0)
                {
                    if (hash < Right.Hash)
                        return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key, value),
                            new ImHashMap<K, V>(Entry), new ImHashMap<K, V>(Right.Entry), 2);

                    return new ImHashMap<K, V>(Right.Entry,
                        new ImHashMap<K, V>(Entry), new ImHashMap<K, V>(hash, key, value), 2);
                }

                var right = Right.AddOrUpdateLeftOrRight(hash, key, value);
                return right.Height > Left.Height + 1 
                    ? BalanceNewRightTree(right) 
                    : new ImHashMap<K, V>(Entry, Left, right);
            }
        }

        private ImHashMap<K, V> BalanceNewLeftTree(ImHashMap<K, V> newLeftTree)
        {
            var leftLeft = newLeftTree.Left;
            var leftLeftHeight = leftLeft.Height;

            var leftRight = newLeftTree.Right;
            var leftRightHeight = leftRight.Height;

            if (leftRightHeight > leftLeftHeight)
            {
                newLeftTree.Right  = leftRight.Left;
                newLeftTree.Height = leftLeftHeight + 1;
                return new ImHashMap<K, V>(leftRight.Entry,
                    newLeftTree,
                    new ImHashMap<K, V>(Entry, leftRight.Right, Right, Right.Height + 1),
                    leftLeftHeight + 2);

                //return new ImHashMap<K, V>(leftRight.Entry,
                //    new ImHashMap<K, V>(newLeftTree.Entry, leftLeft, leftRight.Left),
                //    new ImHashMap<K, V>(Entry, leftRight.Right, Right));
            }

            newLeftTree.Right = new ImHashMap<K, V>(Entry, leftRight, Right, leftRightHeight + 1);
            newLeftTree.Height = leftRightHeight + 2;
            return newLeftTree;

            //return new ImHashMap<K, V>(newLeftTree.Entry,
            //    leftLeft, new ImHashMap<K, V>(Entry, leftRight, Right));
        }

        // Note that Left is by 2 less deep than `newRightTree` - means that at `newRightTree.Left/Right` is at least of Left height or deeper
        private ImHashMap<K, V> BalanceNewRightTree(ImHashMap<K, V> newRightTree)
        {
            var rightLeft  = newRightTree.Left;
            var rightLeftHeight = rightLeft.Height;

            var rightRight = newRightTree.Right;
            var rightRightHeight = rightRight.Height;
            
            if (rightLeftHeight > rightRightHeight) // 1 greater - not 2 greater because it would be too unbalanced
            {
                newRightTree.Left = rightLeft.Right;
                // the height now should be defined by rr - because left now is shorter by 1
                newRightTree.Height = rightRightHeight + 1;
                // the whole height consequentially can be defined by `newRightTree` (rr+1) because left is consist of short Left and -2 rl.Left
                return new ImHashMap<K, V>(rightLeft.Entry,
                    // Left should be >= rightLeft.Left because it maybe rightLeft.Right which defines rl height
                    new ImHashMap<K, V>(Entry, Left, rightLeft.Left, height:Left.Height + 1),
                    newRightTree, rightRightHeight + 2);

                //return new ImHashMap<K, V>(rightLeft.Entry,
                //    new ImHashMap<K, V>(Entry, Left, rightLeft.Left),
                //    new ImHashMap<K, V>(newRightTree.Entry, rightLeft.Right, rightRight));
            }

            // we may decide on the height because the Left smaller by 2
            newRightTree.Left = new ImHashMap<K, V>(Entry, Left, rightLeft, rightLeftHeight + 1); 
            // if rr was > rl by 1 than new rl+1 should be equal height to rr now, if rr was == rl than new rl wins anyway
            newRightTree.Height = rightLeftHeight + 2;
            return newRightTree;

            //return new ImHashMap<K, V>(newRightTree.Entry, new ImHashMap<K, V>(Entry, Left, rightLeft), rightRight);
        }

        /// Uses the user provided hash and adds and updates the tree with passed key-value and the update function for the existing value. Returns a new tree.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrUpdate(int hash, K key, V value, Update<K, V> update) =>
            Height == 0 ? new ImHashMap<K, V>(hash, key, value)
            : hash == Hash ? UpdateValueOrAddOrUpdateConflict(hash, key, value, update)
            : AddOrUpdateLeftOrRightWithUpdate(hash, key, value, update);

        private ImHashMap<K, V> UpdateValueOrAddOrUpdateConflict(int hash, K key, V value, Update<K, V> update)
        {
            var conflictsData = Entry as ImHashMapConflicts<K, V>;
            return conflictsData == null && (ReferenceEquals(Key, key) || Key.Equals(key))
                ? new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key, update(key, Value, value)), Left, Right, Height)
                : AddOrUpdateConflict(conflictsData, hash, key, value, update);
        }

        private ImHashMap<K, V> AddOrUpdateLeftOrRightWithUpdate(int hash, K key, V value, Update<K, V> update)
        {
            if (hash < Hash)
            {
                if (Left.Height == 0)
                    return new ImHashMap<K, V>(Entry, new ImHashMap<K, V>(hash, key, value), Right, 2);

                if (Left.Hash == hash)
                    return new ImHashMap<K, V>(Entry, Left.UpdateValueOrAddOrUpdateConflict(hash, key, value, update), Right, Height);

                if (Right.Height == 0)
                {
                    if (hash < Left.Hash)
                        return new ImHashMap<K, V>(Left.Entry, new ImHashMap<K, V>(hash, key, value), new ImHashMap<K, V>(Entry), 2);

                    return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key, value),
                        new ImHashMap<K, V>(Left.Entry), new ImHashMap<K, V>(Entry), 2);
                }

                var left = Left.AddOrUpdateLeftOrRightWithUpdate(hash, key, value, update);
                return left.Height > Right.Height + 1
                    ? BalanceNewLeftTree(left)
                    : new ImHashMap<K, V>(Entry, left, Right);
            }
            else
            {
                if (Right.Height == 0)
                    return new ImHashMap<K, V>(Entry, Left, new ImHashMap<K, V>(hash, key, value), 2);

                if (Right.Hash == hash)
                    return new ImHashMap<K, V>(Entry, Left, Right.UpdateValueOrAddOrUpdateConflict(hash, key, value, update), Height);

                if (Left.Height == 0)
                {
                    if (hash < Right.Hash)
                        return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key, value),
                            new ImHashMap<K, V>(Entry), new ImHashMap<K, V>(Right.Entry), 2);

                    return new ImHashMap<K, V>(Right.Entry,
                        new ImHashMap<K, V>(Entry), new ImHashMap<K, V>(hash, key, value), 2);
                }

                var right = Right.AddOrUpdateLeftOrRightWithUpdate(hash, key, value, update);
                return right.Height > Left.Height + 1
                    ? BalanceNewRightTree(right)
                    : new ImHashMap<K, V>(Entry, Left, right);
            }
        }

        /// Returns a new tree with added or updated key-value. Uses the provided <paramref name="update"/> for updating the existing value.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrUpdate(K key, V value, Update<K, V> update) =>
            AddOrUpdate(key.GetHashCode(), key, value, update);

        /// Returns a new tree with added or updated key-value. Uses the provided <paramref name="update"/> for updating the existing value.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrUpdate(K key, V value, Update<V> update) =>
            AddOrUpdate(key.GetHashCode(), key, value, update.IgnoreKey);

        /// Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrKeep(int hash, K key, V value) =>
            Height == 0 ? new ImHashMap<K, V>(hash, key, value)
            : hash == Hash ? KeepValueOrAddConflict(hash, key, value)
            : AddOrKeepLeftOrRight(hash, key, value);

        /// Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrKeep(K key, V value) => 
            AddOrKeep(key.GetHashCode(), key, value);

        private ImHashMap<K, V> KeepValueOrAddConflict(int hash, K key, V value)
        {
            var conflictsData = Entry as ImHashMapConflicts<K, V>;
            return conflictsData == null && (ReferenceEquals(Key, key) || Key.Equals(key)) ? this
                : AddOrUpdateConflict(conflictsData, hash, key, value, null, DoAddOrUpdateConflicts.AddOrKeep);
        }
        private ImHashMap<K, V> AddOrKeepLeftOrRight(int hash, K key, V value)
        {
            if (hash < Hash)
            {
                if (Left.Height == 0)
                    return new ImHashMap<K, V>(Entry, new ImHashMap<K, V>(hash, key, value), Right, 2);

                if (Left.Hash == hash)
                {
                    var leftWithNewConflict = Left.KeepValueOrAddConflict(hash, key, value);
                    return ReferenceEquals(leftWithNewConflict, Left) ? this 
                        : new ImHashMap<K, V>(Entry, leftWithNewConflict, Right, Height);
                }

                if (Right.Height == 0)
                {
                    if (hash < Left.Hash)
                        return new ImHashMap<K, V>(Left.Entry,
                            new ImHashMap<K, V>(hash, key, value), new ImHashMap<K, V>(Entry), 2);

                    return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key, value),
                        new ImHashMap<K, V>(Left.Entry), new ImHashMap<K, V>(Entry), 2);
                }

                var left = Left.AddOrKeepLeftOrRight(hash, key, value);
                if (ReferenceEquals(left, Left))
                    return this;

                return left.Height > Right.Height + 1
                    ? BalanceNewLeftTree(left)
                    : new ImHashMap<K, V>(Entry, left, Right);
            }
            else
            {
                if (Right.Height == 0)
                    return new ImHashMap<K, V>(Entry, Left, new ImHashMap<K, V>(hash, key, value), 2);

                if (Right.Hash == hash)
                {
                    var rightWithNewConflict = Right.KeepValueOrAddConflict(hash, key, value);
                    return ReferenceEquals(rightWithNewConflict, Right) ? this 
                        : new ImHashMap<K, V>(Entry, Left, rightWithNewConflict, Height);
                }

                if (Left.Height == 0)
                {
                    if (hash < Right.Hash)
                        return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key, value),
                            new ImHashMap<K, V>(Entry), new ImHashMap<K, V>(Right.Entry), 2);

                    return new ImHashMap<K, V>(Right.Entry,
                        new ImHashMap<K, V>(Entry), new ImHashMap<K, V>(hash, key, value), 2);
                }

                var right = Right.AddOrKeepLeftOrRight(hash, key, value);
                if (ReferenceEquals(right, Right))
                    return this;

                return right.Height > Left.Height + 1
                    ? BalanceNewRightTree(right)
                    : new ImHashMap<K, V>(Entry, Left, right);
            }
        }

        /// Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrKeep(int hash, K key) =>
            Height == 0 ? new ImHashMap<K, V>(hash, key)
            : hash == Hash ? KeepValueOrAddConflict(hash, key)
            : AddOrKeepLeftOrRight(hash, key);

        /// Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrKeep(K key) =>
            AddOrKeep(key.GetHashCode(), key);

        private ImHashMap<K, V> KeepValueOrAddConflict(int hash, K key)
        {
            var conflictsData = Entry as ImHashMapConflicts<K, V>;
            return conflictsData == null && (ReferenceEquals(Key, key) || Key.Equals(key)) 
                ? this : AddOrKeepConflict(conflictsData, hash, key);
        }

        private ImHashMap<K, V> AddOrKeepConflict(ImHashMapConflicts<K, V> conflictsData, int hash, K key)
        {
            if (conflictsData == null)
                return new ImHashMap<K, V>(
                    new ImHashMapConflicts<K, V>(hash, Entry, new ImHashMapEntry<K, V>(hash, key)),
                    Left, Right, Height);

            var conflicts = conflictsData.Conflicts;
            var conflictCount = conflicts.Length;
            var conflictIndex = conflictCount - 1;
            while (conflictIndex != -1 && !key.Equals(conflicts[conflictIndex].Key))
                --conflictIndex;

            if (conflictIndex != -1)
                return this;

            // add the new conflicting value
            var newConflicts = new ImHashMapEntry<K, V>[conflictCount + 1];
            Array.Copy(conflicts, 0, newConflicts, 0, conflictCount);
            newConflicts[conflictCount] = new ImHashMapEntry<K, V>(hash, key);

            return new ImHashMap<K, V>(new ImHashMapConflicts<K, V>(hash, newConflicts), Left, Right, Height);
        }

        private ImHashMap<K, V> AddOrKeepLeftOrRight(int hash, K key)
        {
            if (hash < Hash)
            {
                if (Left.Height == 0)
                    return new ImHashMap<K, V>(Entry, new ImHashMap<K, V>(hash, key), Right, 2);

                if (Left.Hash == hash)
                {
                    var leftWithNewConflict = Left.KeepValueOrAddConflict(hash, key);
                    return ReferenceEquals(leftWithNewConflict, Left) ? this
                        : new ImHashMap<K, V>(Entry, leftWithNewConflict, Right, Height);
                }

                if (Right.Height == 0)
                {
                    if (hash < Left.Hash)
                        return new ImHashMap<K, V>(Left.Entry,
                            new ImHashMap<K, V>(hash, key), new ImHashMap<K, V>(Entry), 2);

                    return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key),
                        new ImHashMap<K, V>(Left.Entry), new ImHashMap<K, V>(Entry), 2);
                }

                var left = Left.AddOrKeepLeftOrRight(hash, key);
                if (ReferenceEquals(left, Left))
                    return this;

                return left.Height > Right.Height + 1
                    ? BalanceNewLeftTree(left)
                    : new ImHashMap<K, V>(Entry, left, Right);
            }
            else
            {
                if (Right.Height == 0)
                    return new ImHashMap<K, V>(Entry, Left, new ImHashMap<K, V>(hash, key), 2);

                if (Right.Hash == hash)
                {
                    var rightWithNewConflict = Right.KeepValueOrAddConflict(hash, key);
                    return ReferenceEquals(rightWithNewConflict, Right) ? this
                        : new ImHashMap<K, V>(Entry, Left, rightWithNewConflict, Height);
                }

                if (Left.Height == 0)
                {
                    if (hash < Right.Hash)
                        return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key),
                            new ImHashMap<K, V>(Entry), new ImHashMap<K, V>(Right.Entry), 2);

                    return new ImHashMap<K, V>(Right.Entry,
                        new ImHashMap<K, V>(Entry), new ImHashMap<K, V>(hash, key), 2);
                }

                var right = Right.AddOrKeepLeftOrRight(hash, key);
                if (ReferenceEquals(right, Right))
                    return this;

                return right.Height > Left.Height + 1
                    ? BalanceNewRightTree(right)
                    : new ImHashMap<K, V>(Entry, Left, right);
            }
        }

        /// Updates the map with the new value if key is found, otherwise returns the same unchanged map.
        public ImHashMap<K, V> Update(int hash, K key, V value, Update<K, V> update = null)
        {
            if (Height == 0)
                return this;

            // No need to balance cause we not adding or removing nodes
            if (hash < Hash)
            {
                var left = Left.Update(hash, key, value, update);
                return ReferenceEquals(left, Left) ? this : new ImHashMap<K, V>(Entry, left, Right, Height);
            }

            if(hash > Hash)
            {
                var right = Right.Update(hash, key, value, update);
                return ReferenceEquals(right, Right) ? this : new ImHashMap<K, V>(Entry, Left, right, Height);
            }

            var conflictsData = Entry as ImHashMapConflicts<K, V>;
            if (conflictsData == null && (ReferenceEquals(Key, key) || Key.Equals(key)))
                return new ImHashMap<K, V>(
                    new ImHashMapEntry<K, V>(hash, key, update == null ? value : update(key, Value, value)), 
                    Left, Right, Height);

            return AddOrUpdateConflict(conflictsData, hash, key, value, update, DoAddOrUpdateConflicts.Update);
        }

        /// Updates the map with the new value if key is found, otherwise returns the same unchanged map.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> Update(K key, V value) =>
            Update(key.GetHashCode(), key, value);

        /// Updates the map with the new value if key is found, otherwise returns the same unchanged map.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> Update(K key, V value, Update<V> update) =>
            Update(key.GetHashCode(), key, value, update.IgnoreKey);

        /// Updates the map with the Default (null for reference types) value if key is found, otherwise returns the same unchanged map.
        [MethodImpl((MethodImplOptions) 256)]
        public ImHashMap<K, V> UpdateToDefault(int hash, K key)
        {
            if (Height == 0)
                return this;

            // No need to balance cause we not adding or removing nodes
            if (hash < Hash)
            {
                var left = Left.UpdateToDefault(hash, key);
                return left == Left ? this : new ImHashMap<K, V>(Entry, left, Right, Height);
            }

            if (hash > Hash)
            {
                var right = Right.UpdateToDefault(hash, key);
                return right == Right ? this : new ImHashMap<K, V>(Entry, Left, right, Height);
            }

            var conflictsData = Entry as ImHashMapConflicts<K, V>;
            if (conflictsData == null && (ReferenceEquals(Key, key) || Key.Equals(key)))
                return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key), Left, Right, Height);

            return UpdateConflictToDefault(conflictsData, hash, key);
        }

        private ImHashMap<K, V> UpdateConflictToDefault(ImHashMapConflicts<K, V> conflictsData, int hash, K key)
        {
            if (conflictsData == null)
                return this;

            var conflicts = conflictsData.Conflicts;
            var conflictCount = conflicts.Length;
            var conflictIndex = conflictCount - 1;
            while (conflictIndex != -1 && !key.Equals(conflicts[conflictIndex].Key))
                --conflictIndex;

            if (conflictIndex == -1)
                return this;

            // update the existing conflicted value
            var newConflicts = new ImHashMapEntry<K, V>[conflictCount];
            Array.Copy(conflicts, 0, newConflicts, 0, conflictCount);
            newConflicts[conflictIndex] = new ImHashMapEntry<K, V>(hash, key);
            return new ImHashMap<K, V>(new ImHashMapConflicts<K, V>(hash, newConflicts), Left, Right, Height);
        }

        /// <summary>
        /// Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
        /// The only difference is using fixed size array instead of stack for speed-up.
        /// </summary>
        public IEnumerable<ImHashMapEntry<K, V>> Enumerate()
        {
            if (Height != 0)
            {
                var parents = new ImHashMap<K, V>[Height];
                var node = this;
                var parentCount = -1;
                while (node.Height != 0 || parentCount != -1)
                {
                    if (node.Height != 0)
                    {
                        parents[++parentCount] = node;
                        node = node.Left;
                    }
                    else
                    {
                        node = parents[parentCount--];
                        if (node.Entry is ImHashMapConflicts<K, V> conflictsData)
                        {
                            var conflicts = conflictsData.Conflicts;
                            for (var i = 0; i < conflicts.Length; i++)
                                yield return conflicts[i];
                        }
                        else
                        {
                            yield return node.Entry;
                        }

                        node = node.Right;
                    }
                }
            }
        }

        /// <summary>
        /// Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
        /// The only difference is using fixed size array instead of stack for speed-up.
        /// Note: By passing <paramref name="parentsStack"/> you may reuse the stack array between different method calls,
        /// but it should be at least <see cref="ImHashMap{K,V}.Height"/> length. The contents of array are not important.
        /// </summary>
        public S Fold<S>(S state, Func<ImHashMapEntry<K, V>, S, S> reduce, ImHashMap<K, V>[] parentsStack = null)
        {
            if (Height == 1 && Entry is ImHashMapConflicts<K, V> == false)
                return reduce(Entry, state);

            if (Height != 0)
            {
                parentsStack = parentsStack ?? new ImHashMap<K, V>[Height];
                var node = this;
                var parentCount = -1;
                while (node.Height != 0 || parentCount != -1)
                {
                    if (node.Height != 0)
                    {
                        parentsStack[++parentCount] = node;
                        node = node.Left;
                    }
                    else
                    {
                        node = parentsStack[parentCount--];

                        if (!(node.Entry is ImHashMapConflicts<K, V> conflicts))
                            state = reduce(node.Entry, state);
                        else
                        {
                            var conflict = conflicts.Conflicts;
                            for (var i = 0; i < conflict.Length; i++)
                                state = reduce(conflict[i], state);
                        }

                        node = node.Right;
                    }
                }
            }

            return state;
        }

        /// <summary>
        /// Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
        /// The only difference is using fixed size array instead of stack for speed-up.
        /// Note: By passing <paramref name="parentsStack"/> you may reuse the stack array between different method calls,
        /// but it should be at least <see cref="ImHashMap{K,V}.Height"/> length. The contents of array are not important.
        /// </summary>
        public S Fold<S>(S state, Func<ImHashMapEntry<K, V>, int, S, S> reduce, ImHashMap<K, V>[] parentsStack = null)
        {
            if (Height == 1 && Entry is ImHashMapConflicts<K, V> == false)
                return reduce(Entry, 0, state);

            if (Height != 0)
            {
                parentsStack = parentsStack ?? new ImHashMap<K, V>[Height];
                var index = 0;
                var node = this;
                var parentCount = -1;
                while (node.Height != 0 || parentCount != -1)
                {
                    if (node.Height != 0)
                    {
                        parentsStack[++parentCount] = node;
                        node = node.Left;
                    }
                    else
                    {
                        node = parentsStack[parentCount--];

                        if (!(node.Entry is ImHashMapConflicts<K, V> conflicts))
                            state = reduce(node.Entry, index++, state);
                        else
                        {
                            var conflictData = conflicts.Conflicts;
                            for (var i = 0; i < conflictData.Length; i++)
                                state = reduce(conflictData[i], index++, state);
                        }

                        node = node.Right;
                    }
                }
            }

            return state;
        }

        /// <summary>
        /// Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
        /// The only difference is using fixed size array instead of stack for speed-up.
        /// Note: By passing <paramref name="parentsStack"/> you may reuse the stack array between different method calls,
        /// but it should be at least <see cref="ImHashMap{K,V}.Height"/> length. The contents of array are not important.
        /// </summary>
        public S Visit<S>(S state, Action<ImHashMapEntry<K, V>, S> effect, ImHashMap<K, V>[] parentsStack = null)
        {
            if (Height == 1 && Entry is ImHashMapConflicts<K, V> == false)
            {
                effect(Entry, state);
            }
            else if (Height != 0)
            {
                parentsStack = parentsStack ?? new ImHashMap<K, V>[Height];
                var node = this;
                var parentCount = -1;
                while (node.Height != 0 || parentCount != -1)
                {
                    if (node.Height != 0)
                    {
                        parentsStack[++parentCount] = node;
                        node = node.Left;
                    }
                    else
                    {
                        node = parentsStack[parentCount--];

                        if (!(node.Entry is ImHashMapConflicts<K, V> conflicts))
                            effect(node.Entry, state);
                        else
                        {
                            var conflict = conflicts.Conflicts;
                            for (var i = 0; i < conflict.Length; i++)
                                effect(conflict[i], state);
                        }

                        node = node.Right;
                    }
                }
            }

            return state;
        }

        /// <summary>
        /// Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
        /// The only difference is using fixed size array instead of stack for speed-up.
        /// Note: By passing <paramref name="parentsStack"/> you may reuse the stack array between different method calls,
        /// but it should be at least <see cref="ImHashMap{K,V}.Height"/> length. The contents of array are not important.
        /// </summary>
        public void Visit(Action<ImHashMapEntry<K, V>> effect, ImHashMap<K, V>[] parentsStack = null)
        {
            if (Height == 1 && Entry is ImHashMapConflicts<K, V> == false)
                effect(Entry);
            else if (Height != 0)
            {
                parentsStack = parentsStack ?? new ImHashMap<K, V>[Height];
                var node = this;
                var parentCount = -1;
                while (node.Height != 0 || parentCount != -1)
                {
                    if (node.Height != 0)
                    {
                        parentsStack[++parentCount] = node;
                        node = node.Left;
                    }
                    else
                    {
                        node = parentsStack[parentCount--];

                        if (!(node.Entry is ImHashMapConflicts<K, V> conflicts))
                            effect(node.Entry);
                        else
                        {
                            var conflict = conflicts.Conflicts;
                            for (var i = 0; i < conflict.Length; i++)
                                effect(conflict[i]);
                        }

                        node = node.Right;
                    }
                }
            }
        }

        /// <summary> Finds the first entry matching the condition, returns `null` if not found </summary>
        public ImHashMapEntry<K, V> FindFirstOrDefault(Func<ImHashMapEntry<K, V>, bool> condition, ImHashMap<K, V>[] parentsStack = null)
        {
            if (Height == 1 && Entry is ImHashMapConflicts<K, V> == false)
            {
                if (condition(Entry))
                    return Entry;
            }
            else if (Height != 0)
            {
                parentsStack = parentsStack ?? new ImHashMap<K, V>[Height];
                var node = this;
                var parentCount = -1;
                while (node.Height != 0 || parentCount != -1)
                {
                    if (node.Height != 0)
                    {
                        parentsStack[++parentCount] = node;
                        node = node.Left;
                    }
                    else
                    {
                        node = parentsStack[parentCount--];

                        if (!(node.Entry is ImHashMapConflicts<K, V> conflicts))
                        {
                            if (condition(node.Entry))
                                return node.Entry;
                        }
                        else
                        {
                            var conflictedEntries = conflicts.Conflicts;
                            for (var i = 0; i < conflictedEntries.Length; i++)
                                if (condition(conflictedEntries[i]))
                                    return conflictedEntries[i];
                        }

                        node = node.Right;
                    }
                }
            }

            return null;
        }

        /// Removes or updates value for specified key, or does nothing if the key is not found (returns the unchanged map)
        /// Based on Eric Lippert http://blogs.msdn.com/b/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx
        public ImHashMap<K, V> Remove(int hash, K key) =>
            RemoveImpl(hash, key);

        /// Removes or updates value for specified key, or does nothing if the key is not found (returns the unchanged map)
        /// Based on Eric Lippert http://blogs.msdn.com/b/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> Remove(K key) =>
            RemoveImpl(key.GetHashCode(), key);

        private ImHashMap<K, V> RemoveImpl(int hash, K key, bool ignoreKey = false)
        {
            if (Height == 0)
                return this;

            ImHashMap<K, V> result;
            if (hash == Hash) // found node
            {
                if (ignoreKey || Equals(Key, key))
                {
                    if (Height == 1) // remove node
                        return Empty;

                    if (Right.IsEmpty)
                        result = Left;
                    else if (Left.IsEmpty)
                        result = Right;
                    else
                    {
                        // we have two children, so remove the next highest node and replace this node with it.
                        var next = Right;
                        while (!next.Left.IsEmpty) 
                            next = next.Left;
                        result = new ImHashMap<K, V>(next.Entry, Left, Right.RemoveImpl(next.Hash, default, ignoreKey: true));
                    }
                }
                else if (Entry is ImHashMapConflicts<K, V> conflictsData)
                    return TryRemoveConflicted(conflictsData, hash, key);
                else
                    return this; // if key is not matching and no conflicts to lookup - just return
            }
            else
                result = hash < Hash
                    ? Balance(Entry, Left.RemoveImpl(hash, key, ignoreKey), Right)
                    : Balance(Entry, Left, Right.RemoveImpl(hash, key, ignoreKey));

            return result;
        }

        /// <summary> Searches for the key in the conflicts and returns true if found </summary>
        public bool ContainsConflictedData(K key)
        {
            if (Conflicts != null)
            {
                var conflicts = Conflicts;
                for (var i = 0; i < conflicts.Length; ++i)
                    if (key.Equals(conflicts[i].Key))
                        return true;
            }
            return false;
        }

        /// <summary> Searches for the key in the node conflicts </summary>
        public ImHashMapEntry<K, V> GetConflictedEntryOrDefault(K key)
        {
            if (Conflicts != null)
            {
                var conflicts = Conflicts;
                for (var i = 0; i < conflicts.Length; ++i)
                    if (key.Equals(conflicts[i].Key))
                        return conflicts[i];
            }
            return null;
        }

        /// Searches for the key in the node conflicts
        public V GetConflictedValueOrDefault(K key, V defaultValue)
        {
            if (Conflicts != null)
            {
                var conflicts = Conflicts;
                for (var i = 0; i < conflicts.Length; ++i)
                    if (key.Equals(conflicts[i].Key))
                        return conflicts[i].Value;
            }
            return defaultValue;
        }

        /// Searches for the key in the node conflicts
        public bool TryFindConflictedValue(K key, out V value)
        {
            if (Conflicts != null)
            {
                var conflicts = Conflicts;
                for (var i = 0; i < conflicts.Length; ++i)
                    if (Equals(conflicts[i].Key, key))
                    {
                        value = conflicts[i].Value;
                        return true;
                    }
            }
            value = default;
            return false;
        }

        // todo: implement in terms of BalanceNewLeftTree | BalanceNewRightTree
        private static ImHashMap<K, V> Balance(ImHashMapEntry<K, V> entry, ImHashMap<K, V> left, ImHashMap<K, V> right)
        {
            var delta = left.Height - right.Height;
            if (delta > 1) // left is longer by 2, rotate left
            {
                var leftLeft = left.Left;
                var leftRight = left.Right;
                if (leftRight.Height > leftLeft.Height)
                {
                    // double rotation:
                    //      5     =>     5     =>     4
                    //   2     6      4     6      2     5
                    // 1   4        2   3        1   3     6
                    //    3        1
                    return new ImHashMap<K, V>(leftRight.Entry,
                        new ImHashMap<K, V>(left.Entry, leftLeft, leftRight.Left),
                        new ImHashMap<K, V>(entry, leftRight.Right, right));
                }

                // one rotation:
                //      5     =>     2
                //   2     6      1     5
                // 1   4              4   6
                return new ImHashMap<K, V>(left.Entry,
                    leftLeft, new ImHashMap<K, V>(entry, leftRight, right));
            }

            if (delta < -1)
            {
                var rightLeft = right.Left;
                var rightRight = right.Right;
                return rightLeft.Height > rightRight.Height
                    ? new ImHashMap<K, V>(rightLeft.Entry,
                        new ImHashMap<K, V>(entry, left, rightLeft.Left),
                        new ImHashMap<K, V>(right.Entry, rightLeft.Right, rightRight))
                    : new ImHashMap<K, V>(right.Entry, new ImHashMap<K, V>(entry, left, rightLeft), rightRight);
            }

            return new ImHashMap<K, V>(entry, left, right);
        }

        private ImHashMap<K, V> TryRemoveConflicted(ImHashMapConflicts<K, V> conflictsData, int hash, K key)
        {
            var conflicts = conflictsData.Conflicts;
            var index = conflicts.Length - 1;
            while (index != -1 && !conflicts[index].Key.Equals(key)) --index;
            if (index == -1) // key is not found in conflicts - just return
                return this;

            // we removing the one from the 2 items, so we can reference the remaining item directly from the map node 
            if (conflicts.Length == 2)
                return new ImHashMap<K, V>(index == 0 ? conflicts[1] : conflicts[0], Left, Right, Height);

            // copy all except the `index`ed data into shrinked conflicts
            var shrinkedConflicts = new ImHashMapEntry<K, V>[conflicts.Length - 1];
            var newIndex = 0;
            for (var i = 0; i < conflicts.Length; ++i)
                if (i != index) 
                    shrinkedConflicts[newIndex++] = conflicts[i];
            return new ImHashMap<K, V>(new ImHashMapConflicts<K, V>(hash, shrinkedConflicts), Left, Right, Height);
        }
    }

    /// ImHashMap methods for faster performance
    public static class ImHashMap
    {
        /// <summary> Looks for key in a tree and returns `true` if found. </summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool Contains<K, V>(this ImHashMap<K, V> map, int hash, K key)
        {
            while (map.Height != 0 && map.Hash != hash)
                map = hash < map.Hash ? map.Left : map.Right;
            return map.Height != 0 && (key.Equals(map.Key) || map.ContainsConflictedData(key));
        }

        /// <summary> Looks for key in a tree and returns `true` if found. </summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool Contains<K, V>(this ImHashMap<K, V> map, K key) =>
            map.Height != 0 && map.Contains(key.GetHashCode(), key);

        /// Looks for key in a tree and returns the Data object if found or `null` otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMapEntry<K, V> GetEntryOrDefault<K, V>(this ImHashMap<K, V> map, int hash, K key)
        {
            while (map.Height != 0 && map.Hash != hash) 
                map = hash < map.Hash ? map.Left : map.Right;

            return map.Height == 0 ? null : 
                key.Equals(map.Key) ? map.Entry : 
                map.GetConflictedEntryOrDefault(key);
        }

        /// <summary> Looks for key in a tree and returns the Data object if found or `null` otherwise. </summary> 
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMapEntry<K, V> GetEntryOrDefault<K, V>(this ImHashMap<K, V> map, K key)
        {
            if (map.Height == 0)
                return null;

            var hash = key.GetHashCode();

            while (map.Hash != hash)
            {
                map = hash < map.Hash ? map.Left : map.Right;
                if (map.Height == 0)
                    return null;
            }

            return key.Equals(map.Key) ? map.Entry : map.GetConflictedEntryOrDefault(key);
        }

        /// Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, K key, V defaultValue = default)
        {
            if (map.Height == 0)
                return defaultValue;

            var hash = key.GetHashCode();

            while (map.Hash != hash)
            {
                map = hash < map.Hash ? map.Left : map.Right;
                if (map.Height == 0)
                    return defaultValue;
            }

            return key.Equals(map.Key) ? map.Value : map.GetConflictedValueOrDefault(key, defaultValue);
        }

        /// Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, int hash, K key, V defaultValue = default)
        {
            if (map.Height == 0)
                return defaultValue;

            while (map.Hash != hash)
            {
                map = hash < map.Hash ? map.Left : map.Right;
                if (map.Height == 0)
                    return defaultValue;
            }

            return key.Equals(map.Key) ? map.Value : map.GetConflictedValueOrDefault(key, defaultValue);
        }

        /// Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<V>(this ImHashMap<Type, V> map, Type key, V defaultValue = default)
        {
            if (map.Height == 0)
                return defaultValue;

            var hash = key.GetHashCode();
            while (hash != map.Hash)
            {
                map = hash < map.Hash ? map.Left : map.Right;
                if (map.Height == 0)
                    return defaultValue;
            }

            // we don't need to check `Height != 0` again cause in that case `key` will be `null` and `ReferenceEquals` will fail
            return ReferenceEquals(key, map.Key) ? map.Value : map.GetConflictedValueOrDefault(key, defaultValue);
        }

        /// Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<V>(this ImHashMap<Type, V> map, int hash, Type key, V defaultValue = default)
        {
            if (map.Height == 0)
                return defaultValue;

            while (hash != map.Hash)
            {
                map = hash < map.Hash ? map.Left : map.Right;
                if (map.Height == 0)
                    return defaultValue;
            }

            // we don't need to check `Height != 0` again cause in that case `key` will be `null` and `ReferenceEquals` will fail
            return ReferenceEquals(key, map.Key) ? map.Value : map.GetConflictedValueOrDefault(key, defaultValue);
        }

        /// Returns true if key is found and sets the value.
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<K, V>(this ImHashMap<K, V> map, K key, out V value)
        {
            if (map.Height != 0)
            {
                var hash = key.GetHashCode();

                while (hash != map.Hash && map.Height != 0)
                    map = hash < map.Hash ? map.Left : map.Right;

                if (map.Height != 0)
                {
                    if (key.Equals(map.Key))
                    {
                        value = map.Value;
                        return true;
                    }

                    return map.TryFindConflictedValue(key, out value);
                }
            }

            value = default;
            return false;
        }

        /// Returns true if key is found and sets the value.
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<K, V>(this ImHashMap<K, V> map, int hash, K key, out V value)
        {
            if (map.Height != 0)
            {
                while (hash != map.Hash && map.Height != 0)
                    map = hash < map.Hash ? map.Left : map.Right;

                if (map.Height != 0)
                {
                    if (key.Equals(map.Key))
                    {
                        value = map.Value;
                        return true;
                    }

                    return map.TryFindConflictedValue(key, out value);
                }
            }

            value = default;
            return false;
        }

        /// Returns true if key is found and the result value.
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<V>(this ImHashMap<Type, V> map, Type key, out V value)
        {
            if (map.Height != 0)
            {
                var hash = key.GetHashCode();
                while (hash != map.Hash && map.Height != 0)
                    map = hash < map.Hash ? map.Left : map.Right;

                if (map.Height != 0)
                {
                    // assign to `var data = ...`
                    if (ReferenceEquals(key, map.Key))
                    {
                        value = map.Value;
                        return true;
                    }

                    return map.TryFindConflictedValue(key, out value);
                }
            }

            value = default;
            return false;
        }

        /// Returns true if hash and key are found and the result value, or the false otherwise
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<V>(this ImHashMap<Type, V> map, int hash, Type key, out V value)
        {
            if (map.Height != 0)
            {
                while (hash != map.Hash && map.Height != 0)
                    map = hash < map.Hash ? map.Left : map.Right;

                if (map.Height != 0)
                {
                    if (ReferenceEquals(key, map.Key))
                    {
                        value = map.Value;
                        return true;
                    }

                    return map.TryFindConflictedValue(key, out value);
                }
            }

            value = default;
            return false;
        }
    }

    /// <summary>
    /// The array of ImHashMap slots where the key first bits are used for FAST slot location
    /// and the slot is the reference to ImHashMap that can be swapped with its updated value
    /// </summary>
    public static class ImHashMapSlots
    {
        /// Default number of slots
        public const int SLOT_COUNT_POWER_OF_TWO = 32;

        /// The default mask to partition the key to the target slot
        public const int HASH_MASK_TO_FIND_SLOT = SLOT_COUNT_POWER_OF_TWO - 1;

        /// Creates the array with the empty slots
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V>[] CreateWithEmpty<K, V>(int slotCountPowerOfTwo = SLOT_COUNT_POWER_OF_TWO)
        {
            var slots = new ImHashMap<K, V>[slotCountPowerOfTwo];
            for (var i = 0; i < slots.Length; ++i)
                slots[i] = ImHashMap<K, V>.Empty;
            return slots;
        }

        /// Returns a new tree with added or updated value for specified key.
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] slots, int hash, K key, V value, int hashMaskToFindSlot = HASH_MASK_TO_FIND_SLOT)
        {
            ref var slot = ref slots[hash & hashMaskToFindSlot];
            var copy = slot;
            if (Interlocked.CompareExchange(ref slot, copy.AddOrUpdate(hash, key, value), copy) != copy)
                RefAddOrUpdateSlot(ref slot, hash, key, value);
        }

        /// Returns a new tree with added or updated value for specified key.
        [MethodImpl((MethodImplOptions) 256)]
        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] slots, K key, V value, int hashMaskToFindSlot = HASH_MASK_TO_FIND_SLOT) =>
            slots.AddOrUpdate(key.GetHashCode(), key, value, hashMaskToFindSlot);

        /// Updates the ref to the slot with the new version - retry if the someone changed the slot in between
        public static void RefAddOrUpdateSlot<K, V>(ref ImHashMap<K, V> slot, int hash, K key, V value) =>
            Ref.Swap(ref slot, hash, key, value, (x, h, k, v) => x.AddOrUpdate(h, k, v));

        /// Updates the value with help of `updateValue` function
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] slots, int hash, K key, V value, Update<K, V> update, int hashMaskToFindSlot = HASH_MASK_TO_FIND_SLOT)
        {
            ref var slot = ref slots[hash & hashMaskToFindSlot];
            var copy = slot;
            if (Interlocked.CompareExchange(ref slot, copy.AddOrUpdate(hash, key, value, update), copy) != copy)
                RefAddOrUpdateSlot(ref slot, hash, key, value, update);
        }

        /// Updates the value with help of `updateValue` function
        [MethodImpl((MethodImplOptions) 256)]
        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] slots, K key, V value, Update<K, V> updateValue, int hashMaskToFindSlot = HASH_MASK_TO_FIND_SLOT) =>
            slots.AddOrUpdate(key.GetHashCode(), key, value, updateValue, hashMaskToFindSlot);

        /// Update the ref to the slot with the new version - retry if the someone changed the slot in between
        public static void RefAddOrUpdateSlot<K, V>(ref ImHashMap<K, V> slot, int hash, K key, V value, Update<K, V> update) =>
            Ref.Swap(ref slot, hash, key, value, (x, h, k, v) => x.AddOrUpdate(h, k, v, update));

        /// Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrKeep<K, V>(this ImHashMap<K, V>[] slots, int hash, K key, V value, int hashMaskToFindSlot = HASH_MASK_TO_FIND_SLOT)
        {
            ref var slot = ref slots[hash & hashMaskToFindSlot];
            var copy = slot;
            if (Interlocked.CompareExchange(ref slot, copy.AddOrKeep(hash, key, value), copy) != copy)
                RefAddOrKeepSlot(ref slot, hash, key, value);
        }

        /// Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrKeep<K, V>(this ImHashMap<K, V>[] slots, K key, V value, int hashMaskToFindSlot = HASH_MASK_TO_FIND_SLOT) =>
            slots.AddOrKeep(key.GetHashCode(), key, value, hashMaskToFindSlot);

        /// Update the ref to the slot with the new version - retry if the someone changed the slot in between
        public static void RefAddOrKeepSlot<K, V>(ref ImHashMap<K, V> slot, int hash, K key, V value) =>
            Ref.Swap(ref slot, hash, key, value, (s, h, k, v) => s.AddOrKeep(h, k, v));

        /// Updates the specified slot or does not change it
        [MethodImpl((MethodImplOptions)256)]
        public static void Update<K, V>(this ImHashMap<K, V>[] slots, int hash, K key, V value, int hashMaskToFindSlot = HASH_MASK_TO_FIND_SLOT)
        {
            ref var slot = ref slots[hash & hashMaskToFindSlot];
            var copy = slot;
            if (Interlocked.CompareExchange(ref slot, copy.Update(hash, key, value), copy) != copy)
                RefUpdateSlot(ref slot, hash, key, value);
        }

        /// Updates the specified slot or does not change it
        [MethodImpl((MethodImplOptions) 256)]
        public static void Update<K, V>(this ImHashMap<K, V>[] slots, K key, V value, int hashMaskToFindSlot = HASH_MASK_TO_FIND_SLOT) =>
            slots.Update(key.GetHashCode(), key, value, hashMaskToFindSlot);

        /// Update the ref to the slot with the new version - retry if the someone changed the slot in between
        public static void RefUpdateSlot<K, V>(ref ImHashMap<K, V> slot, int hash, K key, V value) =>
            Ref.Swap(ref slot, key, value, (s, k, v) => s.Update(k, v));

        /// Returns all map tree nodes without the order
        public static S Fold<K, V, S>(this ImHashMap<K, V>[] slots, S state, Func<ImHashMapEntry<K, V>, S, S> reduce)
        {
            var parentStack = ArrayTools.Empty<ImHashMap<K, V>>();
            for (var s = 0; s < slots.Length; s++)
            {
                var map = slots[s];
                var height = map.Height;
                if (height != 0)
                {
                    if (height > 1 && parentStack.Length < height)
                        parentStack = new ImHashMap<K, V>[height];
                    state = map.Fold(state, reduce, parentStack);
                }
            }

            return state;
        }
    }
}
