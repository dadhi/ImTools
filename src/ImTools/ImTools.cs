// <auto-generated/>
/*
The MIT License (MIT)

Copyright (c) 2016-2019 Maksim Volkau

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// ReSharper disable once InconsistentNaming

namespace ImTools
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading;
    using System.Runtime.CompilerServices; // For [MethodImpl(AggressiveInlining)]

    /// <summary>Helpers for functional composition</summary>
    public static class Fun
    {
        /// <summary>Always a true condition.</summary>
        public static bool Always<T>(T _) => true;

        /// <summary>Identity function returning passed argument as result.</summary>
        public static T Id<T>(T x) => x;

        /// <summary>Piping</summary>
        public static R To<T, R>(this T x, Func<T, R> map) => map(x);

        /// <summary>Piping</summary>
        public static T Do<T>(this T x, Action<T> effect)
        {
            effect(x);
            return x;
        }

        /// Lifts argument to Func without allocations ignoring the first argument.
        /// For example if you have `Func{T, R} = _ => instance`,
        /// you may rewrite it without allocations as `instance.ToFunc{A, R}` 
        public static R ToFunc<T, R>(this R result, T ignoredArg) => result;
    }

    /// Replacement for `Void` type which can be used as a type argument and value.
    /// In traditional functional languages this type is a singleton empty record type,
    /// e.g. `()` in Haskell https://en.wikipedia.org/wiki/Unit_type
    public struct Empty
    {
        /// Singleton unit
        public static readonly Empty Value = new Empty();

        /// <inheritdoc />
        public override string ToString() => "(empty)";
    }

    /*
    ## The example of Union usage:
    *
    /// UI elements
    sealed class UI : U<Text.it, Input.it, Button.it, Check.it, Panel.it> {}
    sealed class Text   : I<Text,   string> {}
    sealed class Input  : I<Input,  (string Content, MessageRef<string> Changed)> {}
    sealed class Button : I<Button, (string Label, MessageRef<Empty> Clicked)> {}
    sealed class Check  : I<Check,  (string Label, bool IsChecked, MessageRef<bool> Changed)> {}
    sealed class Panel  : I<Panel,  (Layout Layout, ImZipper<UI.union> Elements)> {}

    // Somewhere else:
    private static UIElement CreateElement(UI.union ui)
    {
        switch (ui)
        {
            case I<Text> text:
                return new Label { Content = text.Value() };

            case I<Input> input:
                {
                    var (content, changed) = input.Value();
                    var tb = new TextBox { Text = content };
                    tb.TextChanged += (sender, _) => changed.Send(((TextBox)sender).Text);
                    return tb;
                }
            case I<Button> button:
                {
                    var (label, clicked) = button.Value();
                    var b = new Btn { Content = label };
                    b.Click += (sender, _) => clicked.Send(Empty.Value);
                    return b;
                }
            case I<Panel> panel:
                {
                    var (layout, elems) = panel.Value();
                    var orientation = layout == Layout.Vertical ? Orientation.Vertical : Orientation.Horizontal;
                    var p = new StackPanel { Orientation = orientation };
                    elems.Map(CreateElement).Map(e => p.Children.Add(e));
                    return p;
                }
            case I<Check> check:
                {
                    var (label, isChecked, changed) = check.Value();
                    var c = new CheckBox { Content = label, IsChecked = isChecked };
                    c.Checked += (s, _) => changed.Send(true);
                    c.Unchecked += (s, _) => changed.Send(false);
                    return c;
                }
            default:
                throw new NotSupportedException("The type of UI is not supported: " + ui.GetType());
        }
    }
*/

    /// Useful for type pattern matching via `case I{T} x: ...`
    public interface I<out T>
    {
        /// The value in this case ;)
        T Case { get; }
    }

    /// Helpers for `Is` and `Union`
    public static class Union
    {
        /// Pretty prints the Union using the type information
        internal static string ToString<TName, T>(T value)
        {
            if (typeof(TName) == typeof(Empty))
                return ".union(" + value + ")";

            var typeName = typeof(TName).Name;
            var i = typeName.IndexOf('`');
            var name = i == -1 ? typeName : typeName.Substring(0, i);
            return name + ".union(" + value + ")";
        }
    }

    /// Wraps a single value in a nested struct
    public abstract class Rec<TRef, T> : I<T>, IEquatable<Rec<TRef, T>>
        where TRef : Rec<TRef, T>, new()
    {
        /// Converts a value into Rec of the value
        public static TRef Of(T v) => new TRef { Case = v };

        /// <inheritdoc />
        public T Case { get; private set; }

        /// <inheritdoc />
        public bool Equals(Rec<TRef, T> other) =>
            other != null && EqualityComparer<T>.Default.Equals(Case, other.Case);

        /// <inheritdoc />
        public override bool Equals(object obj) => obj is Rec<TRef, T> c && Equals(c);

        // ReSharper disable once NonReadonlyMemberInGetHashCode
        /// <inheritdoc />
        public override int GetHashCode() => EqualityComparer<T>.Default.GetHashCode(Case);

        /// <inheritdoc />
        public override string ToString() => Union.ToString<TRef, T>(Case);
    }

    /// Wraps a single value in a nested struct
    public abstract class Val<TVal, T>
    {
        /// Creation method for the consistency with other types
        public static value Of(T x) => new value(x);

        /// Nested structure that hosts a value.
        /// All nested types by convention here are lowercase
        public readonly struct value : IEquatable<value>, I<T>
        {
            /// <inheritdoc />
            public T Case { [MethodImpl((MethodImplOptions)256)] get => Value; }

            /// The value
            public readonly T Value;

            /// Constructor
            public value(T x) => Value = x;

            /// <inheritdoc />
            public bool Equals(value other) => EqualityComparer<T>.Default.Equals(Value, other.Value);

            /// <inheritdoc />
            public override bool Equals(object obj) => obj is value c && Equals(c);

            /// <inheritdoc />
            public override int GetHashCode() => EqualityComparer<T>.Default.GetHashCode(Value);

            /// <inheritdoc />
            public override string ToString() => Union.ToString<TVal, T>(Value);
        }
    }

    /// Unnamed discriminated union (with Empty name), shorter name for simplified inline usage
    public class U2<T1, T2> : U<Empty, T1, T2> { }

    /// Named discriminated union
    public abstract class U<TName, T1, T2>
    {
        /// The base interface to operate.
        /// The naming is selected to start from the lower letter, cause we need to use the nested type.
        /// It is an unusual case, that's why using the __union__ will be fine to highlight this.
        // ReSharper disable once InconsistentNaming
        public interface union
        {
            /// Matches the union cases to the R value
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2);
        }

        /// Creates the respective case
        public static union Of(T1 x) => new case1(x);

        /// Creates the respective case
        public static union Of(T2 x) => new case2(x);

        /// Wraps the respective case
        public readonly struct case1 : union, IEquatable<case1>, I<T1>
        {
            /// Conversion
            public static implicit operator case1(T1 x) => new case1(x);

            /// <inheritdoc />
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2) => map1(Case);

            /// <inheritdoc />
            public T1 Case => Value;

            /// The X
            public readonly T1 Value;

            /// Wraps the value
            public case1(T1 x) => Value = x;

            /// <inheritdoc />
            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Value, other.Value);

            /// <inheritdoc />
            public override bool Equals(object obj) => obj is case1 x && Equals(x);

            /// <inheritdoc />
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Value);

            /// <inheritdoc />
            public override string ToString() => Union.ToString<TName, T1>(Value);
        }

        /// Wraps the respective case
        public readonly struct case2 : union, IEquatable<case2>, I<T2>
        {
            /// Conversion
            public static implicit operator case2(T2 x) => new case2(x);

            /// <inheritdoc />
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2) => map2(Value);

            /// <inheritdoc />
            public T2 Case => Value;

            /// The X
            public readonly T2 Value;

            /// Wraps the value
            public case2(T2 x) => Value = x;

            /// <inheritdoc />
            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Value, other.Value);

            /// <inheritdoc />
            public override bool Equals(object obj) => obj is case2 x && Equals(x);

            /// <inheritdoc />
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Value);

            /// <inheritdoc />
            public override string ToString() => Union.ToString<TName, T2>(Value);
        }
    }

#pragma warning disable 1591
    public class U3<T1, T2, T3> : U<Empty, T1, T2, T3> { }

    public abstract class U<TName, T1, T2, T3>
    {
        public interface union
        {
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3);
        }

        public static union Of(T1 x) => new case1(x);
        public static union Of(T2 x) => new case2(x);
        public static union Of(T3 x) => new case3(x);

        public struct case1 : union, IEquatable<case1>, I<T1>
        {
            public static implicit operator case1(T1 x) => new case1(x);

            [MethodImpl((MethodImplOptions)256)]
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3) => map1(X);

            public T1 Case { [MethodImpl((MethodImplOptions)256)] get => X; }

            public readonly T1 X;

            public case1(T1 x) => X = x;

            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(X, other.X);
            public override bool Equals(object obj) => obj is case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(X);
            public override string ToString() => Union.ToString<TName, T1>(X);
        }

        public struct case2 : union, IEquatable<case2>, I<T2>
        {
            public static implicit operator case2(T2 x) => new case2(x);

            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3) => map2(X);

            public T2 Case { [MethodImpl((MethodImplOptions)256)] get => X; }

            public readonly T2 X;

            public case2(T2 x) => X = x;

            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(X, other.X);
            public override bool Equals(object obj) => obj is case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(X);
            public override string ToString() => Union.ToString<TName, T2>(X);
        }

        public struct case3 : union, IEquatable<case3>, I<T3>
        {
            public static implicit operator case3(T3 x) => new case3(x);

            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3) => map3(X);

            public T3 Case => X;

            public readonly T3 X;

            public case3(T3 x) => X = x;

            public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(X, other.X);
            public override bool Equals(object obj) => obj is case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(X);
            public override string ToString() => Union.ToString<TName, T3>(X);
        }
    }

    public class U4<T1, T2, T3, T4> : Union<Empty, T1, T2, T3, T4> { }
    public abstract class Union<TType, T1, T2, T3, T4>
    {
        public interface union
        {
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4);
        }

        public static union Of(T1 x) => new Case1(x);
        public static union Of(T2 x) => new Case2(x);
        public static union Of(T3 x) => new Case3(x);
        public static union Of(T4 x) => new Case4(x);

        public struct Case1 : union, IEquatable<Case1>, I<T1>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4) => map1(Case);

            public T1 Case { get; }
            public Case1(T1 v) => Case = v;

            public bool Equals(Case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T1>(Case);
        }

        public struct Case2 : union, IEquatable<Case2>, I<T2>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4) => map2(Case);

            public T2 Case { get; }
            public Case2(T2 v) { Case = v; }

            public bool Equals(Case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T2>(Case);
        }

        public struct Case3 : union, IEquatable<Case3>, I<T3>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4) => map3(Case);

            public T3 Case { get; }
            public Case3(T3 v) { Case = v; }

            public bool Equals(Case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T3>(Case);
        }

        public struct Case4 : union, IEquatable<Case4>, I<T4>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4) => map4(Case);

            public T4 Case { get; }
            public Case4(T4 v) { Case = v; }

            public bool Equals(Case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T4>(Case);
        }
    }

    public class U<T1, T2, T3, T4, T5> : Union<Empty, T1, T2, T3, T4, T5> { }
    public abstract class Union<TType, T1, T2, T3, T4, T5>
    {
        public interface union
        {
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5);
        }

        public static union Of(T1 x) => new Case1(x);
        public static union Of(T2 x) => new Case2(x);
        public static union Of(T3 x) => new Case3(x);
        public static union Of(T4 x) => new Case4(x);
        public static union Of(T5 x) => new Case5(x);

        public struct Case1 : union, IEquatable<Case1>, I<T1>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map1(Case);

            public T1 Case { get; }
            public Case1(T1 v) => Case = v;

            public bool Equals(Case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T1>(Case);
        }

        public struct Case2 : union, IEquatable<Case2>, I<T2>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map2(Case);

            public T2 Case { get; }
            public Case2(T2 v) => Case = v;

            public bool Equals(Case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case2 c && Equals(c);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T2>(Case);
        }

        public struct Case3 : union, IEquatable<Case3>, I<T3>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map3(Case);

            public T3 Case { get; }
            public Case3(T3 v) => Case = v;

            public bool Equals(Case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T3>(Case);
        }

        public struct Case4 : union, IEquatable<Case4>, I<T4>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map4(Case);

            public T4 Case { get; }
            public Case4(T4 v) { Case = v; }

            public bool Equals(Case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T4>(Case);
        }

        public struct Case5 : union, IEquatable<Case5>, I<T5>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map5(Case);

            public T5 Case { get; }
            public Case5(T5 v) { Case = v; }

            public bool Equals(Case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case5 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T5>(Case);
        }
    }

    public class U<T1, T2, T3, T4, T5, T6> : Union<Empty, T1, T2, T3, T4, T5, T6> { }
    public abstract class Union<TType, T1, T2, T3, T4, T5, T6>
    {
        public interface union
        {
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6);
        }

        public static union Of(T1 x) => new Case1(x);
        public static union Of(T2 x) => new Case2(x);
        public static union Of(T3 x) => new Case3(x);
        public static union Of(T4 x) => new Case4(x);
        public static union Of(T5 x) => new Case5(x);
        public static union Of(T6 x) => new Case6(x);

        public struct Case1 : union, IEquatable<Case1>, I<T1>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6) => map1(Case);

            public T1 Case { get; }
            public Case1(T1 v) => Case = v;

            public bool Equals(Case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T1>(Case);
        }

        public struct Case2 : union, IEquatable<Case2>, I<T2>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6) => map2(Case);

            public T2 Case { get; }
            public Case2(T2 v) => Case = v;

            public bool Equals(Case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case2 c && Equals(c);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T2>(Case);
        }

        public struct Case3 : union, IEquatable<Case3>, I<T3>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6) => map3(Case);

            public T3 Case { get; }
            public Case3(T3 v) => Case = v;

            public bool Equals(Case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T3>(Case);
        }

        public struct Case4 : union, IEquatable<Case4>, I<T4>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6) => map4(Case);

            public T4 Case { get; }
            public Case4(T4 v) { Case = v; }

            public bool Equals(Case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T4>(Case);
        }

        public struct Case5 : union, IEquatable<Case5>, I<T5>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6) => map5(Case);

            public T5 Case { get; }
            public Case5(T5 v) { Case = v; }

            public bool Equals(Case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case5 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T5>(Case);
        }

        public struct Case6 : union, IEquatable<Case6>, I<T6>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6) => map6(Case);

            public T6 Case { get; }
            public Case6(T6 v) { Case = v; }

            public bool Equals(Case6 other) => EqualityComparer<T6>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case5 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T6>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T6>(Case);
        }
    }

    public class U<T1, T2, T3, T4, T5, T6, T7> : Union<Empty, T1, T2, T3, T4, T5, T6, T7> { }
    public abstract class Union<TType, T1, T2, T3, T4, T5, T6, T7>
    {
        public interface union
        {
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7);
        }

        public static union Of(T1 x) => new Case1(x);
        public static union Of(T2 x) => new Case2(x);
        public static union Of(T3 x) => new Case3(x);
        public static union Of(T4 x) => new Case4(x);
        public static union Of(T5 x) => new Case5(x);
        public static union Of(T6 x) => new Case6(x);
        public static union Of(T7 x) => new Case7(x);

        public struct Case1 : union, IEquatable<Case1>, I<T1>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7) => map1(Case);

            public T1 Case { get; }
            public Case1(T1 v) => Case = v;

            public bool Equals(Case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T1>(Case);
        }

        public struct Case2 : union, IEquatable<Case2>, I<T2>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7) => map2(Case);

            public T2 Case { get; }
            public Case2(T2 v) => Case = v;

            public bool Equals(Case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case2 c && Equals(c);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T2>(Case);
        }

        public struct Case3 : union, IEquatable<Case3>, I<T3>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7) => map3(Case);

            public T3 Case { get; }
            public Case3(T3 v) => Case = v;

            public bool Equals(Case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T3>(Case);
        }

        public struct Case4 : union, IEquatable<Case4>, I<T4>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7) => map4(Case);

            public T4 Case { get; }
            public Case4(T4 v) { Case = v; }

            public bool Equals(Case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T4>(Case);
        }

        public struct Case5 : union, IEquatable<Case5>, I<T5>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7) => map5(Case);

            public T5 Case { get; }
            public Case5(T5 v) { Case = v; }

            public bool Equals(Case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case5 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T5>(Case);
        }

        public struct Case6 : union, IEquatable<Case6>, I<T6>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7) => map6(Case);

            public T6 Case { get; }
            public Case6(T6 v) { Case = v; }

            public bool Equals(Case6 other) => EqualityComparer<T6>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case6 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T6>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T6>(Case);
        }

        public struct Case7 : union, IEquatable<Case7>, I<T7>
        {
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7) => map7(Case);

            public T7 Case { get; }
            public Case7(T7 v) { Case = v; }

            public bool Equals(Case7 other) => EqualityComparer<T7>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is Case7 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T7>.Default.GetHashCode(Case);
            public override string ToString() => Union.ToString<TType, T7>(Case);
        }
    }

#pragma warning restore 1591

    /// <summary>Methods to work with immutable arrays and some sugar.</summary>
    public static class ArrayTools
    {
        private static class EmptyArray<T>
        {
            public static readonly T[] Value = new T[0];
        }

        /// <summary>Returns singleton empty array of provided type.</summary> 
        /// <typeparam name="T">Array item type.</typeparam> <returns>Empty array.</returns>
        public static T[] Empty<T>() => EmptyArray<T>.Value;

        /// <summary>Wraps item in array.</summary>
        public static T[] One<T>(this T one) => new[] { one };

        /// <summary>Returns true if array is null or have no items.</summary> <typeparam name="T">Type of array item.</typeparam>
        /// <param name="source">Source array to check.</param> <returns>True if null or has no items, false otherwise.</returns>
        public static bool IsNullOrEmpty<T>(this T[] source) => source == null || source.Length == 0;

        /// <summary>Returns empty array instead of null, or source array otherwise.</summary> <typeparam name="T">Type of array item.</typeparam>
        public static T[] EmptyIfNull<T>(this T[] source) => source ?? Empty<T>();

        /// Returns source enumerable if it is array, otherwise converts source to array or an empty array if null.
        public static T[] ToArrayOrSelf<T>(this IEnumerable<T> source) =>
            source == null ? Empty<T>() : (source as T[] ?? source.ToArray());

        /// Returns source enumerable if it is list, otherwise converts source to IList or an empty array if null.
        public static IList<T> ToListOrSelf<T>(this IEnumerable<T> source) =>
            source == null ? Empty<T>() : source as IList<T> ?? source.ToList();

        /// <summary>Returns new array consisting from all items from source array then all items from added array.
        /// If source is null or empty, then added array will be returned.
        /// If added is null or empty, then source will be returned.</summary>
        /// <typeparam name="T">Array item type.</typeparam>
        /// <param name="source">Array with leading items.</param>
        /// <param name="added">Array with following items.</param>
        /// <returns>New array with items of source and added arrays.</returns>
        public static T[] Append<T>(this T[] source, params T[] added)
        {
            if (added == null || added.Length == 0)
                return source;
            if (source == null || source.Length == 0)
                return added;

            var result = new T[source.Length + added.Length];
            Array.Copy(source, 0, result, 0, source.Length);
            if (added.Length == 1)
                result[source.Length] = added[0];
            else
                Array.Copy(added, 0, result, source.Length, added.Length);
            return result;
        }

        /// <summary>Performant concat of enumerables in case of arrays.
        /// But performance will degrade if you use Concat().Where().</summary>
        /// <typeparam name="T">Type of item.</typeparam>
        /// <param name="source">goes first.</param>
        /// <param name="other">appended to source.</param>
        /// <returns>empty array or concat of source and other.</returns>
        public static T[] Append<T>(this IEnumerable<T> source, IEnumerable<T> other) =>
            source.ToArrayOrSelf().Append(other.ToArrayOrSelf());

        /// <summary>Returns new array with <paramref name="value"/> appended, 
        /// or <paramref name="value"/> at <paramref name="index"/>, if specified.
        /// If source array could be null or empty, then single value item array will be created despite any index.</summary>
        /// <typeparam name="T">Array item type.</typeparam>
        /// <param name="source">Array to append value to.</param>
        /// <param name="value">Value to append.</param>
        /// <param name="index">(optional) Index of value to update.</param>
        /// <returns>New array with appended or updated value.</returns>
        public static T[] AppendOrUpdate<T>(this T[] source, T value, int index = -1)
        {
            if (source == null || source.Length == 0)
                return new[] { value };
            var sourceLength = source.Length;
            index = index < 0 ? sourceLength : index;
            var result = new T[index < sourceLength ? sourceLength : sourceLength + 1];
            Array.Copy(source, result, sourceLength);
            result[index] = value;
            return result;
        }

        /// <summary>Calls predicate on each item in <paramref name="source"/> array until predicate returns true,
        /// then method will return this item index, or if predicate returns false for each item, method will return -1.</summary>
        /// <typeparam name="T">Type of array items.</typeparam>
        /// <param name="source">Source array: if null or empty, then method will return -1.</param>
        /// <param name="predicate">Delegate to evaluate on each array item until delegate returns true.</param>
        /// <returns>Index of item for which predicate returns true, or -1 otherwise.</returns>
        public static int IndexOf<T>(this T[] source, Func<T, bool> predicate)
        {
            if (source != null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                    if (predicate(source[i]))
                        return i;
            return -1;
        }

        /// Minimizes the allocations for closure in predicate lambda with the provided <paramref name="state"/>
        public static int IndexOf<T, S>(this T[] source, S state, Func<S, T, bool> predicate)
        {
            if (source != null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                    if (predicate(state, source[i]))
                        return i;
            return -1;
        }

        /// <summary>Looks up for item in source array equal to provided value, and returns its index, or -1 if not found.</summary>
        /// <typeparam name="T">Type of array items.</typeparam>
        /// <param name="source">Source array: if null or empty, then method will return -1.</param>
        /// <param name="value">Value to look up.</param>
        /// <returns>Index of item equal to value, or -1 item is not found.</returns>
        public static int IndexOf<T>(this T[] source, T value)
        {
            if (source != null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                {
                    var item = source[i];
                    if (Equals(item, value))
                        return i;
                }

            return -1;
        }

        /// <summary>Produces new array without item at specified <paramref name="index"/>. 
        /// Will return <paramref name="source"/> array if index is out of bounds, or source is null/empty.</summary>
        /// <typeparam name="T">Type of array item.</typeparam>
        /// <param name="source">Input array.</param> <param name="index">Index if item to remove.</param>
        /// <returns>New array with removed item at index, or input source array if index is not in array.</returns>
        public static T[] RemoveAt<T>(this T[] source, int index)
        {
            if (source == null || source.Length == 0 || index < 0 || index >= source.Length)
                return source;
            if (index == 0 && source.Length == 1)
                return new T[0];
            var result = new T[source.Length - 1];
            if (index != 0)
                Array.Copy(source, 0, result, 0, index);
            if (index != result.Length)
                Array.Copy(source, index + 1, result, index, result.Length - index);
            return result;
        }

        /// <summary>Looks for item in array using equality comparison, and returns new array with found item remove, or original array if not item found.</summary>
        /// <typeparam name="T">Type of array item.</typeparam>
        /// <param name="source">Input array.</param> <param name="value">Value to find and remove.</param>
        /// <returns>New array with value removed or original array if value is not found.</returns>
        public static T[] Remove<T>(this T[] source, T value) =>
            source.RemoveAt(source.IndexOf(value));

        /// <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
        /// <typeparam name="T">item type</typeparam>
        /// <param name="source">items collection to search</param>
        /// <param name="predicate">condition to evaluate for each item.</param>
        /// <returns>First item matching condition or default value.</returns>
        public static T FindFirst<T>(this T[] source, Func<T, bool> predicate)
        {
            if (source != null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                {
                    var item = source[i];
                    if (predicate(item))
                        return item;
                }

            return default(T);
        }

        /// Version of FindFirst with the fixed state used by predicate to prevent allocations by predicate lambda closure
        public static T FindFirst<T, S>(this T[] source, S state, Func<S, T, bool> predicate)
        {
            if (source != null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                {
                    var item = source[i];
                    if (predicate(state, item))
                        return item;
                }

            return default(T);
        }

        /// <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
        /// <typeparam name="T">item type</typeparam>
        /// <param name="source">items collection to search</param>
        /// <param name="predicate">condition to evaluate for each item.</param>
        /// <returns>First item matching condition or default value.</returns>
        public static T FindFirst<T>(this IEnumerable<T> source, Func<T, bool> predicate) =>
            source is T[] sourceArr ? sourceArr.FindFirst(predicate) : source.FirstOrDefault(predicate);

        /// <summary>Returns element if collection consist on single element, otherwise returns default value.
        /// It does not throw for collection with many elements</summary>
        public static T SingleOrDefaultIfMany<T>(this IEnumerable<T> source)
        {
            if (source is IList<T> list)
                return list.Count == 1 ? list[0] : default(T);

            if (source == null)
                return default(T);

            using (var e = source.GetEnumerator())
            {
                if (!e.MoveNext())
                    return default(T);
                var it = e.Current;
                return !e.MoveNext() ? it : default(T);
            }
        }

        /// <summary>Does <paramref name="action"/> for each item</summary>
        public static void ForEach<T>(this T[] source, Action<T> action)
        {
            if (!source.IsNullOrEmpty())
                for (var i = 0; i < source.Length; i++)
                    action(source[i]);
        }

        /// Appends source to results
        public static T[] AppendTo<T>(T[] source, int sourcePos, int count, T[] results = null)
        {
            if (results == null)
            {
                var newResults = new T[count];
                if (count == 1)
                    newResults[0] = source[sourcePos];
                else
                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)
                        newResults[i] = source[j];
                return newResults;
            }

            var matchCount = results.Length;
            var appendedResults = new T[matchCount + count];
            if (matchCount == 1)
                appendedResults[0] = results[0];
            else
                Array.Copy(results, 0, appendedResults, 0, matchCount);

            if (count == 1)
                appendedResults[matchCount] = source[sourcePos];
            else
                Array.Copy(source, sourcePos, appendedResults, matchCount, count);

            return appendedResults;
        }

        private static R[] AppendTo<T, R>(T[] source, int sourcePos, int count, Func<T, R> map, R[] results = null)
        {
            if (results == null || results.Length == 0)
            {
                var newResults = new R[count];
                if (count == 1)
                    newResults[0] = map(source[sourcePos]);
                else
                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)
                        newResults[i] = map(source[j]);
                return newResults;
            }

            var oldResultsCount = results.Length;
            var appendedResults = new R[oldResultsCount + count];
            if (oldResultsCount == 1)
                appendedResults[0] = results[0];
            else
                Array.Copy(results, 0, appendedResults, 0, oldResultsCount);

            if (count == 1)
                appendedResults[oldResultsCount] = map(source[sourcePos]);
            else
            {
                for (int i = oldResultsCount, j = sourcePos; i < appendedResults.Length; ++i, ++j)
                    appendedResults[i] = map(source[j]);
            }

            return appendedResults;
        }

        private static R[] AppendTo<T, S, R>(T[] source, S state, int sourcePos, int count, Func<S, T, R> map, R[] results = null)
        {
            if (results == null || results.Length == 0)
            {
                var newResults = new R[count];
                if (count == 1)
                    newResults[0] = map(state, source[sourcePos]);
                else
                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)
                        newResults[i] = map(state, source[j]);
                return newResults;
            }

            var oldResultsCount = results.Length;
            var appendedResults = new R[oldResultsCount + count];
            if (oldResultsCount == 1)
                appendedResults[0] = results[0];
            else
                Array.Copy(results, 0, appendedResults, 0, oldResultsCount);

            if (count == 1)
                appendedResults[oldResultsCount] = map(state, source[sourcePos]);
            else
            {
                for (int i = oldResultsCount, j = sourcePos; i < appendedResults.Length; ++i, ++j)
                    appendedResults[i] = map(state, source[j]);
            }

            return appendedResults;
        }

        /// <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
        /// It returns source array and does Not create new one if all items match the condition.</summary>
        /// <typeparam name="T">Type of source items.</typeparam>
        /// <param name="source">If null, the null will be returned.</param>
        /// <param name="condition">Condition to keep items.</param>
        /// <returns>New array if some items are filter out. Empty array if all items are filtered out. Original array otherwise.</returns>
        public static T[] Match<T>(this T[] source, Func<T, bool> condition)
        {
            if (source == null || source.Length == 0)
                return source;

            if (source.Length == 1)
                return condition(source[0]) ? source : Empty<T>();

            if (source.Length == 2)
            {
                var condition0 = condition(source[0]);
                var condition1 = condition(source[1]);
                return condition0 && condition1 ? new[] { source[0], source[1] }
                    : condition0 ? new[] { source[0] }
                    : condition1 ? new[] { source[1] }
                    : Empty<T>();
            }

            var matchStart = 0;
            T[] matches = null;
            var matchFound = false;
            var i = 0;
            for (; i < source.Length; ++i)
                if (!(matchFound = condition(source[i])))
                {
                    // for accumulated matched items
                    if (i != 0 && i > matchStart)
                        matches = AppendTo(source, matchStart, i - matchStart, matches);
                    matchStart = i + 1; // guess the next match start will be after the non-matched item
                }

            // when last match was found but not all items are matched (hence matchStart != 0)
            if (matchFound && matchStart != 0)
                return AppendTo(source, matchStart, i - matchStart, matches);

            return matches ?? (matchStart != 0 ? Empty<T>() : source);
        }

        /// Match with the additional state to use in <paramref name="condition"/> to minimize the allocations in <paramref name="condition"/> lambda closure 
        public static T[] Match<T, S>(this T[] source, S state, Func<S, T, bool> condition)
        {
            if (source == null || source.Length == 0)
                return source;

            if (source.Length == 1)
                return condition(state, source[0]) ? source : Empty<T>();

            if (source.Length == 2)
            {
                var condition0 = condition(state, source[0]);
                var condition1 = condition(state, source[1]);
                return condition0 && condition1 ? new[] { source[0], source[1] }
                    : condition0 ? new[] { source[0] }
                    : condition1 ? new[] { source[1] }
                    : Empty<T>();
            }

            var matchStart = 0;
            T[] matches = null;
            var matchFound = false;
            var i = 0;
            for (; i < source.Length; ++i)
                if (!(matchFound = condition(state, source[i])))
                {
                    // for accumulated matched items
                    if (i != 0 && i > matchStart)
                        matches = AppendTo(source, matchStart, i - matchStart, matches);
                    matchStart = i + 1; // guess the next match start will be after the non-matched item
                }

            // when last match was found but not all items are matched (hence matchStart != 0)
            if (matchFound && matchStart != 0)
                return AppendTo(source, matchStart, i - matchStart, matches);

            return matches ?? (matchStart != 0 ? Empty<T>() : source);
        }

        /// <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
        /// It returns source array and does Not create new one if all items match the condition.</summary>
        /// <typeparam name="T">Type of source items.</typeparam> <typeparam name="R">Type of result items.</typeparam>
        /// <param name="source">If null, the null will be returned.</param>
        /// <param name="condition">Condition to keep items.</param> <param name="map">Converter from source to result item.</param>
        /// <returns>New array of result items.</returns>
        public static R[] Match<T, R>(this T[] source, Func<T, bool> condition, Func<T, R> map)
        {
            if (source == null)
                return null;

            if (source.Length == 0)
                return Empty<R>();

            if (source.Length == 1)
            {
                var item = source[0];
                return condition(item) ? new[] { map(item) } : Empty<R>();
            }

            if (source.Length == 2)
            {
                var condition0 = condition(source[0]);
                var condition1 = condition(source[1]);
                return condition0 && condition1 ? new[] { map(source[0]), map(source[1]) }
                    : condition0 ? new[] { map(source[0]) }
                    : condition1 ? new[] { map(source[1]) }
                    : Empty<R>();
            }

            var matchStart = 0;
            R[] matches = null;
            var matchFound = false;

            var i = 0;
            for (; i < source.Length; ++i)
                if (!(matchFound = condition(source[i])))
                {
                    // for accumulated matched items
                    if (i != 0 && i > matchStart)
                        matches = AppendTo(source, matchStart, i - matchStart, map, matches);
                    matchStart = i + 1; // guess the next match start will be after the non-matched item
                }

            // when last match was found but not all items are matched (hence matchStart != 0)
            if (matchFound && matchStart != 0)
                return AppendTo(source, matchStart, i - matchStart, map, matches);

            return matches ?? (matchStart == 0 ? AppendTo(source, 0, source.Length, map) : Empty<R>());
        }

        /// Match with the additional state to use in <paramref name="condition"/> and <paramref name="map"/> to minimize the allocations in <paramref name="condition"/> lambda closure 
        public static R[] Match<T, S, R>(this T[] source, S state, Func<S, T, bool> condition, Func<S, T, R> map)
        {
            if (source == null)
                return null;

            if (source.Length == 0)
                return Empty<R>();

            if (source.Length == 1)
            {
                var item = source[0];
                return condition(state, item) ? new[] { map(state, item) } : Empty<R>();
            }

            if (source.Length == 2)
            {
                var condition0 = condition(state, source[0]);
                var condition1 = condition(state, source[1]);
                return condition0 && condition1 ? new[] { map(state, source[0]), map(state, source[1]) }
                    : condition0 ? new[] { map(state, source[0]) }
                    : condition1 ? new[] { map(state, source[1]) }
                    : Empty<R>();
            }

            var matchStart = 0;
            R[] matches = null;
            var matchFound = false;

            var i = 0;
            for (; i < source.Length; ++i)
                if (!(matchFound = condition(state, source[i])))
                {
                    // for accumulated matched items
                    if (i != 0 && i > matchStart)
                        matches = AppendTo(source, state, matchStart, i - matchStart, map, matches);
                    matchStart = i + 1; // guess the next match start will be after the non-matched item
                }

            // when last match was found but not all items are matched (hence matchStart != 0)
            if (matchFound && matchStart != 0)
                return AppendTo(source, state, matchStart, i - matchStart, map, matches);

            return matches ?? (matchStart == 0 ? AppendTo(source, state, 0, source.Length, map) : Empty<R>());
        }

        /// <summary>Maps all items from source to result array.</summary>
        /// <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
        /// <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
        /// <returns>Converted items</returns>
        public static R[] Map<T, R>(this T[] source, Func<T, R> map)
        {
            if (source == null)
                return null;

            var sourceCount = source.Length;
            if (sourceCount == 0)
                return Empty<R>();

            if (sourceCount == 1)
                return new[] { map(source[0]) };

            if (sourceCount == 2)
                return new[] { map(source[0]), map(source[1]) };

            var results = new R[sourceCount];
            for (var i = 0; i < source.Length; i++)
                results[i] = map(source[i]);
            return results;
        }

        /// Map with additional state to use in <paramref name="map"/> to minimize allocations in <paramref name="map"/> lambda closure 
        public static R[] Map<T, S, R>(this T[] source, S state, Func<S, T, R> map)
        {
            if (source == null)
                return null;

            var sourceCount = source.Length;
            if (sourceCount == 0)
                return Empty<R>();

            if (sourceCount == 1)
                return new[] { map(state, source[0]) };

            if (sourceCount == 2)
                return new[] { map(state, source[0]), map(state, source[1]) };

            var results = new R[sourceCount];
            for (var i = 0; i < source.Length; i++)
                results[i] = map(state, source[i]);
            return results;
        }

        /// <summary>Maps all items from source to result collection. 
        /// If possible uses fast array Map otherwise Enumerable.Select.</summary>
        /// <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
        /// <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
        /// <returns>Converted items</returns>
        public static IEnumerable<R> Map<T, R>(this IEnumerable<T> source, Func<T, R> map) =>
            source is T[] arr ? arr.Map(map) : source?.Select(map);

        /// <summary>If <paramref name="source"/> is array uses more effective Match for array, otherwise just calls Where</summary>
        /// <typeparam name="T">Type of source items.</typeparam>
        /// <param name="source">If null, the null will be returned.</param>
        /// <param name="condition">Condition to keep items.</param>
        /// <returns>Result items, may be an array.</returns>
        public static IEnumerable<T> Match<T>(this IEnumerable<T> source, Func<T, bool> condition) =>
            source is T[] arr ? arr.Match(condition) : source?.Where(condition);

        /// <summary>If <paramref name="source"/> is array uses more effective Match for array,
        /// otherwise just calls Where, Select</summary>
        /// <typeparam name="T">Type of source items.</typeparam> <typeparam name="R">Type of result items.</typeparam>
        /// <param name="source">If null, the null will be returned.</param>
        /// <param name="condition">Condition to keep items.</param>  <param name="map">Converter from source to result item.</param>
        /// <returns>Result items, may be an array.</returns>
        public static IEnumerable<R> Match<T, R>(this IEnumerable<T> source, Func<T, bool> condition, Func<T, R> map) =>
            source is T[] arr ? arr.Match(condition, map) : source?.Where(condition).Select(map);
    }

    /// <summary>Wrapper that provides optimistic-concurrency Swap operation implemented using <see cref="Ref.Swap{T}"/>.</summary>
    /// <typeparam name="T">Type of object to wrap.</typeparam>
    public sealed class Ref<T> where T : class
    {
        /// <summary>Gets the wrapped value.</summary>
        public T Value => _value;

        /// <summary>Creates ref to object, optionally with initial value provided.</summary>
        /// <param name="initialValue">(optional) Initial value.</param>
        public Ref(T initialValue = default)
        {
            _value = initialValue;
        }

        /// <summary>Exchanges currently hold object with <paramref name="getNewValue"/> - see <see cref="Ref.Swap{T}"/> for details.</summary>
        /// <param name="getNewValue">Delegate to produce new object value from current one passed as parameter.</param>
        /// <returns>Returns old object value the same way as <see cref="Interlocked.Exchange(ref int,int)"/></returns>
        /// <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        public T Swap(Func<T, T> getNewValue) =>
            Ref.Swap(ref _value, getNewValue);

        /// Option without allocation for capturing `a` in closure of `getNewValue`
        public T Swap<A>(A a, Func<T, A, T> getNewValue) => Ref.Swap(ref _value, a, getNewValue);

        /// Option without allocation for capturing `a` and `b` in closure of `getNewValue`
        public T Swap<A, B>(A a, B b, Func<T, A, B, T> getNewValue) => Ref.Swap(ref _value, a, b, getNewValue);

        /// <summary>Just sets new value ignoring any intermingled changes.</summary>
        /// <param name="newValue"></param> <returns>old value</returns>
        public T Swap(T newValue) =>
            Interlocked.Exchange(ref _value, newValue);

        /// <summary>Compares current Referred value with <paramref name="currentValue"/> and if equal replaces current with <paramref name="newValue"/></summary>
        /// <param name="currentValue"></param> <param name="newValue"></param>
        /// <returns>True if current value was replaced with new value, and false if current value is outdated (already changed by other party).</returns>
        /// <example><c>[!CDATA[
        /// var value = SomeRef.Value;
        /// if (!SomeRef.TrySwapIfStillCurrent(value, Update(value))
        ///     SomeRef.Swap(v => Update(v)); // fallback to normal Swap with delegate allocation
        /// ]]</c></example>
        public bool TrySwapIfStillCurrent(T currentValue, T newValue) =>
            Interlocked.CompareExchange(ref _value, newValue, currentValue) == currentValue;

        private T _value;
    }

    /// <summary>Provides optimistic-concurrency consistent <see cref="Swap{T}"/> operation.</summary>
    public static class Ref
    {
        /// <summary>Factory for <see cref="Ref{T}"/> with type of value inference.</summary>
        /// <typeparam name="T">Type of value to wrap.</typeparam>
        /// <param name="value">Initial value to wrap.</param>
        /// <returns>New ref.</returns>
        public static Ref<T> Of<T>(T value) where T : class => new Ref<T>(value);

        /// <summary>Creates new ref to the value of original ref.</summary> <typeparam name="T">Ref value type.</typeparam>
        /// <param name="original">Original ref.</param> <returns>New ref to original value.</returns>
        public static Ref<T> NewRef<T>(this Ref<T> original) where T : class => Of(original.Value);

        /// <summary>First, it evaluates new value using <paramref name="getNewValue"/> function. 
        /// Second, it checks that original value is not changed. 
        /// If it is changed it will retry first step, otherwise it assigns new value and returns original (the one used for <paramref name="getNewValue"/>).</summary>
        /// <typeparam name="T">Type of value to swap.</typeparam>
        /// <param name="value">Reference to change to new value</param>
        /// <param name="getNewValue">Delegate to get value from old one.</param>
        /// <returns>Old/original value. By analogy with <see cref="Interlocked.Exchange(ref int,int)"/>.</returns>
        /// <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        [MethodImpl((MethodImplOptions)256)]
        public static T Swap<T>(ref T value, Func<T, T> getNewValue) where T : class
        {
            var retryCount = 0;
            while (true)
            {
                var oldValue = value;
                var newValue = getNewValue(oldValue);
                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)
                    return oldValue;
                if (++retryCount > RETRY_COUNT_UNTIL_THROW)
                    throw new InvalidOperationException(_errorRetryCountExceeded);

                // relinquishes the threads current time slice immediately, voluntarily handing over the CPU to other threads
                // todo: use Thread.Sleep from .NET 4.0 to relinquish only to threads running on the same processor
                //Thread.Sleep(0);
            }
        }

        /// Option without allocation for capturing `a` in closure of `getNewValue`
        [MethodImpl((MethodImplOptions)256)]
        public static T Swap<T, A>(ref T value, A a, Func<T, A, T> getNewValue) where T : class
        {
            var retryCount = 0;
            while (true)
            {
                var oldValue = value;
                var newValue = getNewValue(oldValue, a);
                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)
                    return oldValue;
                if (++retryCount > RETRY_COUNT_UNTIL_THROW)
                    throw new InvalidOperationException(_errorRetryCountExceeded);

                // relinquishes the threads current time slice immediately, voluntarily handing over the CPU to other threads
                // todo: use Thread.Sleep from .NET 4.0 to relinquish only to threads running on the same processor
                //Thread.Sleep(0);
            }
        }

        /// Option without allocation for capturing `a` and `b` in closure of `getNewValue`
        [MethodImpl((MethodImplOptions)256)]
        public static T Swap<T, A, B>(ref T value, A a, B b, Func<T, A, B, T> getNewValue) where T : class
        {
            var retryCount = 0;
            while (true)
            {
                var oldValue = value;
                var newValue = getNewValue(oldValue, a, b);
                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)
                    return oldValue;
                if (++retryCount > RETRY_COUNT_UNTIL_THROW)
                    throw new InvalidOperationException(_errorRetryCountExceeded);

                // relinquishes the threads current time slice immediately, voluntarily handing over the CPU to other threads
                // todo: use Thread.Sleep from .NET 4.0 to relinquish only to threads running on the same processor
                //Thread.Sleep(0);
            }
        }

        /// Option without allocation for capturing `a`, `b`, `c` in closure of `getNewValue`
        [MethodImpl((MethodImplOptions)256)]
        public static T Swap<T, A, B, C>(ref T value, A a, B b, C c, Func<T, A, B, C, T> getNewValue) where T : class
        {
            var retryCount = 0;
            while (true)
            {
                var oldValue = value;
                var newValue = getNewValue(oldValue, a, b, c);
                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)
                    return oldValue;
                if (++retryCount > RETRY_COUNT_UNTIL_THROW)
                    throw new InvalidOperationException(_errorRetryCountExceeded);

                // relinquishes the threads current time slice immediately, voluntarily handing over the CPU to other threads
                // todo: use Thread.Sleep from .NET 4.0 to relinquish only to threads running on the same processor
                //Thread.Sleep(0);
            }
        }

        private const int RETRY_COUNT_UNTIL_THROW = 50;

        private static readonly string _errorRetryCountExceeded =
            "Ref retried to Update for " + RETRY_COUNT_UNTIL_THROW +
            " times But there is always someone else intervened.";
    }

    /// <summary>Printable thing via provided printer </summary>
    public interface IPrintable
    {
        /// <summary>Print to the provided string builder via the provided printer.</summary>
        StringBuilder Print(StringBuilder s, Func<StringBuilder, object, StringBuilder> printer);
    }

    /// <summary>Produces good enough hash codes for the fields</summary>
    public static class Hasher
    {
        /// <summary>Combines hashes of two fields</summary>
        public static int Combine<T1, T2>(T1 a, T2 b) =>
            Combine(a?.GetHashCode() ?? 0, b?.GetHashCode() ?? 0);

        /// <summary>Inspired by System.Tuple.CombineHashCodes</summary>
        public static int Combine(int h1, int h2)
        {
            if (h1 == 0) return h2;
            unchecked
            {
                return (h1 << 5) + h1 ^ h2;
            }
        }
    }

    /// <summary>Immutable Key-Value pair. It is reference type (could be check for null), 
    /// which is different from System value type <see cref="KeyValuePair{TKey,TValue}"/>.
    /// In addition provides <see cref="Equals"/> and <see cref="GetHashCode"/> implementations.</summary>
    /// <typeparam name="K">Type of Key.</typeparam><typeparam name="V">Type of Value.</typeparam>
    public class KV<K, V> : IPrintable
    {
        /// <summary>Key.</summary>
        public readonly K Key;

        /// <summary>Value.</summary>
        public readonly V Value;

        /// <summary>Creates Key-Value object by providing key and value. Does Not check either one for null.</summary>
        /// <param name="key">key.</param><param name="value">value.</param>
        public KV(K key, V value)
        {
            Key = key;
            Value = value;
        }

        /// <inheritdoc />
        public StringBuilder Print(StringBuilder s, Func<StringBuilder, object, StringBuilder> printer) =>
            s.Append("(").To(b => Key == null ? b : printer(b, Key))
                .Append(", ").To(b => Value == null ? b : printer(b, Value))
                .Append(')');

        /// <summary>Creates nice string view.</summary><returns>String representation.</returns>
        public override string ToString() =>
            Print(new StringBuilder(), (s, x) => s.Append(x)).ToString();

        /// <summary>Returns true if both key and value are equal to corresponding key-value of other object.</summary>
        public override bool Equals(object obj)
        {
            var other = obj as KV<K, V>;
            return other != null
                   && (ReferenceEquals(other.Key, Key) || Equals(other.Key, Key))
                   && (ReferenceEquals(other.Value, Value) || Equals(other.Value, Value));
        }

        /// <summary>Combines key and value hash code</summary>
        public override int GetHashCode() => Hasher.Combine(Key, Value);
    }

    /// <summary>Helpers for <see cref="KV{K,V}"/>.</summary>
    public static class KV
    {
        /// <summary>Creates the key value pair.</summary>
        /// <typeparam name="K">Key type</typeparam> <typeparam name="V">Value type</typeparam>
        /// <param name="key">Key</param> <param name="value">Value</param> <returns>New pair.</returns>
        public static KV<K, V> Of<K, V>(K key, V value) => new KV<K, V>(key, value);
    }

    /// Simple helper for creation of the pair of two parts.
    public static class KeyValuePair
    {
        /// Pairs key with value.
        public static KeyValuePair<K, V> Pair<K, V>(this K key, V value) => new KeyValuePair<K, V>(key, value);
    }

    /// <summary>Helper structure which allows to distinguish null value from the default value for optional parameter.</summary>
    public struct Opt<T>
    {
        /// <summary>Allows to transparently convert parameter argument to opt structure.</summary>
        public static implicit operator Opt<T>(T value) => new Opt<T>(value);

        /// <summary>Argument value.</summary>
        public readonly T Value;

        /// <summary>Indicates that value is provided.</summary>
        public readonly bool HasValue;

        /// <summary>Wraps passed value in structure. Sets the flag that value is present.</summary>
        public Opt(T value)
        {
            HasValue = true;
            Value = value;
        }

        /// <summary>Helper to get value or default value if value is not present.</summary>
        public T OrDefault(T defaultValue = default) => HasValue ? Value : defaultValue;
    }

    /// <summary>Immutable list - simplest linked list with the Head and the Tail.</summary>
    public sealed class ImList<T>
    {
        /// <summary>Empty list to Push to.</summary>
        public static readonly ImList<T> Empty = new ImList<T>();

        /// <summary>True for empty list.</summary>
        public bool IsEmpty => Tail == null;

        /// <summary>First value in a list.</summary>
        public readonly T Head;

        /// <summary>The rest of values or Empty if list has a single value.</summary>
        public readonly ImList<T> Tail;

        /// <summary>Prepends new value and returns new list.</summary>
        public ImList<T> Push(T head) => new ImList<T>(head, this);

        /// <summary>Enumerates the list.</summary>
        public IEnumerable<T> Enumerate()
        {
            if (IsEmpty)
                yield break;
            for (var list = this; !list.IsEmpty; list = list.Tail)
                yield return list.Head;
        }

        /// <summary>String representation for debugging purposes</summary>
        public override string ToString() => IsEmpty
            ? "[]" : Tail.IsEmpty
            ? "[" + Head + "]" : Tail.Tail.IsEmpty
            ? "[" + Head + "," + Tail.Head + "]" : Tail.Tail.Tail.IsEmpty
            ? "[" + Head + "," + Tail.Head + "," + Tail.Tail.Head + "]"
            : "[" + Head + "," + Tail.Head + "," + Tail.Tail.Head + ", ...]";

        private ImList() { }

        private ImList(T head, ImList<T> tail)
        {
            Head = head;
            Tail = tail;
        }
    }

    /// <summary>Extension methods providing basic operations on a list.</summary>
    public static class ImList
    {
        /// Split list into (Head, Tail, IsEmpty) tuple
        public static void Deconstruct<T>(this ImList<T> list, out T head, out ImList<T> tail, out bool isEmpty)
        {
            head = list.Head;
            tail = list.Tail;
            isEmpty = list.IsEmpty;
        }

        /// Constructs from the parameter array of items
        public static ImList<T> List<T>(params T[] items)
        {
            var l = ImList<T>.Empty;
            if (!items.IsNullOrEmpty())
                for (var i = items.Length - 1; i >= 0; --i)
                    l = l.Push(items[i]);
            return l;
        }

        /// <summary>Constructs list of one element</summary>
        public static ImList<T> List<T>(this T head) => ImList<T>.Empty.Push(head);

        /// <summary>Constructs list from head and tail</summary>
        public static ImList<T> List<T>(this T head, ImList<T> tail) => tail.Push(head);

        /// <summary>Apples some effect action to each element</summary>
        public static void ForEach<T>(this ImList<T> list, Action<T> effect)
        {
            for (; !list.IsEmpty; list = list.Tail)
                effect(list.Head);
        }

        /// <summary>Fold list to a single value. The respective name for it in LINQ is Aggregate</summary>
        public static R Fold<T, R>(this ImList<T> list, R seed, Func<T, R, R> reduce)
        {
            if (list.IsEmpty)
                return seed;
            var result = seed;
            for (; !list.IsEmpty; list = list.Tail)
                result = reduce(list.Head, result);
            return result;
        }

        /// <summary>Fold list to a single value with index of item. The respective name for it in LINQ is Aggregate.</summary>
        public static R Fold<T, R>(this ImList<T> list, R seed, Func<T, int, R, R> reduce)
        {
            if (list.IsEmpty)
                return seed;
            var result = seed;
            for (var i = 0; !list.IsEmpty; list = list.Tail, ++i)
                result = reduce(list.Head, i, result);
            return result;
        }

        /// <summary>Returns new list in reverse order.</summary>
        public static ImList<T> Reverse<T>(this ImList<T> list) =>
            list.IsEmpty || list.Tail.IsEmpty ? list : list.Fold(ImList<T>.Empty, List);

        /// <summary>Maps the items from the first list to the result list.</summary>
        public static ImList<R> Map<T, R>(this ImList<T> list, Func<T, R> map) =>
            list.Fold(ImList<R>.Empty, (x, r) => List(map(x), r)).Reverse();

        /// <summary>Maps with index</summary>
        public static ImList<R> Map<T, R>(this ImList<T> list, Func<T, int, R> map) =>
            list.Fold(ImList<R>.Empty, (x, i, r) => List(map(x, i), r)).Reverse();

        /// <summary>Copies list to array.</summary>
        public static T[] ToArray<T>(this ImList<T> source) =>
            source.IsEmpty ? ArrayTools.Empty<T>()
            : source.Tail.IsEmpty ? new[] { source.Head } : source.Enumerate().ToArray();
    }

    /// Zipper is an immutable persistent data structure, to represent collection with single focused (selected, active) element.
    /// Consist of REVERSED `Left` immutable list, `Focus` element, and `Right` immutable list. That's why a Zipper name,
    /// where left and right part are joined in focus item.
    public sealed class ImZipper<T>
    {
        /// Empty singleton instance to start building your zipper
        public static readonly ImZipper<T> Empty = new ImZipper<T>();

        /// True is zipper does not contain items
        public bool IsEmpty => Count == 0;

        /// Index of Focus item, from `0` to `Count-1`
        public readonly int Index;

        /// Number of items
        public readonly int Count;

        /// Left REVERSED list, so the Head of the list is just prior the Focus item 
        public readonly ImList<T> Left;

        /// Right list, where Head is just after the Focus item
        public readonly ImList<T> Right;

        /// Single focus item
        public readonly T Focus;

        /// <inheritdoc />
        public override string ToString() =>
            IsEmpty ? "[||]" : Count + ":" + Left.Reverse() + "|" + Index + ":" + Focus + "|" + Right;

        /// Sets a new focus and pushes the old focus to the Left list. 
        public ImZipper<T> Append(T focus) => PushLeft(focus);

        /// Sets a new focus and pushes the old focus to the Left list.
        public ImZipper<T> PushLeft(T focus) =>
        IsEmpty ? new ImZipper<T>(ImList<T>.Empty, focus, 0, ImList<T>.Empty, 1)
                : new ImZipper<T>(Left.Push(Focus), focus, Index + 1, Right, Count + 1);

        /// Sets a new focus and pushes the old focus to the right list. 
        public ImZipper<T> Insert(T focus) => PushRight(focus);

        /// Sets a new focus and pushes the old focus to the right list. 
        public ImZipper<T> PushRight(T focus) =>
            IsEmpty ? new ImZipper<T>(ImList<T>.Empty, focus, 0, ImList<T>.Empty, 1)
                : new ImZipper<T>(Left, focus, Index, Right.Push(Focus), Count + 1);

        /// Removes a focus, filling the hole with the item from the left list, or from the right if the left is empty
        public ImZipper<T> PopLeft() =>
            IsEmpty ? this
            : Left.IsEmpty && Right.IsEmpty ? Empty
            : !Left.IsEmpty ? new ImZipper<T>(Left.Tail, Left.Head, Index - 1, Right, Count - 1)
            : new ImZipper<T>(Left, Right.Head, Index, Right.Tail, Count - 1);

        /// Removes a focus, filling the hole with the item from the right list, or from the left if the right is empty
        public ImZipper<T> PopRight() =>
            IsEmpty ? this
            : Left.IsEmpty && Right.IsEmpty ? Empty
            : !Right.IsEmpty ? new ImZipper<T>(Left, Right.Head, Index, Right.Tail, Count - 1)
            : new ImZipper<T>(Left.Tail, Left.Head, Index - 1, Right, Count - 1);

        /// Shifts focus one element to the left (decrementing its Index).
        public ImZipper<T> ShiftLeft() =>
            IsEmpty || Left.IsEmpty ? this
            : new ImZipper<T>(Left.Tail, Left.Head, Index - 1, Right.Push(Focus), Count);

        /// Shifts focus one element to the right (incrementing its Index).
        public ImZipper<T> ShiftRight() =>
            IsEmpty || Right.IsEmpty ? this
            : new ImZipper<T>(Left.Push(Focus), Right.Head, Index + 1, Right.Tail, Count);

        /// Sets a new focus and returns a new zipper with the left and right lists unchanged
        public ImZipper<T> WithFocus(T focus) =>
            IsEmpty ? this : new ImZipper<T>(Left, focus, Index, Right, Count);

        /// Maps over the zipper items producing a new zipper
        public ImZipper<R> Map<R>(Func<T, R> map) =>
            IsEmpty ? ImZipper<R>.Empty
                : new ImZipper<R>(Left.Reverse().Fold(ImList<R>.Empty, (x, r) => r.Push(map(x))),
                    map(Focus), Index, Right.Map(map), Count);

        /// Maps over the zipper items with item index, producing a new zipper
        public ImZipper<R> Map<R>(Func<T, int, R> map) =>
            IsEmpty ? ImZipper<R>.Empty
                : new ImZipper<R>(
                    Left.Reverse().Fold(ImList<R>.Empty, (x, i, r) => r.Push(map(x, i))),
                    map(Focus, Index), Index, Right.Map((x, i) => map(x, Index + 1 + i)), Count);

        private ImZipper() => Index = -1;

        private ImZipper(ImList<T> left, T focus, int index, ImList<T> right, int count)
        {
            Left = left;
            Focus = focus;
            Index = index;
            Right = right;
            Count = count;
        }
    }

    /// Other ImZipper methods
    public static class ImZipper
    {
        /// Appends array items to zipper
        public static ImZipper<T> Zip<T>(params T[] items)
        {
            if (items.IsNullOrEmpty())
                return ImZipper<T>.Empty;
            var z = ImZipper<T>.Empty;
            for (var i = 0; i < items.Length; ++i)
                z = z.PushLeft(items[i]);
            return z;
        }

        /// Converts to array.
        public static T[] ToArray<T>(this ImZipper<T> z)
        {
            if (z.IsEmpty)
                return ArrayTools.Empty<T>();
            var a = new T[z.Count];
            z.Fold(a, (x, i, xs) =>
            {
                xs[i] = x;
                return xs;
            });
            return a;
        }

        /// Shifts focus to a specified index, e.g. a random access
        public static ImZipper<T> ShiftTo<T>(this ImZipper<T> z, int i)
        {
            if (i < 0 || i >= z.Count || i == z.Index)
                return z;
            while (i < z.Index)
                z = z.ShiftLeft();
            while (i > z.Index)
                z = z.ShiftRight();
            return z;
        }

        /// Updates a focus element if it is present, otherwise does nothing.
        /// If the focus item is the equal one, then returns the same zipper back.
        public static ImZipper<T> Update<T>(this ImZipper<T> z, Func<T, T> update)
        {
            if (z.IsEmpty)
                return z;
            var result = update(z.Focus);
            if (ReferenceEquals(z.Focus, result) || result != null && result.Equals(z.Focus))
                return z;
            return z.WithFocus(result);
        }

        /// Update the item at random index, by shifting and updating it
        public static ImZipper<T> UpdateAt<T>(this ImZipper<T> z, int i, Func<T, T> update) =>
            i < 0 || i >= z.Count ? z : z.ShiftTo(i).Update(update);

        /// Update the item at random index, by shifting and updating it
        public static ImZipper<T> RemoveAt<T>(this ImZipper<T> z, int i) =>
            i < 0 || i >= z.Count ? z : z.ShiftTo(i).PopLeft();

        /// Folds zipper to a single value
        public static R Fold<T, R>(this ImZipper<T> z, R seed, Func<T, R, R> reduce) =>
            z.IsEmpty ? seed :
            z.Right.Fold(reduce(z.Focus, z.Left.Reverse().Fold(seed, reduce)), reduce);

        /// Folds zipper to a single value by using an item index
        public static R Fold<T, R>(this ImZipper<T> z, R seed, Func<T, int, R, R> reduce)
        {
            if (z.IsEmpty)
                return seed;
            var focusIndex = z.Index;
            var reducedLeft = z.Left.Reverse().Fold(seed, reduce);
            return z.Right.Fold(reduce(z.Focus, focusIndex, reducedLeft),
                (x, i, r) => reduce(x, focusIndex + i + 1, r));
        }

        /// <summary>Apply some effect action on each element</summary>
        public static void ForEach<T>(this ImZipper<T> z, Action<T> effect)
        {
            if (!z.IsEmpty)
            {
                if (!z.Left.IsEmpty)
                    z.Left.Reverse().ForEach(effect);
                effect(z.Focus);
                if (!z.Right.IsEmpty)
                    z.Right.ForEach(effect);
            }
        }
    }

    /// Given the old value should and the new value should return result updated value.
    public delegate V Update<V>(V oldValue, V newValue);

    /// Update handler including the key
    public delegate V Update<K, V>(K key, V oldValue, V newValue);

    /// <summary>Immutable http://en.wikipedia.org/wiki/AVL_tree with integer keys and <typeparamref name="V"/> values.</summary>
    public sealed class ImMap<V>
    {
        /// <summary>Empty tree to start with.</summary>
        public static readonly ImMap<V> Empty = new ImMap<V>();

        /// <summary>Key.</summary>
        public readonly int Key;

        /// <summary>Value.</summary>
        public readonly V Value;

        /// <summary>Left sub-tree/branch, or empty.</summary>
        public readonly ImMap<V> Left;

        /// <summary>Right sub-tree/branch, or empty.</summary>
        public readonly ImMap<V> Right;

        /// <summary>Height of the longest sub-tree/branch. It is 0 for empty tree, and 1 for single node tree.</summary>
        public readonly int Height;

        /// <summary>Returns true is tree is empty.</summary>
        public bool IsEmpty => Height == 0;

        /// Adds or updates the value by key in the map, if not updated returns the same map
        [MethodImpl((MethodImplOptions)256)]
        public ImMap<V> AddOrUpdate(int key, V value)
        {
            if (Height == 0)
                return new ImMap<V>(key, value);

            var map = this;
            do
            {
                if (map.Key == key)
                {
                    var mapValue = map.Value;
                    if (ReferenceEquals(value, mapValue) || value?.Equals(mapValue) == true)
                        return this;
                    return UpdateImpl(key, value);
                }

                map = key < map.Key ? map.Left : map.Right;
            } while (map.Height != 0);

            return AddImpl(key, value);
        }

        /// Adds or updates the value by key in the map, if not updated returns the same map
        [MethodImpl((MethodImplOptions)256)]
        public ImMap<V> AddOrUpdate(int key, V value,
            out bool isUpdated, out V oldValue, Update<int, V> update = null)
        {
            isUpdated = false;
            oldValue = default;

            if (Height == 0)
                return new ImMap<V>(key, value);

            var map = this;
            do
            {
                if (map.Key == key)
                {
                    oldValue = map.Value;
                    if (update != null)
                        value = update(key, oldValue, value);

                    if (ReferenceEquals(value, oldValue) || value?.Equals(oldValue) == true)
                        return this;

                    isUpdated = true;
                    return UpdateImpl(key, value);
                }

                map = key < map.Key ? map.Left : map.Right;
            } while (map.Height != 0);

            return AddImpl(key, value);
        }

        /// Combines TryFind and Add methods returning either found value by key or adding key-value to the new tree and returning it instead
        [MethodImpl((MethodImplOptions)256)]
        public bool GetOrAdd(int key, V value, out V foundValue, out ImMap<V> newMap)
        {
            if (Height == 0)
            {
                foundValue = default;
                newMap = new ImMap<V>(key, value);
                return false;
            }

            var map = this;
            do
            {
                if (map.Key == key)
                {
                    newMap = null;
                    foundValue = map.Value;
                    return true;
                }

                map = key < map.Key ? map.Left : map.Right;
            } while (map.Height != 0);


            foundValue = default;
            newMap = AddImpl(key, value);
            return false;
        }

        /// <summary>Returns new tree with added or updated value for specified key.</summary>
        /// <param name="key">Key</param> <param name="value">Value</param>
        /// <param name="updateValue">(optional) Delegate to calculate new value from and old and a new value.</param>
        /// <returns>New tree.</returns>
        [MethodImpl((MethodImplOptions)256)]
        public ImMap<V> AddOrUpdate(int key, V value, Update<V> updateValue)
        {
            if (Height == 0)
                return new ImMap<V>(key, value);

            var map = this;
            do
            {
                if (map.Key == key)
                {
                    var oldValue = map.Value;
                    value = updateValue(oldValue, value);
                    if (ReferenceEquals(value, oldValue) || oldValue?.Equals(Value) == true)
                        return this;
                    return UpdateImpl(key, value);
                }

                map = key < map.Key ? map.Left : map.Right;
            } while (map.Height != 0);

            return AddImpl(key, value);
        }

        /// <summary>Returns new tree with updated value for the key, Or the same tree if key was not found.</summary>
        /// <param name="key"></param> <param name="value"></param>
        /// <returns>New tree if key is found, or the same tree otherwise.</returns>
        [MethodImpl((MethodImplOptions)256)]
        public ImMap<V> Update(int key, V value)
        {
            if (Height != 0)
            {
                var map = this;
                do
                {
                    if (map.Key == key)
                        return ReferenceEquals(value, Value) || value?.Equals(Value) == true
                            ? this
                            : UpdateImpl(key, value);

                    map = key < map.Key ? map.Left : map.Right;
                } while (map.Height != 0);
            }

            return this;
        }

        private ImMap<V> AddImpl(int key, V value)
        {
            // todo: maybe ordered by most frequent operation first, and then split by key to left or to right
            // if (Height > 2) {}
            // if (Height == 2) {}
            // if (Height == 1) {}

            if (key < Key)
            {
                // this is a leaf node - just adding then to the left, the new height will be 2, no balance needed
                if (Height == 1)
                    return new ImMap<V>(Key, Value, new ImMap<V>(key, value), Empty, 2);

                // left is empty - in balanced tree it means that right is the leaf node, adding to the left, the height will remain 2, no balance needed
                if (Left.Height == 0)
                    return new ImMap<V>(Key, Value, new ImMap<V>(key, value), Right, 2);

                // we will add the node on the left:
                //      5
                //   2     ?
                //       ?   ?
                var left = Left;
                if (left.Height == 1)
                {
                    //     5
                    //  2
                    if (Right.Height == 0)
                    {
                        // single rotation:
                        //           5     =>     2
                        //        2        new:1     5
                        // new:1                     
                        if (key < left.Key)
                            return new ImMap<V>(left.Key, left.Value,
                                new ImMap<V>(key, value), new ImMap<V>(Key, Value), 2);

                        // double rotation in a one swoop:
                        //      5     =>     5     =>     4
                        //   2            4            2     5
                        //     4        2                     
                        return new ImMap<V>(key, value,
                            new ImMap<V>(left.Key, left.Value), new ImMap<V>(Key, Value), 2);
                    }

                    // no need to balance here, just to left-left or to left-right
                    //       5
                    //    2     8
                    //        ?   ?
                    left = key < left.Key
                        ? new ImMap<V>(left.Key, left.Value, new ImMap<V>(key, value), Empty, 2)
                        : new ImMap<V>(left.Key, left.Value, Empty, new ImMap<V>(key, value), 2);
                }
                else
                {
                    left = left.AddImpl(key, value);
                }

                // left is longer by 2, rotate left
                if (left.Height > Right.Height + 1)
                {
                    var leftLeft = left.Left;
                    var leftRight = left.Right;

                    // single rotation:
                    //      5     =>     2
                    //   2     6      1     5
                    // 1   4              4   6
                    if (leftLeft.Height >= leftRight.Height)
                        return new ImMap<V>(left.Key, left.Value,
                            leftLeft, new ImMap<V>(Key, Value, leftRight, Right));

                    // double rotation:
                    //      5     =>     5     =>     4
                    //   2     6      4     6      2     5
                    // 1   4        2   3        1   3     6
                    //    3        1
                    return new ImMap<V>(leftRight.Key, leftRight.Value,
                        new ImMap<V>(left.Key, left.Value, leftLeft, leftRight.Left),
                        new ImMap<V>(Key, Value, leftRight.Right, Right));
                }

                return new ImMap<V>(Key, Value, left, Right);
            }
            else
            {
                if (Height == 1)
                    return new ImMap<V>(Key, Value, Empty, new ImMap<V>(key, value), 2);

                if (Right.Height == 0)
                    return new ImMap<V>(Key, Value, Left, new ImMap<V>(key, value), 2);

                var right = Right;
                if (right.Height == 1)
                {
                    if (Left.Height == 0)
                    {
                        // double rotation:
                        //    5     =>   5     =>     6
                        //       8          6      5     8
                        //      6            8
                        if (key < right.Key)
                            return new ImMap<V>(key, value,
                                new ImMap<V>(Key, Value), new ImMap<V>(right.Key, right.Value), 2);

                        // single rotation:
                        //    5     =>    6
                        //      6      5     8
                        //       8
                        return new ImMap<V>(right.Key, right.Value,
                            new ImMap<V>(Key, Value), new ImMap<V>(key, value), 2);
                    }

                    right = key < right.Key
                        ? new ImMap<V>(right.Key, right.Value, new ImMap<V>(key, value), Empty, 2)
                        : new ImMap<V>(right.Key, right.Value, Empty, new ImMap<V>(key, value), 2);
                }
                else
                {
                    right = right.AddImpl(key, value);
                }

                if (right.Height > Left.Height + 1)
                {
                    var rightLeft = right.Left;
                    var rightRight = right.Right;

                    if (rightRight.Height >= rightLeft.Height)
                        return new ImMap<V>(right.Key, right.Value,
                            new ImMap<V>(Key, Value, Left, rightLeft), rightRight);

                    return new ImMap<V>(rightLeft.Key, rightLeft.Value,
                        new ImMap<V>(Key, Value, Left, rightLeft.Left),
                        new ImMap<V>(right.Key, right.Value, rightLeft.Right, rightRight));
                }

                return new ImMap<V>(Key, Value, Left, right);
            }
        }

        private ImMap<V> UpdateImpl(int key, V value)
        {
            if (key < Key)
                return new ImMap<V>(Key, Value, Left.UpdateImpl(key, value), Right, Height);

            if (key > Key)
                return new ImMap<V>(Key, Value, Left, Right.UpdateImpl(key, value), Height);

            return new ImMap<V>(key, value, Left, Right, Height);
        }

        // todo: Leak, cause returned ImMap references left and right sub-trees - replace with `KeyValuePair`
        /// <summary>Returns all sub-trees enumerated from left to right.</summary> 
        /// <returns>Enumerated sub-trees or empty if tree is empty.</returns>
        public IEnumerable<ImMap<V>> Enumerate()
        {
            if (Height == 0)
                yield break;

            var parents = new ImMap<V>[Height];

            var node = this;
            var parentCount = -1;
            while (node.Height != 0 || parentCount != -1)
            {
                if (node.Height != 0)
                {
                    parents[++parentCount] = node;
                    node = node.Left;
                }
                else
                {
                    node = parents[parentCount--];
                    yield return node;
                    node = node.Right;
                }
            }
        }

        /// <summary>Removes or updates value for specified key, or does nothing if key is not found.
        /// Based on Eric Lippert http://blogs.msdn.com/b/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx </summary>
        /// <param name="key">Key to look for.</param> 
        /// <returns>New tree with removed or updated value.</returns>
        [MethodImpl((MethodImplOptions)256)]
        public ImMap<V> Remove(int key)
        {
            if (Height == 0)
                return this;

            if (key == Key) // we've found the node to remove
            {
                if (Height == 1) // remove the leaf node
                    return Empty;

                // if we have the on child remaining then just return it
                if (Right.Height == 0)
                    return Left;

                if (Left.Height == 0)
                    return Right;

                // we have two children,
                // so remove the next highest node and replace this node with it.
                var successor = Right;
                while (successor.Left.Height != 0)
                    successor = successor.Left;
                return new ImMap<V>(successor.Key, successor.Value,
                    Left, Right.Remove(successor.Key));
            }

            // remove the node and balance the new tree
            return key < Key
                ? Balance(Key, Value, Left.Remove(key), Right)
                : Balance(Key, Value, Left, Right.Remove(key));
        }

        /// <summary>Outputs key value pair</summary>
        public override string ToString() => IsEmpty ? "empty" : Key + ":" + Value;

        internal ImMap() { }

        internal ImMap(int key, V value)
        {
            Key = key;
            Value = value;
            Left = Empty;
            Right = Empty;
            Height = 1;
        }

        internal ImMap(int key, V value, ImMap<V> left, ImMap<V> right, int height)
        {
            Key = key;
            Value = value;
            Left = left;
            Right = right;
            Height = height;
        }

        internal ImMap(int key, V value, ImMap<V> left, ImMap<V> right)
        {
            Key = key;
            Value = value;
            Left = left;
            Right = right;
            Height = left.Height > right.Height ? left.Height + 1 : right.Height + 1;
        }

        internal static ImMap<V> Balance(int key, V value, ImMap<V> left, ImMap<V> right)
        {
            var delta = left.Height - right.Height;
            if (delta > 1) // left is longer by 2, rotate left
            {
                var leftLeft = left.Left;
                var leftRight = left.Right;
                if (leftRight.Height > leftLeft.Height)
                {
                    // double rotation:
                    //      5     =>     5     =>     4
                    //   2     6      4     6      2     5
                    // 1   4        2   3        1   3     6
                    //    3        1
                    return new ImMap<V>(leftRight.Key, leftRight.Value,
                        new ImMap<V>(left.Key, left.Value, leftLeft, leftRight.Left),
                        new ImMap<V>(key, value, leftRight.Right, right));
                }

                // single rotation:
                //      5     =>     2
                //   2     6      1     5
                // 1   4              4   6
                return new ImMap<V>(left.Key, left.Value,
                    leftLeft,
                    new ImMap<V>(key, value, leftRight, right));
            }

            if (delta < -1)
            {
                var rightLeft = right.Left;
                var rightRight = right.Right;
                if (rightLeft.Height > rightRight.Height)
                {
                    return new ImMap<V>(rightLeft.Key, rightLeft.Value,
                        new ImMap<V>(key, value, left, rightLeft.Left),
                        new ImMap<V>(right.Key, right.Value, rightLeft.Right, rightRight));
                }

                return new ImMap<V>(right.Key, right.Value,
                    new ImMap<V>(key, value, left, rightLeft),
                    rightRight);
            }

            return new ImMap<V>(key, value, left, right);
        }
    }

    /// ImMap methods
    public static class ImMap
    {
        internal static V IgnoreKey<K, V>(this Update<V> u, K _, V ov, V nv) => u(ov, nv);

        /// Get value for found key or the default value otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<V>(this ImMap<V> map, int key)
        {
            while (map.Height != 0 && map.Key != key)
                map = key < map.Key ? map.Left : map.Right;
            return map.Value; // that's fine to return the value without check, because for we have a default value in empty map
        }

        /// Get value for found key or the specified default value otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<V>(this ImMap<V> map, int key, V defaultValue)
        {
            while (map.Height != 0 && map.Key != key)
                map = key < map.Key ? map.Left : map.Right;
            return map.Height != 0 ? map.Value : defaultValue;
        }

        /// Returns true if key is found and sets the value.
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<V>(this ImMap<V> map, int key, out V value)
        {
            while (map.Height != 0)
            {
                if (key < map.Key)
                    map = map.Left;
                else if (key > map.Key)
                    map = map.Right;
                else
                    break;
            }

            value = map.Value;
            return map.Height != 0;
        }
    }

    /// <summary>Immutable http://en.wikipedia.org/wiki/AVL_tree 
    /// where node key is the hash code of <typeparamref name="K"/>.</summary>
    public sealed class ImHashMap<K, V>
    {
        /// <summary>Empty tree to start with.</summary>
        public static readonly ImHashMap<K, V> Empty = new ImHashMap<K, V>();

        /// <summary>Calculated key hash.</summary>
        public int Hash
        {
            [MethodImpl((MethodImplOptions)256)]
            get => _data.Hash;
        }

        /// <summary>Key of type K that should support <see cref="object.Equals(object)"/> and <see cref="object.GetHashCode"/>.</summary>
        public K Key
        {
            [MethodImpl((MethodImplOptions)256)]
            get => _data.Key;
        }

        /// <summary>Value of any type V.</summary>
        public V Value
        {
            [MethodImpl((MethodImplOptions)256)]
            get => _data.Value;
        }

        /// <summary>In case of <see cref="Hash"/> conflicts for different keys contains conflicted keys with their values.</summary>
        public KV<K, V>[] Conflicts
        {
            [MethodImpl((MethodImplOptions)256)]
            get => _data.Conflicts;
        }

        /// <summary>Left sub-tree/branch, or empty.</summary>
        public readonly ImHashMap<K, V> Left;

        /// <summary>Right sub-tree/branch, or empty.</summary>
        public readonly ImHashMap<K, V> Right;

        /// <summary>Height of longest sub-tree/branch plus 1. It is 0 for empty tree, and 1 for single node tree.</summary>
        public readonly int Height;

        /// <summary>Returns true if tree is empty.</summary>
        public bool IsEmpty => Height == 0;

        /// <summary>Returns new tree with added key-value. 
        /// If value with the same key is exist then the value is replaced.</summary>
        /// <param name="key">Key to add.</param><param name="value">Value to add.</param>
        /// <returns>New tree with added or updated key-value.</returns>
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrUpdate(K key, V value) =>
            AddOrUpdate(key, value, out _, out _);

        /// <summary>Returns new tree with added key-value. If value with the same key is exist, then
        /// if <paramref name="update"/> is not specified: then existing value will be replaced by <paramref name="value"/>;
        /// if <paramref name="update"/> is specified: then update delegate will decide what value to keep.</summary>
        /// <param name="key">Key to add.</param><param name="value">Value to add.</param>
        /// <param name="update">Update handler.</param>
        /// <returns>New tree with added or updated key-value.</returns>
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrUpdate(K key, V value, Update<V> update) =>
            AddOrUpdate(key, value, out _, out _, update.IgnoreKey);

        /// Allocation free for `update` delegate with key
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrUpdate(K key, V value, out bool isUpdated, out V oldValue, Update<K, V> update = null)
        {
            isUpdated = false;
            oldValue = default;

            var hash = key.GetHashCode();

            if (Height == 0)
                return new ImHashMap<K, V>(new Data(hash, key, value));

            if (hash == Hash)
                return ReferenceEquals(Key, key) || Key.Equals(key)
                    ? UpdatedOrOld(hash, key, value, ref isUpdated, ref oldValue, update)
                    : UpdateValueAndResolveConflicts(key, value, ref isUpdated, ref oldValue, update);

            return AddOrUpdateImpl(hash, key, value, ref isUpdated, ref oldValue, update);
        }

        /// <summary>Looks for <paramref name="key"/> and replaces its value with new <paramref name="value"/>, or 
        /// runs custom update handler (<paramref name="update"/>) with old and new value to get the updated result.</summary>
        /// <param name="key">Key to look for.</param>
        /// <param name="value">New value to replace key value with.</param>
        /// <param name="update">(optional) Delegate for custom update logic, it gets old and new <paramref name="value"/>
        /// as inputs and should return updated value as output.</param>
        /// <returns>New tree with updated value or the SAME tree if no key found.</returns>
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> Update(K key, V value, Update<V> update = null) =>
            Update(key.GetHashCode(), key, value, update);

        /// <summary>Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
        /// The only difference is using fixed size array instead of stack for speed-up (~20% faster than stack).</summary>
        /// <returns>Sequence of enumerated key value pairs.</returns>
        public IEnumerable<KV<K, V>> Enumerate()
        {
            if (Height == 0)
                yield break;

            var parents = new ImHashMap<K, V>[Height];

            var node = this;
            var parentCount = -1;
            while (node.Height != 0 || parentCount != -1)
            {
                if (node.Height != 0)
                {
                    parents[++parentCount] = node;
                    node = node.Left;
                }
                else
                {
                    node = parents[parentCount--];
                    yield return new KV<K, V>(node.Key, node.Value);

                    if (node.Conflicts != null)
                        for (var i = 0; i < node.Conflicts.Length; i++)
                            yield return node.Conflicts[i];

                    node = node.Right;
                }
            }
        }

        /// <summary>Removes or updates value for specified key, or does nothing if key is not found.
        /// Based on Eric Lippert http://blogs.msdn.com/b/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx </summary>
        /// <param name="key">Key to look for.</param> 
        /// <returns>New tree with removed or updated value.</returns>
        public ImHashMap<K, V> Remove(K key) =>
            Remove(key.GetHashCode(), key);

        /// <summary>Outputs key value pair</summary>
        public override string ToString() => IsEmpty ? "empty" : (Key + ":" + Value);

        #region Implementation

        private sealed class Data
        {
            public readonly int Hash;
            public readonly K Key;
            public readonly V Value;
            public readonly KV<K, V>[] Conflicts;

            public Data() { }

            public Data(int hash, K key, V value, KV<K, V>[] conflicts = null)
            {
                Hash = hash;
                Key = key;
                Value = value;
                Conflicts = conflicts;
            }
        }

        private readonly Data _data;

        private ImHashMap()
        {
            _data = new Data();
        }

        private ImHashMap(Data data)
        {
            _data = data;
            Left = Empty;
            Right = Empty;
            Height = 1;
        }

        private ImHashMap(Data data, ImHashMap<K, V> left, ImHashMap<K, V> right)
        {
            _data = data;
            Left = left;
            Right = right;
            Height = 1 + (left.Height > right.Height ? left.Height : right.Height);
        }

        private ImHashMap(Data data, ImHashMap<K, V> left, ImHashMap<K, V> right, int height)
        {
            _data = data;
            Left = left;
            Right = right;
            Height = height;
        }

        private ImHashMap<K, V> AddOrUpdateImpl(int hash, K key, V value,
            ref bool isUpdated, ref V oldValue, Update<K, V> update = null)
        {
            if (hash < Hash)
            {
                if (Height == 1)
                    return new ImHashMap<K, V>(_data, new ImHashMap<K, V>(new Data(hash, key, value)), Empty, 2);

                var left = Left;
                if (left.Height == 0)
                    return new ImHashMap<K, V>(_data, new ImHashMap<K, V>(new Data(hash, key, value)), Right, 2);

                if (left.Hash == hash)
                {
                    var updatedLeft = ReferenceEquals(left.Key, key) || left.Key.Equals(key)
                        ? left.UpdatedOrOld(hash, key, value, ref isUpdated, ref oldValue, update)
                        : left.UpdateValueAndResolveConflicts(key, value, ref isUpdated, ref oldValue, update);

                    // if not updated - return this, otherwise add updated left and keep the height
                    return updatedLeft == left ? this : new ImHashMap<K, V>(_data, updatedLeft, Right, Height);
                }

                if (left.Height == 1)
                {
                    if (Right.Height == 0)
                    {
                        // single rotation:
                        //      5     =>     2
                        //   2            1     5
                        // 1                     
                        if (hash < left.Hash)
                            return new ImHashMap<K, V>(left._data,
                                new ImHashMap<K, V>(new Data(hash, key, value)), new ImHashMap<K, V>(_data), 2);

                        // double rotation:
                        //      5     =>     5     =>     4
                        //   2            4            2     5
                        //     4        2                     
                        return new ImHashMap<K, V>(new Data(hash, key, value),
                            new ImHashMap<K, V>(left._data), new ImHashMap<K, V>(_data), 2);
                    }

                    if (hash < left.Hash)
                        left = new ImHashMap<K, V>(left._data,
                            new ImHashMap<K, V>(new Data(hash, key, value)), Empty, 2);
                    else
                        left = new ImHashMap<K, V>(left._data,
                            Empty, new ImHashMap<K, V>(new Data(hash, key, value)), 2);
                }
                else
                {
                    var oldLeft = left;
                    left = left.AddOrUpdateImpl(hash, key, value, ref isUpdated, ref oldValue, update);
                    if (oldLeft == left)
                        return this;
                }

                if (left.Height > Right.Height + 1) // left is longer by 2, rotate left
                {
                    var leftLeft = left.Left;
                    var leftRight = left.Right;

                    // double rotation:
                    //      5     =>     5     =>     4
                    //   2     6      4     6      2     5
                    // 1   4        2   3        1   3     6
                    //    3        1
                    if (leftRight.Height > leftLeft.Height)
                        return new ImHashMap<K, V>(leftRight._data,
                            new ImHashMap<K, V>(left._data, leftLeft, leftRight.Left),
                            new ImHashMap<K, V>(_data, leftRight.Right, Right));

                    // single rotation:
                    //      5     =>     2
                    //   2     6      1     5
                    // 1   4              4   6
                    return new ImHashMap<K, V>(left._data,
                        leftLeft, new ImHashMap<K, V>(_data, leftRight, Right));
                }

                return new ImHashMap<K, V>(_data, left, Right);
            }
            else
            {
                if (Height == 1)
                    return new ImHashMap<K, V>(_data, Empty, new ImHashMap<K, V>(new Data(hash, key, value)), 2);

                var right = Right;
                if (right.Height == 0)
                    return new ImHashMap<K, V>(_data, Left, new ImHashMap<K, V>(new Data(hash, key, value)), 2);

                if (right.Hash == hash)
                {
                    var updatedRight = ReferenceEquals(right.Key, key) || right.Key.Equals(key)
                        ? right.UpdatedOrOld(hash, key, value, ref isUpdated, ref oldValue, update)
                        : right.UpdateValueAndResolveConflicts(key, value, ref isUpdated, ref oldValue, update);

                    // if not updated - return this, otherwise add updated left and keep the height
                    return updatedRight == right ? this : new ImHashMap<K, V>(_data, Left, updatedRight, Height);
                }

                if (right.Height == 1)
                {
                    if (Left.Height == 0)
                    {
                        // double rotation:
                        //    5     =>   5     =>     6
                        //       8          6      5     8
                        //      6            8
                        if (hash < right.Hash)
                            return new ImHashMap<K, V>(new Data(hash, key, value),
                                new ImHashMap<K, V>(_data), new ImHashMap<K, V>(right._data), 2);

                        // single rotation:
                        //    5     =>    6
                        //      6      5     8
                        //       8
                        return new ImHashMap<K, V>(right._data,
                            new ImHashMap<K, V>(_data), new ImHashMap<K, V>(new Data(hash, key, value)), 2);
                    }

                    if (hash < right.Hash)
                        right = new ImHashMap<K, V>(right._data,
                            new ImHashMap<K, V>(new Data(hash, key, value)), Empty, 2);
                    else
                        right = new ImHashMap<K, V>(right._data,
                            Empty, new ImHashMap<K, V>(new Data(hash, key, value)), 2);
                }
                else
                {
                    var oldRight = right;
                    right = right.AddOrUpdateImpl(hash, key, value, ref isUpdated, ref oldValue, update);
                    if (oldRight == right)
                        return this;
                }

                if (right.Height > Left.Height + 1)
                {
                    var rightLeft = right.Left;
                    var rightRight = right.Right;
                    if (rightLeft.Height > rightRight.Height)
                        return new ImHashMap<K, V>(rightLeft._data,
                            new ImHashMap<K, V>(_data, Left, rightLeft.Left),
                            new ImHashMap<K, V>(right._data, rightLeft.Right, rightRight));

                    return new ImHashMap<K, V>(right._data,
                        new ImHashMap<K, V>(_data, Left, rightLeft), rightRight);
                }

                return new ImHashMap<K, V>(_data, Left, right);
            }
        }

        private ImHashMap<K, V> UpdatedOrOld(int hash, K key, V value, ref bool isUpdated, ref V oldValue, Update<K, V> update = null)
        {
            if (update != null)
                value = update(key, Value, value);
            if (ReferenceEquals(value, Value) || value?.Equals(Value) == true)
                return this;
            isUpdated = true;
            oldValue = Value;
            return new ImHashMap<K, V>(new Data(hash, key, value, Conflicts), Left, Right);
        }

        /// It is fine, made public for testing.
        public ImHashMap<K, V> Update(int hash, K key, V value, Update<V> update = null)
        {
            if (Height == 0)
                return this;

            if (hash == Hash)
            {
                if (ReferenceEquals(Key, key) || Key.Equals(key))
                {
                    if (update != null)
                        value = update(Value, value);
                    return new ImHashMap<K, V>(new Data(hash, key, value, Conflicts), Left, Right);
                }

                var isUpdated = false;
                var oldValue = default(V);
                return UpdateValueAndResolveConflicts(key, value, ref isUpdated, ref oldValue,
                    update == null ? (Update<K, V>)null : (k, v, nv) => update(v, nv),
                    true);
            }

            // No need to balance cause we not adding or removing nodes
            if (hash < Hash)
            {
                var left = Left.Update(hash, key, value, update);
                return left == Left ? this : new ImHashMap<K, V>(_data, left, Right);
            }
            else
            {
                var right = Right.Update(hash, key, value, update);
                return right == Right ? this : new ImHashMap<K, V>(_data, Left, right);
            }
        }

        private ImHashMap<K, V> UpdateValueAndResolveConflicts(
            K key, V value, ref bool isUpdated, ref V oldValue, Update<K, V> update = null, bool updateOnly = false)
        {
            if (Conflicts == null) // add only if updateOnly is false.
                return updateOnly
                    ? this
                    : new ImHashMap<K, V>(new Data(Hash, Key, Value, new[] { new KV<K, V>(key, value) }), Left, Right);

            var found = Conflicts.Length - 1;
            while (found >= 0 && !Equals(Conflicts[found].Key, Key)) --found;
            if (found == -1)
            {
                if (updateOnly)
                    return this;
                var newConflicts = new KV<K, V>[Conflicts.Length + 1];
                Array.Copy(Conflicts, 0, newConflicts, 0, Conflicts.Length);
                newConflicts[Conflicts.Length] = new KV<K, V>(key, value);
                return new ImHashMap<K, V>(new Data(Hash, Key, Value, newConflicts), Left, Right);
            }

            var conflicts = new KV<K, V>[Conflicts.Length];
            Array.Copy(Conflicts, 0, conflicts, 0, Conflicts.Length);

            if (update != null)
                value = update(key, Conflicts[found].Value, value);
            if (ReferenceEquals(value, Value) || value?.Equals(Value) == true)
                return this;

            isUpdated = true;
            oldValue = conflicts[found].Value;
            conflicts[found] = new KV<K, V>(key, value);
            return new ImHashMap<K, V>(new Data(Hash, Key, Value, conflicts), Left, Right);
        }

        /// It is fine to be public.
        public V GetConflictedValueOrDefault(K key, V defaultValue)
        {
            if (Conflicts != null)
                for (var i = Conflicts.Length - 1; i >= 0; --i)
                    if (Equals(Conflicts[i].Key, key))
                        return Conflicts[i].Value;
            return defaultValue;
        }

        /// Does it
        public bool TryFindConflictedValue(K key, out V value)
        {
            if (Conflicts != null)
                for (var i = Conflicts.Length - 1; i >= 0; --i)
                    if (Equals(Conflicts[i].Key, key))
                    {
                        value = Conflicts[i].Value;
                        return true;
                    }

            value = default;
            return false;
        }

        private static ImHashMap<K, V> Balance(Data data, ImHashMap<K, V> left, ImHashMap<K, V> right)
        {
            var delta = left.Height - right.Height;
            if (delta > 1) // left is longer by 2, rotate left
            {
                var leftLeft = left.Left;
                var leftRight = left.Right;
                if (leftRight.Height > leftLeft.Height)
                {
                    // double rotation:
                    //      5     =>     5     =>     4
                    //   2     6      4     6      2     5
                    // 1   4        2   3        1   3     6
                    //    3        1
                    return new ImHashMap<K, V>(leftRight._data,
                        new ImHashMap<K, V>(left._data, leftLeft, leftRight.Left),
                        new ImHashMap<K, V>(data, leftRight.Right, right));
                }

                // one rotation:
                //      5     =>     2
                //   2     6      1     5
                // 1   4              4   6
                return new ImHashMap<K, V>(left._data,
                    leftLeft, new ImHashMap<K, V>(data, leftRight, right));
            }

            if (delta < -1)
            {
                var rightLeft = right.Left;
                var rightRight = right.Right;
                if (rightLeft.Height > rightRight.Height)
                {
                    return new ImHashMap<K, V>(rightLeft._data,
                        new ImHashMap<K, V>(data, left, rightLeft.Left),
                        new ImHashMap<K, V>(right._data, rightLeft.Right, rightRight));
                }

                return new ImHashMap<K, V>(right._data,
                    new ImHashMap<K, V>(data, left, rightLeft), rightRight);
            }

            return new ImHashMap<K, V>(data, left, right);
        }

        internal ImHashMap<K, V> Remove(int hash, K key, bool ignoreKey = false)
        {
            if (Height == 0)
                return this;

            ImHashMap<K, V> result;
            if (hash == Hash) // found node
            {
                if (ignoreKey || Equals(Key, key))
                {
                    if (!ignoreKey && Conflicts != null)
                        return ReplaceRemovedWithConflicted();

                    if (Height == 1) // remove node
                        return Empty;

                    if (Right.IsEmpty)
                        result = Left;
                    else if (Left.IsEmpty)
                        result = Right;
                    else
                    {
                        // we have two children, so remove the next highest node and replace this node with it.
                        var successor = Right;
                        while (!successor.Left.IsEmpty) successor = successor.Left;
                        result = new ImHashMap<K, V>(successor._data,
                            Left, Right.Remove(successor.Hash, default, ignoreKey: true));
                    }
                }
                else if (Conflicts != null)
                    return TryRemoveConflicted(key);
                else
                    return this; // if key is not matching and no conflicts to lookup - just return
            }
            else
                result = hash < Hash
                    ? Balance(_data, Left.Remove(hash, key, ignoreKey), Right)
                    : Balance(_data, Left, Right.Remove(hash, key, ignoreKey));

            return result;
        }

        private ImHashMap<K, V> TryRemoveConflicted(K key)
        {
            var index = Conflicts.Length - 1;
            while (index >= 0 && !Equals(Conflicts[index].Key, key)) --index;
            if (index == -1) // key is not found in conflicts - just return
                return this;

            if (Conflicts.Length == 1)
                return new ImHashMap<K, V>(new Data(Hash, Key, Value), Left, Right);
            var shrinkedConflicts = new KV<K, V>[Conflicts.Length - 1];
            var newIndex = 0;
            for (var i = 0; i < Conflicts.Length; ++i)
                if (i != index) shrinkedConflicts[newIndex++] = Conflicts[i];
            return new ImHashMap<K, V>(new Data(Hash, Key, Value, shrinkedConflicts), Left, Right);
        }

        private ImHashMap<K, V> ReplaceRemovedWithConflicted()
        {
            if (Conflicts.Length == 1)
                return new ImHashMap<K, V>(new Data(Hash, Conflicts[0].Key, Conflicts[0].Value), Left, Right);
            var shrinkedConflicts = new KV<K, V>[Conflicts.Length - 1];
            Array.Copy(Conflicts, 1, shrinkedConflicts, 0, shrinkedConflicts.Length);
            return new ImHashMap<K, V>(new Data(Hash, Conflicts[0].Key, Conflicts[0].Value, shrinkedConflicts), Left, Right);
        }

        #endregion
    }

    /// ImHashMap methods for faster performance
    public static class ImHashMap
    {
        /// Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, K key, V defaultValue = default)
        {
            if (map.Height == 0)
                return defaultValue;

            var hash = key.GetHashCode();

            while (map.Hash != hash)
            {
                map = hash < map.Hash ? map.Left : map.Right;
                if (map.Height == 0)
                    return defaultValue;
            }

            return ReferenceEquals(key, map.Key) || key.Equals(map.Key)
                ? map.Value : map.GetConflictedValueOrDefault(key, defaultValue);
        }

        /// Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<V>(this ImHashMap<Type, V> map, Type key, V defaultValue = default)
        {
            if (map.Height == 0)
                return defaultValue;

            var hash = key.GetHashCode();
            while (hash != map.Hash)
            {
                map = hash < map.Hash ? map.Left : map.Right;
                if (map.Height == 0)
                    return defaultValue;
            }

            // we don't need to check `Height != 0` again cause in that case `key` will be `null` and `ReferenceEquals` will fail
            return ReferenceEquals(key, map.Key) ? map.Value : map.GetConflictedValueOrDefault(key, defaultValue);
        }

        /// Returns true if key is found and sets the value.
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<K, V>(this ImHashMap<K, V> map, K key, out V value)
        {
            if (map.Height != 0)
            {
                var hash = key.GetHashCode();
                do
                {
                    if (hash < map.Hash)
                        map = map.Left;
                    else if (hash > map.Hash)
                        map = map.Right;
                    else if (ReferenceEquals(key, map.Key) || key.Equals(map.Key))
                    {
                        value = map.Value;
                        return true;
                    }
                    else
                    {
                        return map.TryFindConflictedValue(key, out value);
                    }
                }
                while (map.Height != 0);
            }

            value = default;
            return false;
        }

        /// Returns true if key is found and sets the value.
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<V>(this ImHashMap<string, V> map, string key, out V value)
        {
            if (map.Height != 0)
            {
                var hash = key.GetHashCode();
                do
                {
                    if (hash < map.Hash)
                        map = map.Left;
                    else if (hash > map.Hash)
                        map = map.Right;
                    else if (key.Equals(map.Key))
                    {
                        value = map.Value;
                        return true;
                    }
                    else
                    {
                        return map.TryFindConflictedValue(key, out value);
                    }
                }
                while (map.Height != 0);
            }

            value = default;
            return false;
        }

        /// Returns true if key is found and the result value.
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<V>(this ImHashMap<Type, V> map, Type key, out V value)
        {
            if (map.Height != 0)
            {
                var hash = key.GetHashCode();
                do
                {
                    if (hash < map.Hash)
                        map = map.Left;
                    else if (hash > map.Hash)
                        map = map.Right;
                    else if (key == map.Key)
                    {
                        value = map.Value;
                        return true;
                    }
                    else
                    {
                        return map.TryFindConflictedValue(key, out value);
                    }
                }
                while (map.Height != 0);
            }

            value = default;
            return false;
        }
    }

    /// The array of ImMap of constant width wide, where the `Key` is partitioned using last bits and the rest of bits are combined with `Height` into a single `int32`
    public struct ImMapArray<V>
    {
        // Slots count and mask to partition the Key across the slots 
        internal const int SLOT_COUNT = 32;
        internal const int HEIGHT_MASK = SLOT_COUNT - 1;
        internal const int KEY_MASK = ~HEIGHT_MASK;

        /// Creates en empty array
        [MethodImpl((MethodImplOptions)256)]
        public static ImMapArray<V> Create()
        {
            var slots = new ImMapSlot<V>[SLOT_COUNT];
            for (var i = 0; i < SLOT_COUNT; ++i)
                slots[i] = ImMapSlot<V>.Empty;
            return new ImMapArray<V>(slots);
        }

        internal readonly ImMapSlot<V>[] Slots;
        private ImMapArray(ImMapSlot<V>[] slots) => Slots = slots;

        /// Returns a new tree with added or updated value for specified key.
        [MethodImpl((MethodImplOptions)256)]
        public void AddOrUpdate(int key, V value)
        {
            ref var slot = ref Slots[key & HEIGHT_MASK];
            var copy = slot;

            var newSlot = copy.KeyPlusHeight == 0 ? ImMapSlot<V>.Leaf(key & KEY_MASK, value)
                : (key & KEY_MASK) != copy.KeyPart ? copy.AddOrUpdate(key & KEY_MASK, value)
                : new ImMapSlot<V>(copy.KeyPlusHeight, value, copy.Left, copy.Right);

            if (Interlocked.CompareExchange(ref slot, newSlot, copy) != copy)
                RefAddOrUpdateSlot(ref slot, key, value);
        }

        private static void RefAddOrUpdateSlot(ref ImMapSlot<V> slot, int key, V value) =>
            Ref.Swap(ref slot, key, value, (s, k, v) =>
                s.KeyPlusHeight == 0 ? ImMapSlot<V>.Leaf(k, v)
                : k != s.KeyPart ? s.AddOrUpdate(k, v)
                : new ImMapSlot<V>(s.KeyPlusHeight, v, s.Left, s.Right));

        /// <summary>Returns new tree with added or updated value for specified key.</summary>
        /// <param name="key">Key</param> <param name="value">Value</param>
        /// <param name="updateValue">(optional) Delegate to calculate new value from and old and a new value.</param>
        /// <returns>New tree.</returns>
        [MethodImpl((MethodImplOptions)256)]
        public void AddOrUpdate(int key, V value, Update<V> updateValue)
        {
            ref var slot = ref Slots[key & HEIGHT_MASK];
            var copy = slot;

            var newSlot = copy.AddOrUpdate(key & KEY_MASK, value, false, updateValue);
            if (Interlocked.CompareExchange(ref slot, newSlot, copy) != copy)
                RefAddOrUpdateSlot(ref slot, key & KEY_MASK, value, updateValue);
        }

        private static void RefAddOrUpdateSlot(ref ImMapSlot<V> slot, int key, V value, Update<V> updateValue) =>
            Ref.Swap(ref slot, key, value, updateValue, (s, k, v, u) => s.AddOrUpdate(k, v, false, u));

        /// <summary>Returns new tree with updated value for the key, Or the same tree if key was not found.</summary>
        /// <param name="key"></param> <param name="value"></param>
        /// <returns>New tree if key is found, or the same tree otherwise.</returns>
        [MethodImpl((MethodImplOptions)256)]
        public void Update(int key, V value)
        {
            ref var slot = ref Slots[key & HEIGHT_MASK];
            var copy = slot;
            var newSlot = copy.AddOrUpdate(key & KEY_MASK, value, true, null);
            if (Interlocked.CompareExchange(ref slot, newSlot, copy) != copy)
                RefUpdateSlot(ref slot, key & KEY_MASK, value);
        }

        private static void RefUpdateSlot(ref ImMapSlot<V> slot, int key, V value) =>
            Ref.Swap(ref slot, key, value, (s, k, v) => s.AddOrUpdate(k, v, true, null));

        /// Get value for found key or the default value otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public V GetValueOrDefault(int key)
        {
            var slot = Slots[key & HEIGHT_MASK];

            key &= KEY_MASK;
            while (slot.KeyPlusHeight != 0 && key != slot.KeyPart)
                slot = key < slot.KeyPart ? slot.Left : slot.Right;

            return slot.Value;
        }

        /// Returns true if key is found and sets the value.
        [MethodImpl((MethodImplOptions)256)]
        public bool TryFind(int key, out V value)
        {
            var slot = Slots[key & HEIGHT_MASK];

            key &= KEY_MASK;
            while (slot.KeyPlusHeight != 0 && key != slot.KeyPart)
                slot = key < slot.KeyPart ? slot.Left : slot.Right;

            if (slot.KeyPlusHeight == 0)
            {
                value = default;
                return false;
            }

            value = slot.Value;
            return true;
        }

        /*
                    if (Height == 0)
                    {
                        foundValue = default;
                        newMap = new ImMap<V>(key, value);
                        return false;
                    }

                    var map = this;
                    do
                    {
                        if (map.Key == key)
                        {
                            newMap = null;
                            foundValue = map.Value;
                            return true;
                        }

                        map = key < map.Key ? map.Left : map.Right;
                    } while (map.Height != 0);


                    foundValue = default;
                    newMap = AddImpl(key, value);
                    return false;

            ---
            ref var slot = ref Slots[key & HEIGHT_MASK];
            var copy = slot;

            var newSlot = copy.KeyPlusHeight == 0 ? ImMapSlot<V>.Leaf(key & KEY_MASK, value)
                : (key & KEY_MASK) != copy.KeyPart ? copy.AddOrUpdate(key & KEY_MASK, value)
                : new ImMapSlot<V>(copy.KeyPlusHeight, value, copy.Left, copy.Right);

            if (Interlocked.CompareExchange(ref slot, newSlot, copy) != copy)
                RefAddOrUpdateSlot(ref slot, key, value);

         */

        /// Combines TryFind and Add methods returning either found value by key or adding key-value to the new tree and returning it instead
        [MethodImpl((MethodImplOptions)256)]
        public bool GetOrAdd(int key, V value, out V existingValue)
        {
            ref var slot = ref Slots[key & HEIGHT_MASK];
            key &= KEY_MASK;
            if (slot.KeyPlusHeight == 0)
            {
                var copy = slot;
                if (Interlocked.CompareExchange(ref slot, ImMapSlot<V>.Leaf(key, value), copy) != copy)
                    RefAddOrUpdateSlot(ref slot, key, value);
            }

            key &= KEY_MASK;
            while (slot.KeyPlusHeight != 0 && key != slot.KeyPart)
                slot = key < slot.KeyPart ? slot.Left : slot.Right;

            if (slot.KeyPlusHeight == 0)
            {
                value = default;
                return false;
            }

            value = slot.Value;
            return true;
        }
    }

    internal sealed class ImMapSlot<V>
    {
        /// Empty tree to start with
        public static readonly ImMapSlot<V> Empty = new ImMapSlot<V>(0, default, null, null);

        /// Combines height in lower bits and the trimmed key in upper bits
        public readonly int KeyPlusHeight;

        /// <summary>Value.</summary>
        public readonly V Value;

        /// <summary>Left sub-tree/branch, or empty.</summary>
        public readonly ImMapSlot<V> Left;

        /// <summary>Right sub-tree/branch, or empty.</summary>
        public readonly ImMapSlot<V> Right;

        /// The Key without last 4 bits
        public int KeyPart
        {
            [MethodImpl((MethodImplOptions)256)]
            get => KeyPlusHeight & ImMapArray<V>.KEY_MASK;
        }

        /// Height of longest sub-tree/branch plus 1. It is 0 for empty tree, and 1 for single node tree.
        public int Height
        {
            [MethodImpl((MethodImplOptions)256)]
            get => KeyPlusHeight & ImMapArray<V>.HEIGHT_MASK;
        }

        /// <summary>Returns true is tree is empty.</summary>
        public bool IsEmpty
        {
            [MethodImpl((MethodImplOptions)256)]
            get => KeyPlusHeight == 0;
        }

        /// Outputs the key value pair or empty if node is empty
        public override string ToString() => IsEmpty ? "empty" : "Node: " + KeyPart + " -> " + Value;

        internal ImMapSlot(int keyPlusHeight, V value, ImMapSlot<V> left, ImMapSlot<V> right)
        {
            KeyPlusHeight = keyPlusHeight;
            Value = value;
            Left = left;
            Right = right;
        }

        [MethodImpl((MethodImplOptions)256)]
        internal static ImMapSlot<V> Leaf(int key, V value) =>
            new ImMapSlot<V>(key | 1, value, Empty, Empty);

        [MethodImpl((MethodImplOptions)256)]
        internal static ImMapSlot<V> Branch(int key, V value, ImMapSlot<V> left, ImMapSlot<V> right) =>
            new ImMapSlot<V>(key | (left.Height > right.Height ? left.Height + 1 : right.Height + 1), value, left, right);

        internal ImMapSlot<V> AddOrUpdate(int key, V value)
        {
            if (key < KeyPart)
            {
                if (Left.KeyPlusHeight == 0)
                    return new ImMapSlot<V>(KeyPart | 2, Value, Leaf(key, value), Right);

                if (Left.KeyPart == key)
                    return new ImMapSlot<V>(KeyPart | Height, Value, Leaf(key, value), Right);

                if (Right.KeyPlusHeight == 0)
                {
                    // single rotation:
                    //      5     =>     2
                    //   2            1     5
                    // 1              
                    if (key < Left.KeyPart)
                        return new ImMapSlot<V>(Left.KeyPart | 2, Left.Value, Leaf(key, value), Leaf(KeyPart, Value));

                    // double rotation:
                    //      5     =>     5     =>     4
                    //   2            4            2     5
                    //     4        2               
                    return new ImMapSlot<V>(key | 2, value, Leaf(Left.KeyPart, Left.Value), Leaf(KeyPart, Value));
                }

                var left = Left.AddOrUpdate(key, value);

                if (left.Height > Right.Height + 1) // left is longer by 2, rotate left
                {
                    var leftLeft = left.Left;
                    var leftRight = left.Right;

                    // single rotation:
                    //      5     =>     2
                    //   2     6      1     5
                    // 1   4              4   6
                    if (leftLeft.Height >= leftRight.Height)
                        return Branch(left.KeyPart, left.Value, leftLeft, Branch(KeyPart, Value, leftRight, Right));

                    // double rotation:
                    //      5     =>     5     =>     4
                    //   2     6      4     6      2     5
                    // 1   4        2   3        1   3     6
                    //    3        1
                    return Branch(leftRight.KeyPart, leftRight.Value,
                        Branch(left.KeyPart, left.Value, leftLeft, leftRight.Left),
                        Branch(KeyPart, Value, leftRight.Right, Right));
                }

                return Branch(KeyPart, Value, left, Right);
            }
            else
            {
                if (Right.KeyPlusHeight == 0)
                    return Branch(KeyPart | 2, Value, Left, Leaf(key, value));

                if (Right.KeyPart == key)
                    return Branch(KeyPart | Height, Value, Left, Leaf(key, value));

                if (Left.KeyPlusHeight == 0)
                {
                    // single rotation:
                    //      5     =>     8     
                    //         8      5     9
                    //           9
                    if (key >= Right.KeyPart)
                        return new ImMapSlot<V>(Right.KeyPart | 2, Right.Value, Leaf(KeyPart, Value), Leaf(key, value));

                    // double rotation:
                    //      5     =>     5     =>     7
                    //         8            7      5     8
                    //        7              8
                    return new ImMapSlot<V>(key | 2, value, Leaf(KeyPart, Value), Leaf(Right.KeyPart, Right.Value));
                }

                var right = Right.AddOrUpdate(key, value);
                if (right.Height > Left.Height + 1)
                {
                    var rightLeft = right.Left;
                    var rightRight = right.Right;

                    if (rightRight.Height >= rightLeft.Height)
                        return Branch(right.KeyPart, right.Value, Branch(KeyPart, Value, Left, rightLeft), rightRight);

                    return Branch(rightLeft.KeyPart, rightLeft.Value,
                        Branch(KeyPart, Value, Left, rightLeft.Left),
                        Branch(right.KeyPart, right.Value, rightLeft.Right, rightRight));
                }

                return Branch(KeyPart, Value, Left, right);
            }
        }

        // note: Not so much optimized (memory and performance wise) as a AddOrUpdateImpl without `update` delegate
        internal ImMapSlot<V> AddOrUpdate(int key, V value, bool updateOnly, Update<V> update) =>
            KeyPlusHeight == 0
                ? (updateOnly ? this : Leaf(key, value))
                : key == KeyPart
                    ? new ImMapSlot<V>(KeyPlusHeight, update == null ? value : update(Value, value), Left, Right)
                    : key < KeyPart // try update on left or right sub-tree
                        ? Balance(KeyPart, Value, Left.AddOrUpdate(key, value, updateOnly, update), Right)
                        : Balance(KeyPart, Value, Left, Right.AddOrUpdate(key, value, updateOnly, update));

        internal static ImMapSlot<V> Balance(int key, V value, ImMapSlot<V> left, ImMapSlot<V> right)
        {
            var delta = left.Height - right.Height;
            if (delta > 1) // left is longer by 2, rotate left
            {
                var leftLeft = left.Left;
                var leftRight = left.Right;
                if (leftRight.Height > leftLeft.Height)
                {
                    // double rotation:
                    //      5     =>     5     =>     4
                    //   2     6      4     6      2     5
                    // 1   4        2   3        1   3     6
                    //    3        1
                    return Branch(leftRight.KeyPart, leftRight.Value,
                        Branch(left.KeyPart, left.Value, leftLeft, leftRight.Left),
                        Branch(key, value, leftRight.Right, right));
                }

                // single rotation:
                //      5     =>     2
                //   2     6      1     5
                // 1   4              4   6
                return Branch(left.KeyPart, left.Value, leftLeft, Branch(key, value, leftRight, right));
            }

            if (delta < -1)
            {
                var rightLeft = right.Left;
                var rightRight = right.Right;
                if (rightLeft.Height > rightRight.Height)
                    return Branch(rightLeft.KeyPart, rightLeft.Value,
                        Branch(key, value, left, rightLeft.Left),
                        Branch(right.KeyPart, right.Value, rightLeft.Right, rightRight));

                return Branch(right.KeyPart, right.Value, Branch(key, value, left, rightLeft), rightRight);
            }

            return Branch(key, value, left, right);
        }
    }
}
